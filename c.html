
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>anyArrayV2: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/aid297/aid/array/anyArrayV2/any_array.attr.go (60.0%)</option>
				
				<option value="file1">github.com/aid297/aid/array/anyArrayV2/any_array.go (21.3%)</option>
				
				<option value="file2">github.com/aid297/aid/common/types.go (0.0%)</option>
				
				<option value="file3">github.com/aid297/aid/compression/zlib.go (70.6%)</option>
				
				<option value="file4">github.com/aid297/aid/daemon/daemon.go (0.0%)</option>
				
				<option value="file5">github.com/aid297/aid/db/main.go (23.8%)</option>
				
				<option value="file6">github.com/aid297/aid/db/parser.go (61.7%)</option>
				
				<option value="file7">github.com/aid297/aid/db/storage.go (63.6%)</option>
				
				<option value="file8">github.com/aid297/aid/db/types.go (71.8%)</option>
				
				<option value="file9">github.com/aid297/aid/dict/anyDictV2/any_dict.attr.go (0.0%)</option>
				
				<option value="file10">github.com/aid297/aid/dict/anyDictV2/any_dict.go (0.0%)</option>
				
				<option value="file11">github.com/aid297/aid/dict/any_dict.go (74.2%)</option>
				
				<option value="file12">github.com/aid297/aid/digest/bcrypt.go (0.0%)</option>
				
				<option value="file13">github.com/aid297/aid/digest/md5.go (0.0%)</option>
				
				<option value="file14">github.com/aid297/aid/digest/sha256.go (0.0%)</option>
				
				<option value="file15">github.com/aid297/aid/digest/sm3.go (0.0%)</option>
				
				<option value="file16">github.com/aid297/aid/excel/errors.go (0.0%)</option>
				
				<option value="file17">github.com/aid297/aid/excel/excelV2/cell.attr.go (85.0%)</option>
				
				<option value="file18">github.com/aid297/aid/excel/excelV2/cell.go (78.6%)</option>
				
				<option value="file19">github.com/aid297/aid/excel/excelV2/reader.attr.go (0.0%)</option>
				
				<option value="file20">github.com/aid297/aid/excel/excelV2/reader.go (50.9%)</option>
				
				<option value="file21">github.com/aid297/aid/excel/excelV2/row.attr.go (0.0%)</option>
				
				<option value="file22">github.com/aid297/aid/excel/excelV2/row.go (0.0%)</option>
				
				<option value="file23">github.com/aid297/aid/excel/excelV2/util.go (11.1%)</option>
				
				<option value="file24">github.com/aid297/aid/excel/excelV2/writer.attr.go (23.8%)</option>
				
				<option value="file25">github.com/aid297/aid/excel/excelV2/writer.go (64.5%)</option>
				
				<option value="file26">github.com/aid297/aid/excel/excel_cell.go (0.0%)</option>
				
				<option value="file27">github.com/aid297/aid/excel/excel_reader.go (0.0%)</option>
				
				<option value="file28">github.com/aid297/aid/excel/excel_row.go (0.0%)</option>
				
				<option value="file29">github.com/aid297/aid/excel/excel_util.go (0.0%)</option>
				
				<option value="file30">github.com/aid297/aid/excel/excel_writer.go (0.0%)</option>
				
				<option value="file31">github.com/aid297/aid/filesystem/file_manager.go (0.0%)</option>
				
				<option value="file32">github.com/aid297/aid/filesystem/filesystem.go (14.3%)</option>
				
				<option value="file33">github.com/aid297/aid/filesystem/filesystemV2/dir.go (45.1%)</option>
				
				<option value="file34">github.com/aid297/aid/filesystem/filesystemV2/errors.go (0.0%)</option>
				
				<option value="file35">github.com/aid297/aid/filesystem/filesystemV2/file.go (63.4%)</option>
				
				<option value="file36">github.com/aid297/aid/filesystem/filesystemV2/filesystem.go (22.2%)</option>
				
				<option value="file37">github.com/aid297/aid/filesystem/filesystemV3/dir.attr.go (70.0%)</option>
				
				<option value="file38">github.com/aid297/aid/filesystem/filesystemV3/dir.go (49.3%)</option>
				
				<option value="file39">github.com/aid297/aid/filesystem/filesystemV3/file.attr.go (80.0%)</option>
				
				<option value="file40">github.com/aid297/aid/filesystem/filesystemV3/file.go (54.4%)</option>
				
				<option value="file41">github.com/aid297/aid/filesystem/filesystemV3/operation.go (50.0%)</option>
				
				<option value="file42">github.com/aid297/aid/filesystem/filesystemV3/utils.go (69.4%)</option>
				
				<option value="file43">github.com/aid297/aid/honestMan/errors.go (0.0%)</option>
				
				<option value="file44">github.com/aid297/aid/honestMan/honest_man.go (0.0%)</option>
				
				<option value="file45">github.com/aid297/aid/httpClient/errors.go (0.0%)</option>
				
				<option value="file46">github.com/aid297/aid/httpClient/httpClientV2/http_client.attr.go (22.5%)</option>
				
				<option value="file47">github.com/aid297/aid/httpClient/httpClientV2/http_client.go (43.6%)</option>
				
				<option value="file48">github.com/aid297/aid/httpClient/http_client.go (0.0%)</option>
				
				<option value="file49">github.com/aid297/aid/httpClient/http_client_download.go (0.0%)</option>
				
				<option value="file50">github.com/aid297/aid/httpClient/http_client_multiple.go (0.0%)</option>
				
				<option value="file51">github.com/aid297/aid/httpLimiter/ip_limiter.go (0.0%)</option>
				
				<option value="file52">github.com/aid297/aid/httpLimiter/route_limiter.go (0.0%)</option>
				
				<option value="file53">github.com/aid297/aid/lock/map_lock.go (55.6%)</option>
				
				<option value="file54">github.com/aid297/aid/logger/zap_provider.go (72.4%)</option>
				
				<option value="file55">github.com/aid297/aid/logger/zap_provider_config.go (90.0%)</option>
				
				<option value="file56">github.com/aid297/aid/main.go (0.0%)</option>
				
				<option value="file57">github.com/aid297/aid/operation/manifold.go (0.0%)</option>
				
				<option value="file58">github.com/aid297/aid/operation/math.go (0.0%)</option>
				
				<option value="file59">github.com/aid297/aid/operation/operationV2/ternary.go (40.6%)</option>
				
				<option value="file60">github.com/aid297/aid/operation/operationV2/ternary_attributer.go (70.0%)</option>
				
				<option value="file61">github.com/aid297/aid/operation/ternary.go (25.0%)</option>
				
				<option value="file62">github.com/aid297/aid/ptr/new.go (100.0%)</option>
				
				<option value="file63">github.com/aid297/aid/redisPool/redis.set.go (0.0%)</option>
				
				<option value="file64">github.com/aid297/aid/redisPool/redis_pool.go (0.0%)</option>
				
				<option value="file65">github.com/aid297/aid/reflection/reflection.go (0.0%)</option>
				
				<option value="file66">github.com/aid297/aid/reflection/reflection_attributer.go (0.0%)</option>
				
				<option value="file67">github.com/aid297/aid/regexp/regexp.go (0.0%)</option>
				
				<option value="file68">github.com/aid297/aid/regexp/regexp_attributer.go (0.0%)</option>
				
				<option value="file69">github.com/aid297/aid/retry/retry.go (61.9%)</option>
				
				<option value="file70">github.com/aid297/aid/retry/retry_attribute.go (100.0%)</option>
				
				<option value="file71">github.com/aid297/aid/rpc/rpcServer/rpc_server.go (37.5%)</option>
				
				<option value="file72">github.com/aid297/aid/rpc/rpcServer/rpc_server_pool.go (24.2%)</option>
				
				<option value="file73">github.com/aid297/aid/secret/asymmetric/pem.go (0.0%)</option>
				
				<option value="file74">github.com/aid297/aid/secret/asymmetric/rsa.go (0.0%)</option>
				
				<option value="file75">github.com/aid297/aid/secret/secret.go (0.0%)</option>
				
				<option value="file76">github.com/aid297/aid/secret/symmetric/aes.go (83.8%)</option>
				
				<option value="file77">github.com/aid297/aid/secret/symmetric/cbc.go (0.0%)</option>
				
				<option value="file78">github.com/aid297/aid/secret/symmetric/ecb.go (72.5%)</option>
				
				<option value="file79">github.com/aid297/aid/setting/setting.attr.go (0.0%)</option>
				
				<option value="file80">github.com/aid297/aid/setting/setting.go (0.0%)</option>
				
				<option value="file81">github.com/aid297/aid/sonarqube/client.go (0.0%)</option>
				
				<option value="file82">github.com/aid297/aid/steam/steam.go (0.0%)</option>
				
				<option value="file83">github.com/aid297/aid/steam/steam_attributer.go (0.0%)</option>
				
				<option value="file84">github.com/aid297/aid/str/buffer.go (12.7%)</option>
				
				<option value="file85">github.com/aid297/aid/str/html.attr.go (84.8%)</option>
				
				<option value="file86">github.com/aid297/aid/str/html.go (100.0%)</option>
				
				<option value="file87">github.com/aid297/aid/str/markdown.attr.go (55.6%)</option>
				
				<option value="file88">github.com/aid297/aid/str/markdown.go (85.7%)</option>
				
				<option value="file89">github.com/aid297/aid/str/rand.go (0.0%)</option>
				
				<option value="file90">github.com/aid297/aid/str/regexp.go (30.4%)</option>
				
				<option value="file91">github.com/aid297/aid/str/regexp_attributer.go (15.4%)</option>
				
				<option value="file92">github.com/aid297/aid/str/terminal.go (0.0%)</option>
				
				<option value="file93">github.com/aid297/aid/str/transfer.go (0.0%)</option>
				
				<option value="file94">github.com/aid297/aid/time/time.go (0.0%)</option>
				
				<option value="file95">github.com/aid297/aid/validator/errors.go (0.0%)</option>
				
				<option value="file96">github.com/aid297/aid/validator/validator.go (46.2%)</option>
				
				<option value="file97">github.com/aid297/aid/validator/validatorV2/validator.go (51.2%)</option>
				
				<option value="file98">github.com/aid297/aid/validator/validatorV3/check.bool.go (0.0%)</option>
				
				<option value="file99">github.com/aid297/aid/validator/validatorV3/check.float.go (0.0%)</option>
				
				<option value="file100">github.com/aid297/aid/validator/validatorV3/check.int.go (12.4%)</option>
				
				<option value="file101">github.com/aid297/aid/validator/validatorV3/check.slice.go (0.0%)</option>
				
				<option value="file102">github.com/aid297/aid/validator/validatorV3/check.string.go (21.5%)</option>
				
				<option value="file103">github.com/aid297/aid/validator/validatorV3/check.time.go (0.0%)</option>
				
				<option value="file104">github.com/aid297/aid/validator/validatorV3/check.uint.go (0.0%)</option>
				
				<option value="file105">github.com/aid297/aid/validator/validatorV3/checker.go (60.0%)</option>
				
				<option value="file106">github.com/aid297/aid/validator/validatorV3/field_info.go (22.1%)</option>
				
				<option value="file107">github.com/aid297/aid/validator/validatorV3/validator.go (57.1%)</option>
				
				<option value="file108">github.com/aid297/aid/validator/validator_check_float.go (0.0%)</option>
				
				<option value="file109">github.com/aid297/aid/validator/validator_check_int.go (0.0%)</option>
				
				<option value="file110">github.com/aid297/aid/validator/validator_check_string.go (1.9%)</option>
				
				<option value="file111">github.com/aid297/aid/validator/validator_check_time.go (0.0%)</option>
				
				<option value="file112">github.com/aid297/aid/validator/validator_check_uint.go (0.0%)</option>
				
				<option value="file113">github.com/aid297/aid/web/backend/aid-web-backend-gin/api/httpAPI/health.api.go (0.0%)</option>
				
				<option value="file114">github.com/aid297/aid/web/backend/aid-web-backend-gin/api/httpAPI/v1HTTPAPI/rezip.api.go (0.0%)</option>
				
				<option value="file115">github.com/aid297/aid/web/backend/aid-web-backend-gin/api/httpAPI/v1HTTPAPI/uuid.api.go (0.0%)</option>
				
				<option value="file116">github.com/aid297/aid/web/backend/aid-web-backend-gin/command/help.cmd.go (0.0%)</option>
				
				<option value="file117">github.com/aid297/aid/web/backend/aid-web-backend-gin/command/web_service.cmd.go (0.0%)</option>
				
				<option value="file118">github.com/aid297/aid/web/backend/aid-web-backend-gin/initialize/config.init.go (0.0%)</option>
				
				<option value="file119">github.com/aid297/aid/web/backend/aid-web-backend-gin/initialize/timezone.init.go (0.0%)</option>
				
				<option value="file120">github.com/aid297/aid/web/backend/aid-web-backend-gin/initialize/zap.init.go (0.0%)</option>
				
				<option value="file121">github.com/aid297/aid/web/backend/aid-web-backend-gin/main.go (0.0%)</option>
				
				<option value="file122">github.com/aid297/aid/web/backend/aid-web-backend-gin/middleware/httpMiddleware/recover_hander.mw.go (0.0%)</option>
				
				<option value="file123">github.com/aid297/aid/web/backend/aid-web-backend-gin/middleware/httpMiddleware/v1HTTPMiddleware/core.mw.go (0.0%)</option>
				
				<option value="file124">github.com/aid297/aid/web/backend/aid-web-backend-gin/middleware/httpMiddleware/v1HTTPMiddleware/timeout.mw.go (0.0%)</option>
				
				<option value="file125">github.com/aid297/aid/web/backend/aid-web-backend-gin/module/httpModule/http_response.mod.go (0.0%)</option>
				
				<option value="file126">github.com/aid297/aid/web/backend/aid-web-backend-gin/module/httpModule/v1HTTPModule/request/uuid_generate.req.go (0.0%)</option>
				
				<option value="file127">github.com/aid297/aid/web/backend/aid-web-backend-gin/module/httpModule/v1HTTPModule/response/uuid_generate.res.go (0.0%)</option>
				
				<option value="file128">github.com/aid297/aid/web/backend/aid-web-backend-gin/route/httpRoute/v1HTTPRoute/rezip.rout.go (0.0%)</option>
				
				<option value="file129">github.com/aid297/aid/web/backend/aid-web-backend-gin/route/httpRoute/v1HTTPRoute/uuid.rout.go (0.0%)</option>
				
				<option value="file130">github.com/aid297/aid/web/backend/aid-web-backend-gin/route/index.rout.go (0.0%)</option>
				
				<option value="file131">github.com/aid297/aid/web/backend/aid-web-backend-gin/service/httpService/v1HTTPService/uuid.srv.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package anyArrayV2

type (
        Attributer[T any] interface {
                Register(anyArray *AnyArray[T])
        }

        AttrList[T any]  struct{ list []T }
        AttrItems[T any] struct{ items []T }
        AttrLen[T any]   struct{ length int }
        AttrCap[T any]   struct{ cap int }
        AttrEmpty[T any] struct{}
)

func List[T any](list []T) Attributer[T] <span class="cov8" title="1">{ return AttrList[T]{list: list} }</span>

func (my AttrList[T]) Register(anyArray *AnyArray[T]) <span class="cov8" title="1">{
        anyArray.data = my.list
}</span>

func Items[T any](items ...T) Attributer[T] <span class="cov8" title="1">{ return AttrItems[T]{items: items} }</span>

func (my AttrItems[T]) Register(anyArray *AnyArray[T]) <span class="cov8" title="1">{
        anyArray.data = my.items
}</span>

func Len[T any](length int) Attributer[T] <span class="cov8" title="1">{ return AttrLen[T]{length: length} }</span>

func (my AttrLen[T]) Register(anyArray *AnyArray[T]) <span class="cov8" title="1">{ anyArray.data = make([]T, my.length) }</span>

func Cap[T any](cap int) Attributer[T] <span class="cov0" title="0">{ return AttrCap[T]{cap: cap} }</span>

func (my AttrCap[T]) Register(anyArray *AnyArray[T]) <span class="cov0" title="0">{ anyArray.data = make([]T, 0, my.cap) }</span>

func Empty[T any]() Attributer[T] <span class="cov0" title="0">{ return AttrEmpty[T]{} }</span>

func (my AttrEmpty[T]) Register(anyArray *AnyArray[T]) <span class="cov0" title="0">{ anyArray.data = make([]T, 0) }</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package anyArrayV2

import (
        "encoding/json"
        "fmt"
        "math/rand"
        "reflect"
        "slices"
        "sort"
        "strings"
        "sync"
        "time"

        "github.com/spf13/cast"
)

type AnyArray[T any] struct {
        data []T
        mu   *sync.RWMutex
}

func New[T any](attrs ...Attributer[T]) AnyArray[T] <span class="cov8" title="1">{
        a := AnyArray[T]{data: []T{}, mu: &amp;sync.RWMutex{}}
        return a.SetAttrs(attrs...)
}</span>

func NewList[T any](list []T) AnyArray[T] <span class="cov0" title="0">{ return New(List(list)) }</span>

func NewItems[T any](items ...T) AnyArray[T] <span class="cov0" title="0">{ return New(Items(items...)) }</span>

func (my AnyArray[T]) SetAttrs(attrs ...Attributer[T]) AnyArray[T] <span class="cov8" title="1">{
        if len(attrs) &gt; 0 </span><span class="cov8" title="1">{
                for idx := range attrs </span><span class="cov8" title="1">{
                        attrs[idx].Register(&amp;my)
                }</span>
        }
        <span class="cov8" title="1">return my</span>
}

func (my AnyArray[T]) Lock() AnyArray[T] <span class="cov0" title="0">{
        my.mu.Lock()
        return my
}</span>

func (my AnyArray[T]) Unlock() AnyArray[T] <span class="cov0" title="0">{
        my.mu.Unlock()
        return my
}</span>

func (my AnyArray[T]) RLock() AnyArray[T] <span class="cov0" title="0">{
        my.mu.RLock()
        return my
}</span>

func (my AnyArray[T]) RUnlock() AnyArray[T] <span class="cov0" title="0">{
        my.mu.RUnlock()
        return my
}</span>

// Empty 判断是否为空
func (my AnyArray[T]) Empty() bool <span class="cov8" title="1">{ return len(my.data) == 0 }</span>

// NotEmpty 判断是否不为空
func (my AnyArray[T]) NotEmpty() bool <span class="cov8" title="1">{ return !my.Empty() }</span>

// IfEmpty 判断是否为空：如果为空则执行回调
func (my AnyArray[T]) IfEmpty(fn func()) <span class="cov0" title="0">{
        if len(my.data) == 0 </span><span class="cov0" title="0">{
                fn()
        }</span>
}

// IfNotEmpty 判断是否不为空：如果不为空则执行回调
func (my AnyArray[T]) IfNotEmpty(fn func()) <span class="cov0" title="0">{
        if len(my.data) != 0 </span><span class="cov0" title="0">{
                fn()
        }</span>
}

// IfEmptyError 判断是否为空：如果为空则执行回调并返回错误
func (my AnyArray[T]) IfEmptyError(fn func() error) error <span class="cov0" title="0">{
        if len(my.data) == 0 </span><span class="cov0" title="0">{
                return fn()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// IfNotEmptyError 判断是否不为空：如果不为空则执行回调并返回错误
func (my AnyArray[T]) IfNotEmptyError(fn func() error) error <span class="cov0" title="0">{
        if len(my.data) != 0 </span><span class="cov0" title="0">{
                return fn()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Has 检查是否存在
func (my AnyArray[T]) Has(k int) bool <span class="cov0" title="0">{ return k &gt;= 0 &amp;&amp; k &lt; len(my.data) }</span>

func (my AnyArray[T]) SetValue(k int, v T) AnyArray[T] <span class="cov0" title="0">{
        my.data[k] = v
        return my
}</span>

// Get 获取值
func (my AnyArray[T]) GetValue(idx int) T <span class="cov8" title="1">{ return my.data[idx] }</span>

// GetValuePtr 获取值指针
func (my AnyArray[T]) GetValuePtr(idx int) *T <span class="cov0" title="0">{
        if idx &lt; 0 || idx &gt;= len(my.data) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;my.data[idx]</span>
}

// GetValueOrDefault 获取值：如果索引不存在则返回默认值
func (my AnyArray[T]) GetValueOrDefault(idx int, defaultValue T) T <span class="cov0" title="0">{
        if idx &lt; 0 || idx &gt;= len(my.data) </span><span class="cov0" title="0">{
                return defaultValue
        }</span>
        <span class="cov0" title="0">return my.data[idx]</span>
}

func (my AnyArray[T]) GetValues(indexes ...int) []T <span class="cov0" title="0">{
        res := make([]T, len(indexes))

        for k, idx := range indexes </span><span class="cov0" title="0">{
                res[k] = my.data[idx]
        }</span>

        <span class="cov0" title="0">return res</span>
}

func (my AnyArray[T]) Append(v ...T) AnyArray[T] <span class="cov8" title="1">{
        return New(List(append(my.data, v...)))
}</span>

// First 获取第一个值
func (my AnyArray[T]) First() T <span class="cov0" title="0">{
        var t T
        if len(my.data) &gt; 0 </span><span class="cov0" title="0">{
                return my.data[0]
        }</span>

        <span class="cov0" title="0">return t</span>
}

// Last 获取最后一个值
func (my AnyArray[T]) Last() T <span class="cov0" title="0">{
        var t T

        if len(my.data) &gt; 0 </span><span class="cov0" title="0">{
                return my.data[len(my.data)-1]
        }</span>

        <span class="cov0" title="0">return t</span>
}

// ToSlice 获取全部值：到切片
func (my AnyArray[T]) ToSlice() []T <span class="cov0" title="0">{ return my.data }</span>

// GetIndexes 获取所有索引
func (my AnyArray[T]) GetIndexes() []int <span class="cov0" title="0">{
        var indexes = make([]int, len(my.data))
        for i := range my.data </span><span class="cov0" title="0">{
                indexes[i] = i
        }</span>

        <span class="cov0" title="0">return indexes</span>
}

// GetIndexByValue 根据值获取索引下标
func (my AnyArray[T]) GetIndexByValue(value T) int <span class="cov0" title="0">{
        for idx, val := range my.data </span><span class="cov0" title="0">{
                if reflect.DeepEqual(val, value) </span><span class="cov0" title="0">{
                        return idx
                }</span>
        }

        <span class="cov0" title="0">return -1</span>
}

// GetIndexesByValues 通过值获取索引下标
func (my AnyArray[T]) GetIndexesByValues(values ...T) []int <span class="cov0" title="0">{
        var indexes []int
        for _, value := range values </span><span class="cov0" title="0">{
                for idx, val := range my.data </span><span class="cov0" title="0">{
                        if reflect.DeepEqual(val, value) </span><span class="cov0" title="0">{
                                indexes = append(indexes, idx)
                        }</span>
                }
        }

        <span class="cov0" title="0">return indexes</span>
}

// Shuffle 打乱切片中的元素顺序
func (my AnyArray[T]) Shuffle() AnyArray[T] <span class="cov0" title="0">{
        randStr := rand.New(rand.NewSource(time.Now().UnixNano()))
        newData := my.data

        for i := range my.data </span><span class="cov0" title="0">{
                j := randStr.Intn(i + 1)                        // 生成 [0, i] 范围内的随机数
                newData[i], newData[j] = newData[j], newData[i] // 交换元素
        }</span>

        <span class="cov0" title="0">return New(List(newData))</span>
}

// Length 获取数组长度
func (my AnyArray[T]) Length() int <span class="cov8" title="1">{ return len(my.data) }</span>

// LengthNotEmpty 获取非0值长度
func (my AnyArray[T]) LengthNotEmpty() int <span class="cov0" title="0">{ return my.RemoveEmpty().Length() }</span>

// Filter 过滤数组值
func (my AnyArray[T]) Filter(fn func(item T) bool) AnyArray[T] <span class="cov0" title="0">{
        j := 0
        ret := make([]T, len(my.data))
        for i := range my.data </span><span class="cov0" title="0">{
                if fn(my.data[i]) </span><span class="cov0" title="0">{
                        ret[j] = my.data[i]
                        j++
                }</span>
        }

        <span class="cov0" title="0">return New(List(ret[:j]))</span>
}

// RemoveEmpty 清除0值元素
func (my AnyArray[T]) RemoveEmpty() AnyArray[T] <span class="cov0" title="0">{
        return my.Filter(func(item T) bool </span><span class="cov0" title="0">{
                ref := reflect.ValueOf(item)

                if ref.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                        if ref.IsNil() </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov0" title="0">if ref.Elem().IsZero() </span><span class="cov0" title="0">{
                                return false
                        }</span>
                } else<span class="cov0" title="0"> {
                        if ref.IsZero() </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }

                <span class="cov0" title="0">return true</span>
        })
}

// Join 拼接字符串
func (my AnyArray[T]) Join(sep string) string <span class="cov0" title="0">{
        values := make([]string, my.Length())
        for idx := range my.data </span><span class="cov0" title="0">{
                values[idx] = cast.ToString(my.data[idx])
        }</span>

        <span class="cov0" title="0">return strings.Join(values, sep)</span>
}

// JoinNotEmpty 拼接非空元素
func (my AnyArray[T]) JoinNotEmpty(sep string) string <span class="cov0" title="0">{ return my.RemoveEmpty().Join(sep) }</span>

func (my AnyArray[T]) in(target T) bool <span class="cov8" title="1">{
        for idx := range my.data </span><span class="cov8" title="1">{
                if reflect.DeepEqual(target, my.data[idx]) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// In 检查值是否存在
func (my AnyArray[T]) In(targets ...T) bool <span class="cov8" title="1">{ return slices.ContainsFunc(targets, my.in) }</span>

// NotIn 检查值是否不存在
func (my AnyArray[T]) NotIn(targets ...T) bool <span class="cov0" title="0">{ return !slices.ContainsFunc(targets, my.in) }</span>

func (my AnyArray[T]) IfIn(fn func(), targets ...T) <span class="cov0" title="0">{
        if my.In(targets...) </span><span class="cov0" title="0">{
                fn()
        }</span>
}

func (my AnyArray[T]) IfNotIn(fn func(), targets ...T) <span class="cov0" title="0">{
        if my.NotIn(targets...) </span><span class="cov0" title="0">{
                fn()
        }</span>
}

func (my AnyArray[T]) IfInError(fn func() error, targets ...T) error <span class="cov0" title="0">{
        if my.In(targets...) </span><span class="cov0" title="0">{
                return fn()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (my AnyArray[T]) IfNotInError(fn func() error, targets ...T) error <span class="cov0" title="0">{
        if my.NotIn(targets...) </span><span class="cov0" title="0">{
                return fn()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// AllEmpty 判断当前数组是否0空
func (my AnyArray[T]) AllEmpty() bool <span class="cov0" title="0">{ return my.RemoveEmpty().Length() == 0 }</span>

// AnyEmpty 判断当前数组中是否存在0值
func (my AnyArray[T]) AnyEmpty() bool <span class="cov0" title="0">{ return my.RemoveEmpty().Length() != my.Length() }</span>

// Chunk 分块
func (my AnyArray[T]) Chunk(size int) [][]T <span class="cov0" title="0">{
        var chunks [][]T
        for i := 0; i &lt; len(my.data); i += size </span><span class="cov0" title="0">{
                end := min(i+size, len(my.data))
                chunks = append(chunks, my.data[i:end])
        }</span>

        <span class="cov0" title="0">return chunks</span>
}

// Pluck 获取数组中指定字段的值
func (my AnyArray[T]) Pluck(fn func(item T) any) AnyArray[any] <span class="cov0" title="0">{
        var ret = make([]any, 0)
        for _, v := range my.data </span><span class="cov0" title="0">{
                ret = append(ret, fn(v))
        }</span>

        <span class="cov0" title="0">return New(List(ret))</span>
}

// Intersection 取交集
func (my AnyArray[T]) Intersection(other AnyArray[T]) AnyArray[T] <span class="cov8" title="1">{
        if other.Empty() </span><span class="cov0" title="0">{
                return New[T]()
        }</span>

        <span class="cov8" title="1">var intersection = make([]T, 0)
        for idx := range my.data </span><span class="cov8" title="1">{
                if other.In(my.data[idx]) </span><span class="cov8" title="1">{
                        intersection = append(intersection, my.data[idx])
                }</span>
        }

        <span class="cov8" title="1">return New(List(intersection))</span>
}

// IntersectionBySlice 取交集：通过切片
func (my AnyArray[T]) IntersectionBySlice(other ...T) AnyArray[T] <span class="cov8" title="1">{
        return my.Intersection(New(List(other)))
}</span>

// Difference 取差集
func (my AnyArray[T]) Difference(other AnyArray[T]) AnyArray[T] <span class="cov8" title="1">{
        if other.Empty() </span><span class="cov0" title="0">{
                return New[T]()
        }</span>

        <span class="cov8" title="1">var difference = make([]T, 0)
        for _, value := range my.data </span><span class="cov8" title="1">{
                if !other.In(value) </span><span class="cov8" title="1">{
                        difference = append(difference, value)
                }</span>
        }

        <span class="cov8" title="1">return New(List(difference))</span>
}

// DifferenceBySlice 取差集：通过切片
func (my AnyArray[T]) DifferenceBySlice(other ...T) AnyArray[T] <span class="cov8" title="1">{
        return my.Difference(New(List(other)))
}</span>

// Union 取并集
func (my AnyArray[T]) Union(other AnyArray[T]) AnyArray[T] <span class="cov0" title="0">{
        if other.Empty() </span><span class="cov0" title="0">{
                return New[T]()
        }</span>

        <span class="cov0" title="0">var union = make([]T, 0)
        union = append(union, my.data...)

        for _, value := range other.data </span><span class="cov0" title="0">{
                if !my.In(value) </span><span class="cov0" title="0">{
                        union = append(union, value)
                }</span>
        }

        <span class="cov0" title="0">return New(List(union))</span>
}

// UnionBySlice 取并集：通过切片
func (my AnyArray[T]) UnionBySlice(other []T) AnyArray[T] <span class="cov0" title="0">{
        return my.Union(New(List(other)))
}</span>

// Unique 去重
func (my AnyArray[T]) Unique() AnyArray[T] <span class="cov8" title="1">{
        seen := make(map[string]struct{}) // 使用空结构体作为值，因为我们只关心键
        result := make([]T, 0)

        for _, value := range my.data </span><span class="cov8" title="1">{
                key := fmt.Sprintf("%v", value)
                if _, exists := seen[key]; !exists </span><span class="cov8" title="1">{
                        seen[key] = struct{}{}
                        result = append(result, value)
                }</span>
        }

        <span class="cov8" title="1">return New(List(result))</span>
}

// RemoveByIndex 根据索引删除元素
func (my AnyArray[T]) RemoveByIndex(index int) AnyArray[T] <span class="cov8" title="1">{
        if index &lt; 0 || index &gt;= len(my.data) </span><span class="cov0" title="0">{
                return my
        }</span>

        <span class="cov8" title="1">return New(List(append(my.data[:index], my.data[index+1:]...)))</span>
}

// RemoveByIndexes 根据索引删除元素
func (my AnyArray[T]) RemoveByIndexes(indexes ...int) AnyArray[T] <span class="cov0" title="0">{
        newData := make([]T, 0, len(my.data))
        myIndexes := make([]int, 0, len(indexes))

        for idx := range indexes </span><span class="cov0" title="0">{
                if indexes[idx] &lt; 0 || indexes[idx] &gt;= len(my.data) </span><span class="cov0" title="0">{
                        myIndexes = append(myIndexes, indexes[idx])
                }</span>
        }

        <span class="cov0" title="0">for idx := range my.data </span><span class="cov0" title="0">{
                for idx2 := range myIndexes </span><span class="cov0" title="0">{
                        if idx == idx2 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">newData = append(newData, my.data[idx])</span>
                }
        }

        <span class="cov0" title="0">return New(List(newData))</span>
}

// RemoveByValue 删除数组中对应的目标
func (my AnyArray[T]) RemoveByValue(target T) AnyArray[T] <span class="cov0" title="0">{
        var ret = make([]T, len(my.data))
        j := 0
        for _, value := range my.data </span><span class="cov0" title="0">{
                if !reflect.DeepEqual(value, target) </span><span class="cov0" title="0">{
                        ret[j] = value
                        j++
                }</span>
        }

        <span class="cov0" title="0">return New(List(ret[:j]))</span>
}

// RemoveByValues 删除数组中对应的多个目标
func (my AnyArray[T]) RemoveByValues(targets ...T) AnyArray[T] <span class="cov0" title="0">{
        data := my.data

        for idx := range targets </span><span class="cov0" title="0">{
                data = New(List(data)).RemoveByValues(targets[idx]).data
        }</span>

        <span class="cov0" title="0">return New(List(data))</span>
}

// Every 循环处理每一个
func (my AnyArray[T]) Every(fn func(item T) T) AnyArray[T] <span class="cov0" title="0">{
        data := make([]T, len(my.data))
        for idx := range my.data </span><span class="cov0" title="0">{
                data[idx] = fn(my.data[idx])
        }</span>

        <span class="cov0" title="0">return New(List(data))</span>
}

// Each 遍历数组
func (my AnyArray[T]) Each(fn func(idx int, item T)) AnyArray[T] <span class="cov0" title="0">{
        for idx := range my.data </span><span class="cov0" title="0">{
                fn(idx, my.data[idx])
        }</span>

        <span class="cov0" title="0">return my</span>
}

// Sort 排序
func (my AnyArray[T]) Sort(fn func(i, j int) bool) AnyArray[T] <span class="cov0" title="0">{
        sort.Slice(my.data, fn)
        return my
}</span>

// Clean 清理数据
func (my AnyArray[T]) Clean() AnyArray[T] <span class="cov8" title="1">{
        my.data = make([]T, 0)
        return my
}</span>

// MarshalJSON 实现接口：json序列化
func (my AnyArray[T]) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{ return json.Marshal(&amp;my.data) }</span>

// UnmarshalJSON 实现接口：json反序列化
func (my AnyArray[T]) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{ return json.Unmarshal(data, &amp;my.data) }</span>

// ToString 导出string
func (my AnyArray[T]) ToString(formats ...string) string <span class="cov8" title="1">{
        var format = "%v"
        if len(formats) &gt; 0 </span><span class="cov0" title="0">{
                format = formats[0]
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf(format, my.data)</span>
}

// Cast 转换值类型
func Cast[SRC, DST any](aa AnyArray[SRC], fn func(value SRC) DST) AnyArray[DST] <span class="cov0" title="0">{
        if aa.Length() == 0 </span><span class="cov0" title="0">{
                return New[DST]()
        }</span>

        <span class="cov0" title="0">data := make([]DST, len(aa.data))
        for idx := range aa.data </span><span class="cov0" title="0">{
                data[idx] = fn(aa.data[idx])
        }</span>

        <span class="cov0" title="0">return New(List(data))</span>
}

// ToAny converts any slice to []any
func ToAny(slice any) []any <span class="cov0" title="0">{
        v := reflect.ValueOf(slice)
        if v.Kind() != reflect.Slice </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">result := make([]any, v.Len())
        for i := range v.Len() </span><span class="cov0" title="0">{
                result[i] = v.Index(i).Interface()
        }</span>

        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package common

import (
        "bytes"
        "encoding/binary"
        "encoding/json"
        "fmt"
        "math"
        "reflect"
        "strconv"
        "strings"
        "time"
)

var (
        emptyStringMap = map[string]struct{}{
                "":      {},
                "0":     {},
                "no":    {},
                "off":   {},
                "false": {},
        }
)

type iVal interface{ Val() any }

// iString is used for type assert api for String().
type iString interface{ String() string }

// iBool is used for type assert api for Bool().
type iBool interface{ Bool() bool }

// iInt64 is used for type assert api for Int64().
type iInt64 interface{ Int64() int64 }

// iUint64 is used for type assert api for Uint64().
type iUint64 interface{ Uint64() uint64 }

// iFloat32 is used for type assert api for Float32().
type iFloat32 interface{ Float32() float32 }

// iFloat64 is used for type assert api for Float64().
type iFloat64 interface{ Float64() float64 }

// iError is used for type assert api for Error().
type iError interface{ Error() string }

// iBytes is used for type assert api for Bytes().
type iBytes interface{ Bytes() []byte }

// iInterface is used for type assert api for Interface().
type iInterface interface{ Interface() any }

// iInterfaces is used for type assert api for Interfaces().
type iInterfaces interface{ Interfaces() []any }

// iFloats is used for type assert api for Floats().
type iFloats interface{ Floats() []float64 }

// iInts is used for type assert api for Ints().
type iInts interface{ Ints() []int }

// iStrings is used for type assert api for Strings().
type iStrings interface{ Strings() []string }

// iUints is used for type assert api for Uints().
type iUints interface{ Uints() []uint }

// iMapStrAny is the interface support for converting struct parameter to map.
type iMapStrAny interface{ MapStrAny() map[string]any }

// iUnmarshalValue is the interface for custom defined types customizing value assignment.
// Note that only pointer can implement interface iUnmarshalValue.
type iUnmarshalValue interface{ UnmarshalValue(any) error }

// iUnmarshalText is the interface for custom defined types customizing value assignment.
// Note that only pointer can implement interface iUnmarshalText.
type iUnmarshalText interface{ UnmarshalText(text []byte) error }

// iUnmarshalText is the interface for custom defined types customizing value assignment.
// Note that only pointer can implement interface iUnmarshalJSON.
type iUnmarshalJSON interface{ UnmarshalJSON(b []byte) error }

// iSet is the interface for custom value assignment.
type iSet interface{ Set(value any) (old any) }

// FloatFormat 浮点精度控制
func FloatFormat(f float64, length int) (float64, error) <span class="cov0" title="0">{
        return strconv.ParseFloat(strconv.FormatFloat(f, 'f', length, 64), 64)
}</span>

func ToBytes(original any) []byte <span class="cov0" title="0">{
        if original == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">switch value := original.(type) </span>{
        case string:<span class="cov0" title="0">
                return []byte(value)</span>

        case []byte:<span class="cov0" title="0">
                return value</span>

        default:<span class="cov0" title="0">
                if f, ok := value.(iBytes); ok </span><span class="cov0" title="0">{
                        return f.Bytes()
                }</span>

                <span class="cov0" title="0">refType := reflect.TypeOf(original)
                refValue := reflect.ValueOf(original)

                switch refType.Kind() </span>{
                case reflect.Map:<span class="cov0" title="0">
                        bytes, err := json.Marshal(original)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(err)</span>
                        }
                        <span class="cov0" title="0">return bytes</span>

                case reflect.Array, reflect.Slice:<span class="cov0" title="0">
                        var (
                                ok    = true
                                bytes = make([]byte, refValue.Len())
                        )

                        for i := range bytes </span><span class="cov0" title="0">{
                                int32Value := ToInt32(refValue.Index(i).Interface())
                                if int32Value &lt; 0 || int32Value &gt; math.MaxUint8 </span><span class="cov0" title="0">{
                                        ok = false
                                        break</span>
                                }
                                <span class="cov0" title="0">bytes[i] = byte(int32Value)</span>
                        }

                        <span class="cov0" title="0">if ok </span><span class="cov0" title="0">{
                                return bytes
                        }</span>
                }

                <span class="cov0" title="0">return LeEncode(original)</span>
        }
}

func ToUint(original any) uint <span class="cov0" title="0">{
        if original == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">if v, ok := original.(uint); ok </span><span class="cov0" title="0">{
                return v
        }</span>

        <span class="cov0" title="0">return uint(ToInt64(original))</span>
}

func ToUint8(original any) uint8 <span class="cov0" title="0">{
        if original == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">if v, ok := original.(uint8); ok </span><span class="cov0" title="0">{
                return v
        }</span>

        <span class="cov0" title="0">return uint8(ToInt64(original))</span>
}

func ToUint16(original any) uint16 <span class="cov0" title="0">{
        if original == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">if v, ok := original.(uint16); ok </span><span class="cov0" title="0">{
                return v
        }</span>

        <span class="cov0" title="0">return uint16(ToInt64(original))</span>
}

func ToUint32(original any) uint32 <span class="cov0" title="0">{
        if original == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">if v, ok := original.(uint32); ok </span><span class="cov0" title="0">{
                return v
        }</span>

        <span class="cov0" title="0">return uint32(ToInt64(original))</span>
}

func ToUint64(original any) uint64 <span class="cov0" title="0">{
        if original == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">switch value := original.(type) </span>{
        case int:<span class="cov0" title="0">
                return uint64(value)</span>
        case int8:<span class="cov0" title="0">
                return uint64(value)</span>
        case int16:<span class="cov0" title="0">
                return uint64(value)</span>
        case int32:<span class="cov0" title="0">
                return uint64(value)</span>
        case int64:<span class="cov0" title="0">
                return uint64(value)</span>
        case uint:<span class="cov0" title="0">
                return uint64(value)</span>
        case uint8:<span class="cov0" title="0">
                return uint64(value)</span>
        case uint16:<span class="cov0" title="0">
                return uint64(value)</span>
        case uint32:<span class="cov0" title="0">
                return uint64(value)</span>
        case uint64:<span class="cov0" title="0">
                return value</span>
        case float32:<span class="cov0" title="0">
                return uint64(value)</span>
        case float64:<span class="cov0" title="0">
                return uint64(value)</span>
        case bool:<span class="cov0" title="0">
                if value </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        case []byte:<span class="cov0" title="0">
                return LeDecodeToUint64(value)</span>
        default:<span class="cov0" title="0">
                if f, ok := value.(iUint64); ok </span><span class="cov0" title="0">{
                        return f.Uint64()
                }</span>
                <span class="cov0" title="0">var s = ToString(value)
                if len(s) &gt; 0 </span><span class="cov0" title="0">{
                        if s[0] == '-' </span><span class="cov0" title="0">{
                                s = s[1:]
                        }</span> else<span class="cov0" title="0"> if s[0] == '+' </span><span class="cov0" title="0">{
                                s = s[1:]
                        }</span>
                }
                // Hexadecimal
                <span class="cov0" title="0">if len(s) &gt; 2 &amp;&amp; s[0] == '0' &amp;&amp; (s[1] == 'x' || s[1] == 'X') </span><span class="cov0" title="0">{
                        if v, e := strconv.ParseUint(s[2:], 16, 64); e == nil </span><span class="cov0" title="0">{
                                return v
                        }</span>
                }
                // Decimal
                <span class="cov0" title="0">if v, e := strconv.ParseUint(s, 10, 64); e == nil </span><span class="cov0" title="0">{
                        return v
                }</span>
                // Float64
                <span class="cov0" title="0">if valueInt64 := ToFloat64(value); math.IsNaN(valueInt64) </span><span class="cov0" title="0">{
                        return 0
                }</span> else<span class="cov0" title="0"> {
                        return uint64(valueInt64)
                }</span>
        }
}

func ToInt(original any) int <span class="cov0" title="0">{
        if original == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">if v, ok := original.(int); ok </span><span class="cov0" title="0">{
                return v
        }</span>

        <span class="cov0" title="0">return int(ToInt64(original))</span>
}

func ToInt8(original any) int8 <span class="cov0" title="0">{
        if original == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">if v, ok := original.(int8); ok </span><span class="cov0" title="0">{
                return v
        }</span>

        <span class="cov0" title="0">return int8(ToInt64(original))</span>
}

func ToInt16(original any) int16 <span class="cov0" title="0">{
        if original == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">if v, ok := original.(int16); ok </span><span class="cov0" title="0">{
                return v
        }</span>

        <span class="cov0" title="0">return int16(ToInt64(original))</span>
}

func ToInt32(original any) int32 <span class="cov0" title="0">{
        if original == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">if v, ok := original.(int32); ok </span><span class="cov0" title="0">{
                return v
        }</span>

        <span class="cov0" title="0">return int32(ToInt64(original))</span>
}

func ToInt64(original any) int64 <span class="cov0" title="0">{
        if original == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">switch value := original.(type) </span>{
        case int:<span class="cov0" title="0">
                return int64(value)</span>
        case int8:<span class="cov0" title="0">
                return int64(value)</span>
        case int16:<span class="cov0" title="0">
                return int64(value)</span>
        case int32:<span class="cov0" title="0">
                return int64(value)</span>
        case int64:<span class="cov0" title="0">
                return value</span>
        case uint:<span class="cov0" title="0">
                return int64(value)</span>
        case uint8:<span class="cov0" title="0">
                return int64(value)</span>
        case uint16:<span class="cov0" title="0">
                return int64(value)</span>
        case uint32:<span class="cov0" title="0">
                return int64(value)</span>
        case uint64:<span class="cov0" title="0">
                return int64(value)</span>
        case float32:<span class="cov0" title="0">
                return int64(value)</span>
        case float64:<span class="cov0" title="0">
                return int64(value)</span>
        case bool:<span class="cov0" title="0">
                if value </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        case []byte:<span class="cov0" title="0">
                return LeDecodeToInt64(value)</span>
        default:<span class="cov0" title="0">
                if f, ok := value.(iInt64); ok </span><span class="cov0" title="0">{
                        return f.Int64()
                }</span>
                <span class="cov0" title="0">var (
                        s       = ToString(value)
                        isMinus = false
                )
                if len(s) &gt; 0 </span><span class="cov0" title="0">{
                        if s[0] == '-' </span><span class="cov0" title="0">{
                                isMinus = true
                                s = s[1:]
                        }</span> else<span class="cov0" title="0"> if s[0] == '+' </span><span class="cov0" title="0">{
                                s = s[1:]
                        }</span>
                }
                // Hexadecimal
                <span class="cov0" title="0">if len(s) &gt; 2 &amp;&amp; s[0] == '0' &amp;&amp; (s[1] == 'x' || s[1] == 'X') </span><span class="cov0" title="0">{
                        if v, e := strconv.ParseInt(s[2:], 16, 64); e == nil </span><span class="cov0" title="0">{
                                if isMinus </span><span class="cov0" title="0">{
                                        return -v
                                }</span>
                                <span class="cov0" title="0">return v</span>
                        }
                }
                // Decimal
                <span class="cov0" title="0">if v, e := strconv.ParseInt(s, 10, 64); e == nil </span><span class="cov0" title="0">{
                        if isMinus </span><span class="cov0" title="0">{
                                return -v
                        }</span>
                        <span class="cov0" title="0">return v</span>
                }
                // Float64
                <span class="cov0" title="0">if valueInt64 := ToFloat64(value); math.IsNaN(valueInt64) </span><span class="cov0" title="0">{
                        return 0
                }</span> else<span class="cov0" title="0"> {
                        return int64(valueInt64)
                }</span>
        }
}

func ToDatetimeUnixMilli(original any) time.Time <span class="cov0" title="0">{ return time.UnixMilli(ToInt64(original)) }</span>

// ToFloat32 converts `any` to float32.
func ToFloat32(original any) float32 <span class="cov0" title="0">{
        if original == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">switch value := original.(type) </span>{
        case float32:<span class="cov0" title="0">
                return value</span>
        case float64:<span class="cov0" title="0">
                return float32(value)</span>
        case []byte:<span class="cov0" title="0">
                return LeDecodeToFloat32(value)</span>
        default:<span class="cov0" title="0">
                if f, ok := value.(iFloat32); ok </span><span class="cov0" title="0">{
                        return f.Float32()
                }</span>
                <span class="cov0" title="0">v, _ := strconv.ParseFloat(ToString(original), 64)
                return float32(v)</span>
        }
}

// ToFloat64 converts `any` to float64.
func ToFloat64(original any) float64 <span class="cov0" title="0">{
        if original == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">switch value := original.(type) </span>{
        case float32:<span class="cov0" title="0">
                return float64(value)</span>
        case float64:<span class="cov0" title="0">
                return value</span>
        case []byte:<span class="cov0" title="0">
                return LeDecodeToFloat64(value)</span>
        default:<span class="cov0" title="0">
                if f, ok := value.(iFloat64); ok </span><span class="cov0" title="0">{
                        return f.Float64()
                }</span>
                <span class="cov0" title="0">v, _ := strconv.ParseFloat(ToString(original), 64)
                return v</span>
        }
}

func ToString(original any) string <span class="cov0" title="0">{
        if original == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">switch value := original.(type) </span>{
        case int:<span class="cov0" title="0">
                return strconv.Itoa(value)</span>
        case int8:<span class="cov0" title="0">
                return strconv.Itoa(int(value))</span>
        case int16:<span class="cov0" title="0">
                return strconv.Itoa(int(value))</span>
        case int32:<span class="cov0" title="0">
                return strconv.Itoa(int(value))</span>
        case int64:<span class="cov0" title="0">
                return strconv.FormatInt(value, 10)</span>
        case uint:<span class="cov0" title="0">
                return strconv.FormatUint(uint64(value), 10)</span>
        case uint8:<span class="cov0" title="0">
                return strconv.FormatUint(uint64(value), 10)</span>
        case uint16:<span class="cov0" title="0">
                return strconv.FormatUint(uint64(value), 10)</span>
        case uint32:<span class="cov0" title="0">
                return strconv.FormatUint(uint64(value), 10)</span>
        case uint64:<span class="cov0" title="0">
                return strconv.FormatUint(value, 10)</span>
        case float32:<span class="cov0" title="0">
                return strconv.FormatFloat(float64(value), 'f', -1, 32)</span>
        case float64:<span class="cov0" title="0">
                return strconv.FormatFloat(value, 'f', -1, 64)</span>
        case bool:<span class="cov0" title="0">
                return strconv.FormatBool(value)</span>
        case string:<span class="cov0" title="0">
                return value</span>
        case []byte:<span class="cov0" title="0">
                return string(value)</span>
        case time.Time:<span class="cov0" title="0">
                if value.IsZero() </span><span class="cov0" title="0">{
                        return ""
                }</span>
                <span class="cov0" title="0">return value.String()</span>
        case *time.Time:<span class="cov0" title="0">
                if value == nil </span><span class="cov0" title="0">{
                        return ""
                }</span>
                <span class="cov0" title="0">return value.String()</span>
        default:<span class="cov0" title="0">
                // Empty checks.
                // if value == nil {
                //         return ""
                // }
                if f, ok := value.(iString); ok </span><span class="cov0" title="0">{
                        // If the variable implements the String() interface,
                        // then use that interface to perform the conversion
                        return f.String()
                }</span>
                <span class="cov0" title="0">if f, ok := value.(iError); ok </span><span class="cov0" title="0">{
                        // If the variable implements the Error() interface,
                        // then use that interface to perform the conversion
                        return f.Error()
                }</span>
                // Reflection checks.
                <span class="cov0" title="0">var (
                        rv   = reflect.ValueOf(value)
                        kind = rv.Kind()
                )
                switch kind </span>{
                case reflect.Chan,
                        reflect.Map,
                        reflect.Slice,
                        reflect.Func,
                        reflect.Ptr,
                        reflect.Interface,
                        reflect.UnsafePointer:<span class="cov0" title="0">
                        if rv.IsNil() </span><span class="cov0" title="0">{
                                return ""
                        }</span>
                case reflect.String:<span class="cov0" title="0">
                        return rv.String()</span>
                }
                <span class="cov0" title="0">if kind == reflect.Ptr </span><span class="cov0" title="0">{
                        return ToString(rv.Elem().Interface())
                }</span>
                // Finally, we use json.Marshal to convert.
                <span class="cov0" title="0">if jsonContent, err := json.Marshal(value); err != nil </span><span class="cov0" title="0">{
                        return fmt.Sprint(value)
                }</span> else<span class="cov0" title="0"> {
                        return string(jsonContent)
                }</span>
        }
}

func ToBool(original any) bool <span class="cov0" title="0">{
        if original == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">switch value := original.(type) </span>{
        case bool:<span class="cov0" title="0">
                return value</span>
        case []byte:<span class="cov0" title="0">
                if _, ok := emptyStringMap[strings.ToLower(string(value))]; ok </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">return true</span>
        case string:<span class="cov0" title="0">
                if _, ok := emptyStringMap[strings.ToLower(value)]; ok </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">return true</span>
        default:<span class="cov0" title="0">
                if f, ok := value.(iBool); ok </span><span class="cov0" title="0">{
                        return f.Bool()
                }</span>
                <span class="cov0" title="0">rv := reflect.ValueOf(original)
                switch rv.Kind() </span>{
                case reflect.Ptr:<span class="cov0" title="0">
                        return !rv.IsNil()</span>
                case reflect.Map:<span class="cov0" title="0">
                        fallthrough</span>
                case reflect.Array:<span class="cov0" title="0">
                        fallthrough</span>
                case reflect.Slice:<span class="cov0" title="0">
                        return rv.Len() != 0</span>
                case reflect.Struct:<span class="cov0" title="0">
                        return true</span>
                default:<span class="cov0" title="0">
                        s := strings.ToLower(ToString(original))
                        if _, ok := emptyStringMap[s]; ok </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov0" title="0">return true</span>
                }
        }
}

// ToStruct 任意类型转结构体
func ToStruct(v any, r any) error <span class="cov0" title="0">{
        var (
                e        error
                jsonByte []byte
        )
        jsonByte, e = json.Marshal(v)
        if e != nil </span><span class="cov0" title="0">{
                return e
        }</span>

        <span class="cov0" title="0">return json.Unmarshal(jsonByte, &amp;r)</span>
}

func LeEncode(values ...any) []byte <span class="cov0" title="0">{
        buf := new(bytes.Buffer)
        for i := 0; i &lt; len(values); i++ </span><span class="cov0" title="0">{
                if values[i] == nil </span><span class="cov0" title="0">{
                        return buf.Bytes()
                }</span>
                <span class="cov0" title="0">switch value := values[i].(type) </span>{
                case int:<span class="cov0" title="0">
                        buf.Write(LeEncodeInt(value))</span>
                case int8:<span class="cov0" title="0">
                        buf.Write(LeEncodeInt8(value))</span>
                case int16:<span class="cov0" title="0">
                        buf.Write(LeEncodeInt16(value))</span>
                case int32:<span class="cov0" title="0">
                        buf.Write(LeEncodeInt32(value))</span>
                case int64:<span class="cov0" title="0">
                        buf.Write(LeEncodeInt64(value))</span>
                case uint:<span class="cov0" title="0">
                        buf.Write(LeEncodeUint(value))</span>
                case uint8:<span class="cov0" title="0">
                        buf.Write(LeEncodeUint8(value))</span>
                case uint16:<span class="cov0" title="0">
                        buf.Write(LeEncodeUint16(value))</span>
                case uint32:<span class="cov0" title="0">
                        buf.Write(LeEncodeUint32(value))</span>
                case uint64:<span class="cov0" title="0">
                        buf.Write(LeEncodeUint64(value))</span>
                case bool:<span class="cov0" title="0">
                        buf.Write(LeEncodeBool(value))</span>
                case string:<span class="cov0" title="0">
                        buf.Write(LeEncodeString(value))</span>
                case []byte:<span class="cov0" title="0">
                        buf.Write(value)</span>
                case float32:<span class="cov0" title="0">
                        buf.Write(LeEncodeFloat32(value))</span>
                case float64:<span class="cov0" title="0">
                        buf.Write(LeEncodeFloat64(value))</span>

                default:<span class="cov0" title="0">
                        if err := binary.Write(buf, binary.LittleEndian, value); err != nil </span><span class="cov0" title="0">{
                                buf.Write(LeEncodeString(fmt.Sprintf("%v", value)))
                        }</span>
                }
        }

        <span class="cov0" title="0">return buf.Bytes()</span>
}

func LeEncodeByLength(length int, values ...any) []byte <span class="cov0" title="0">{
        b := LeEncode(values...)
        if len(b) &lt; length </span><span class="cov0" title="0">{
                b = append(b, make([]byte, length-len(b))...)
        }</span> else<span class="cov0" title="0"> if len(b) &gt; length </span><span class="cov0" title="0">{
                b = b[0:length]
        }</span>

        <span class="cov0" title="0">return b</span>
}

func LeDecode(b []byte, values ...any) error <span class="cov0" title="0">{
        var (
                err error
                buf = bytes.NewBuffer(b)
        )
        for i := 0; i &lt; len(values); i++ </span><span class="cov0" title="0">{
                if err = binary.Read(buf, binary.LittleEndian, values[i]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func LeEncodeString(s string) []byte <span class="cov0" title="0">{ return []byte(s) }</span>

func LeDecodeToString(b []byte) string <span class="cov0" title="0">{ return string(b) }</span>

func LeEncodeBool(b bool) []byte <span class="cov0" title="0">{
        if b </span><span class="cov0" title="0">{
                return []byte{1}
        }</span> else<span class="cov0" title="0"> {
                return []byte{0}
        }</span>
}

func LeEncodeInt(i int) []byte <span class="cov0" title="0">{
        if i &lt;= math.MaxInt8 </span><span class="cov0" title="0">{
                return LeEncodeInt8(int8(i))
        }</span> else<span class="cov0" title="0"> if i &lt;= math.MaxInt16 </span><span class="cov0" title="0">{
                return LeEncodeInt16(int16(i))
        }</span> else<span class="cov0" title="0"> if i &lt;= math.MaxInt32 </span><span class="cov0" title="0">{
                return LeEncodeInt32(int32(i))
        }</span> else<span class="cov0" title="0"> {
                return LeEncodeInt64(int64(i))
        }</span>
}

func LeEncodeUint(i uint) []byte <span class="cov0" title="0">{
        if i &lt;= math.MaxUint8 </span><span class="cov0" title="0">{
                return LeEncodeUint8(uint8(i))
        }</span> else<span class="cov0" title="0"> if i &lt;= math.MaxUint16 </span><span class="cov0" title="0">{
                return LeEncodeUint16(uint16(i))
        }</span> else<span class="cov0" title="0"> if i &lt;= math.MaxUint32 </span><span class="cov0" title="0">{
                return LeEncodeUint32(uint32(i))
        }</span> else<span class="cov0" title="0"> {
                return LeEncodeUint64(uint64(i))
        }</span>
}

func LeEncodeInt8(i int8) []byte <span class="cov0" title="0">{ return []byte{byte(i)} }</span>

func LeEncodeUint8(i uint8) []byte <span class="cov0" title="0">{ return []byte{i} }</span>

func LeEncodeInt16(i int16) []byte <span class="cov0" title="0">{
        b := make([]byte, 2)
        binary.LittleEndian.PutUint16(b, uint16(i))

        return b
}</span>

func LeEncodeUint16(i uint16) []byte <span class="cov0" title="0">{
        b := make([]byte, 2)
        binary.LittleEndian.PutUint16(b, i)

        return b
}</span>

func LeEncodeInt32(i int32) []byte <span class="cov0" title="0">{
        b := make([]byte, 4)
        binary.LittleEndian.PutUint32(b, uint32(i))

        return b
}</span>

func LeEncodeUint32(i uint32) []byte <span class="cov0" title="0">{
        b := make([]byte, 4)
        binary.LittleEndian.PutUint32(b, i)

        return b
}</span>

func LeEncodeInt64(i int64) []byte <span class="cov0" title="0">{
        b := make([]byte, 8)
        binary.LittleEndian.PutUint64(b, uint64(i))

        return b
}</span>

func LeEncodeUint64(i uint64) []byte <span class="cov0" title="0">{
        b := make([]byte, 8)
        binary.LittleEndian.PutUint64(b, i)

        return b
}</span>

func LeEncodeFloat32(f float32) []byte <span class="cov0" title="0">{
        bits := math.Float32bits(f)
        b := make([]byte, 4)
        binary.LittleEndian.PutUint32(b, bits)

        return b
}</span>

func LeEncodeFloat64(f float64) []byte <span class="cov0" title="0">{
        bits := math.Float64bits(f)
        b := make([]byte, 8)
        binary.LittleEndian.PutUint64(b, bits)

        return b
}</span>

func LeDecodeToInt(b []byte) int <span class="cov0" title="0">{
        if len(b) &lt; 2 </span><span class="cov0" title="0">{
                return int(LeDecodeToUint8(b))
        }</span> else<span class="cov0" title="0"> if len(b) &lt; 3 </span><span class="cov0" title="0">{
                return int(LeDecodeToUint16(b))
        }</span> else<span class="cov0" title="0"> if len(b) &lt; 5 </span><span class="cov0" title="0">{
                return int(LeDecodeToUint32(b))
        }</span> else<span class="cov0" title="0"> {
                return int(LeDecodeToUint64(b))
        }</span>
}

func LeDecodeToUint(b []byte) uint <span class="cov0" title="0">{
        if len(b) &lt; 2 </span><span class="cov0" title="0">{
                return uint(LeDecodeToUint8(b))
        }</span> else<span class="cov0" title="0"> if len(b) &lt; 3 </span><span class="cov0" title="0">{
                return uint(LeDecodeToUint16(b))
        }</span> else<span class="cov0" title="0"> if len(b) &lt; 5 </span><span class="cov0" title="0">{
                return uint(LeDecodeToUint32(b))
        }</span> else<span class="cov0" title="0"> {
                return uint(LeDecodeToUint64(b))
        }</span>
}

func LeDecodeToBool(b []byte) bool <span class="cov0" title="0">{
        if len(b) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if bytes.Equal(b, make([]byte, len(b))) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

func LeDecodeToInt8(b []byte) int8 <span class="cov0" title="0">{
        if len(b) == 0 </span><span class="cov0" title="0">{
                panic(`empty slice given`)</span>
        }

        <span class="cov0" title="0">return int8(b[0])</span>
}

func LeDecodeToUint8(b []byte) uint8 <span class="cov0" title="0">{
        if len(b) == 0 </span><span class="cov0" title="0">{
                panic(`empty slice given`)</span>
        }

        <span class="cov0" title="0">return b[0]</span>
}

func LeDecodeToInt16(b []byte) int16 <span class="cov0" title="0">{
        return int16(binary.LittleEndian.Uint16(LeFillUpSize(b, 2)))
}</span>

func LeDecodeToUint16(b []byte) uint16 <span class="cov0" title="0">{
        return binary.LittleEndian.Uint16(LeFillUpSize(b, 2))
}</span>

func LeDecodeToInt32(b []byte) int32 <span class="cov0" title="0">{
        return int32(binary.LittleEndian.Uint32(LeFillUpSize(b, 4)))
}</span>

func LeDecodeToUint32(b []byte) uint32 <span class="cov0" title="0">{
        return binary.LittleEndian.Uint32(LeFillUpSize(b, 4))
}</span>

func LeDecodeToInt64(b []byte) int64 <span class="cov0" title="0">{
        return int64(binary.LittleEndian.Uint64(LeFillUpSize(b, 8)))
}</span>

func LeDecodeToUint64(b []byte) uint64 <span class="cov0" title="0">{
        return binary.LittleEndian.Uint64(LeFillUpSize(b, 8))
}</span>

func LeDecodeToFloat32(b []byte) float32 <span class="cov0" title="0">{
        return math.Float32frombits(binary.LittleEndian.Uint32(LeFillUpSize(b, 4)))
}</span>

func LeDecodeToFloat64(b []byte) float64 <span class="cov0" title="0">{
        return math.Float64frombits(binary.LittleEndian.Uint64(LeFillUpSize(b, 8)))
}</span>

// LeFillUpSize fills up the bytes `b` to given length `l` using LittleEndian.
//
// Note that it creates a new bytes slice by copying the original one to avoid changing
// the original parameter bytes.
func LeFillUpSize(b []byte, l int) []byte <span class="cov0" title="0">{
        if len(b) &gt;= l </span><span class="cov0" title="0">{
                return b[:l]
        }</span>
        <span class="cov0" title="0">c := make([]byte, l)
        copy(c, b)

        return c</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package compression

import (
        "bytes"
        "compress/zlib"
        "io"
)

type Zlib struct{}

var ZlibApp Zlib

func (*Zlib) New() *Zlib <span class="cov0" title="0">{ return &amp;Zlib{} }</span>

//go:fix 推荐使用New方法
func NewZlib() *Zlib <span class="cov8" title="1">{ return &amp;Zlib{} }</span>

// Compress 压缩
func (*Zlib) Compress(originalData []byte) ([]byte, error) <span class="cov8" title="1">{
        var (
                err    error
                buffer bytes.Buffer
                writer *zlib.Writer
        )

        // 创建一个新的Zlib压缩器
        writer = zlib.NewWriter(&amp;buffer)

        // 写入数据到压缩器
        if _, err = writer.Write(originalData); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 记住要关闭Writer以完成压缩
        <span class="cov8" title="1">if err = writer.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 压缩后的数据存储在b的缓冲区中
        <span class="cov8" title="1">return buffer.Bytes(), nil</span>
}

// Decompress 解压缩
func (*Zlib) Decompress(data []byte) ([]byte, error) <span class="cov8" title="1">{
        var (
                err    error
                buffer bytes.Buffer
                reader io.ReadCloser
        )
        reader, err = zlib.NewReader(bytes.NewReader(data))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer reader.Close()

        // 读取解压缩后的数据到缓冲区
        if _, err = io.Copy(&amp;buffer, reader); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return buffer.Bytes(), nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package daemon

import (
        "fmt"
        "log"
        "os"
        "os/exec"
        "syscall"
        "time"

        "github.com/aid297/aid/filesystem/filesystemV2"
        "github.com/aid297/aid/operation/operationV2"
)

// Daemon 守护进程服务提供者
type Daemon struct{}

// Launch 启动守护进程
func (*Daemon) Launch(title, logDir, logFilename string) <span class="cov0" title="0">{
        var (
                err  error
                dir  *filesystemV2.Dir  = filesystemV2.APP.Dir.NewByAbs(logDir)
                file *filesystemV2.File = filesystemV2.APP.File.NewByAbs(logDir, operationV2.NewTernary(operationV2.TrueValue(logFilename), operationV2.FalseValue("daemon.log")).GetByValue(logFilename != ""))
                fp   *os.File
        )

        if syscall.Getppid() == 1 </span><span class="cov0" title="0">{
                if err := os.Chdir("./"); err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                // syscall.Umask(0) // TODO TEST
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">if !dir.GetExist() </span><span class="cov0" title="0">{
                if err = dir.Create(os.ModePerm).Error(); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("【启动失败】创建日志目录失败：%s", err.Error())
                }</span>
        }

        <span class="cov0" title="0">if fp, err = os.OpenFile(file.GetFullPath(), os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("【启动失败】创建总日志失败：%s", err.Error())
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = fp.Close() }</span>()
        <span class="cov0" title="0">cmd := exec.Command(os.Args[0], os.Args[1:]...)
        // cmd.SysProcAttr = &amp;syscall.SysProcAttr{Setsid: true} // TODO TEST
        cmd.SysProcAttr = &amp;syscall.SysProcAttr{} // TODO TEST
        cmd.Stdout = fp
        cmd.Stderr = fp
        cmd.Stdin = nil
        if err = cmd.Start(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("【启动失败】%s", err.Error())
        }</span>

        <span class="cov0" title="0">if _, err = fmt.Fprintf(
                fp,
                "--------------------------------------------------\r\n%s 程序启动成功 [进程号-&gt;%d] 启动于：%s\r\n",
                title,
                cmd.Process.Pid,
                time.Now().Format(string(time.DateTime+".000")),
        ); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("【启动失败】写入日志失败：%s", err.Error())
        }</span>

        <span class="cov0" title="0">os.Exit(0)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "bufio"
        "fmt"
        "os"
)

// Database 数据库结构
type Database struct {
        parser        *SQLParser
        storageEngine *StorageEngine
        dataDir       string
}

// NewDatabase 创建新的数据库实例
func NewDatabase(dataDir string) (*Database, error) <span class="cov8" title="1">{
        storageEngine, err := NewStorageEngine(dataDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create storage engine: %v", err)
        }</span>

        <span class="cov8" title="1">db := &amp;Database{
                parser:        NewSQLParser(),
                storageEngine: storageEngine,
                dataDir:       dataDir,
        }

        // 加载已存在的表
        if err := db.loadExistingTables(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load existing tables: %v", err)
        }</span>

        <span class="cov8" title="1">return db, nil</span>
}

// loadExistingTables 加载已存在的表
func (db *Database) loadExistingTables() error <span class="cov8" title="1">{
        // 列出所有schema文件
        entries, err := os.ReadDir(db.dataDir)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        // 目录不存在，这不是错误
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov8" title="1">for _, entry := range entries </span><span class="cov8" title="1">{
                if !entry.IsDir() &amp;&amp; len(entry.Name()) &gt; 12 &amp;&amp; entry.Name()[len(entry.Name())-12:] == ".schema.json" </span><span class="cov8" title="1">{
                        tableName := entry.Name()[:len(entry.Name())-12]
                        table, err := db.storageEngine.LoadTable(tableName)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to load table '%s': %v", tableName, err)
                        }</span>
                        <span class="cov8" title="1">db.parser.Tables[tableName] = table</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// Execute 执行SQL语句
func (db *Database) Execute(sql string) error <span class="cov8" title="1">{
        if err := db.parser.ParseAndExecute(sql); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // 自动保存表数据
        <span class="cov8" title="1">for tableName, table := range db.parser.Tables </span><span class="cov8" title="1">{
                if err := db.storageEngine.SaveTable(table); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to save table '%s': %v", tableName, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ListTables 列出所有表
func (db *Database) ListTables() <span class="cov0" title="0">{
        fmt.Println("Available tables:")
        for tableName := range db.parser.Tables </span><span class="cov0" title="0">{
                fmt.Printf("- %s\n", tableName)
        }</span>
}

// ShowTableSchema 显示表结构
func (db *Database) ShowTableSchema(tableName string) error <span class="cov0" title="0">{
        table, exists := db.parser.Tables[tableName]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("table '%s' does not exist", tableName)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Table: %s\n", table.Name)
        fmt.Println("Columns:")
        for _, col := range table.Columns </span><span class="cov0" title="0">{
                nullable := "NULL"
                if !col.Nullable </span><span class="cov0" title="0">{
                        nullable = "NOT NULL"
                }</span>
                <span class="cov0" title="0">fmt.Printf("- %s %s %s\n", col.Name, col.Type.String(), nullable)</span>
        }

        <span class="cov0" title="0">fmt.Printf("Rows: %d\n", len(table.Rows))
        return nil</span>
}

// RunInteractive 运行交互式命令行界面
func (db *Database) RunInteractive() <span class="cov0" title="0">{
        scanner := bufio.NewScanner(os.Stdin)

        fmt.Println("Simple MySQL-like Database")
        fmt.Println("Kind 'help' for available commands or 'exit' to quit")
        fmt.Println()

        for </span><span class="cov0" title="0">{
                fmt.Print("db&gt; ")
                if !scanner.Scan() </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">input := scanner.Text()
                if input == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if input == "exit" || input == "quit" </span><span class="cov0" title="0">{
                        break</span>
                } else<span class="cov0" title="0"> if input == "help" </span><span class="cov0" title="0">{
                        fmt.Println("Available commands:")
                        fmt.Println("- CREATE TABLE table_name (col1 type1, col2 type2, ...)")
                        fmt.Println("- INSERT INTO table_name VALUES (val1, val2, ...)")
                        fmt.Println("- SELECT * FROM table_name")
                        fmt.Println("- LIST TABLES")
                        fmt.Println("- DESC table_name")
                        fmt.Println("- EXIT")
                        continue</span>
                } else<span class="cov0" title="0"> if input == "LIST TABLES" </span><span class="cov0" title="0">{
                        db.ListTables()
                        continue</span>
                } else<span class="cov0" title="0"> if len(input) &gt; 5 &amp;&amp; input[:5] == "DESC " </span><span class="cov0" title="0">{
                        tableName := input[5:]
                        if err := db.ShowTableSchema(tableName); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Error: %v\n", err)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">if err := db.Execute(input); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error: %v\n", err)
                }</span>
        }

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Input error: %v\n", err)
        }</span>
}

// 主函数
func main() <span class="cov0" title="0">{
        // 创建数据库实例
        db, err := NewDatabase("./data")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to create database: %v\n", err)
                return
        }</span>

        // 运行交互式界面
        <span class="cov0" title="0">db.RunInteractive()</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "fmt"
        "regexp"
        "strings"
)

// SQLParser SQL解析器
type SQLParser struct {
        Tables map[string]*Table
}

// NewSQLParser 创建新的SQL解析器
func NewSQLParser() *SQLParser <span class="cov8" title="1">{
        return &amp;SQLParser{
                Tables: make(map[string]*Table),
        }
}</span>

// ParseAndExecute 解析并执行SQL语句
func (p *SQLParser) ParseAndExecute(sql string) error <span class="cov8" title="1">{
        sql = strings.TrimSpace(sql)

        // 转换为大写以便判断语句类型
        upperSQL := strings.ToUpper(sql)

        if strings.HasPrefix(upperSQL, "CREATE TABLE") </span><span class="cov8" title="1">{
                return p.parseCreateTable(sql)
        }</span> else<span class="cov8" title="1"> if strings.HasPrefix(upperSQL, "INSERT INTO") </span><span class="cov8" title="1">{
                return p.parseInsert(sql)
        }</span> else<span class="cov8" title="1"> if strings.HasPrefix(upperSQL, "SELECT") </span><span class="cov0" title="0">{
                return p.parseSelect(sql)
        }</span> else<span class="cov8" title="1"> {
                return fmt.Errorf("unsupported SQL statement: %s", sql)
        }</span>
}

// parseCreateTable 解析CREATE TABLE语句
func (p *SQLParser) parseCreateTable(sql string) error <span class="cov8" title="1">{
        // 简化的CREATE TABLE解析，格式: CREATE TABLE table_name (col1 type1, col2 type2, ...)
        re := regexp.MustCompile(`CREATE\s+TABLE\s+(\w+)\s*\((.+)\)`)
        matches := re.FindStringSubmatch(sql)
        if len(matches) != 3 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid CREATE TABLE syntax: %s", sql)
        }</span>

        <span class="cov8" title="1">tableName := matches[1]
        columnsDef := matches[2]

        // 解析列定义
        columnsStr := strings.Split(columnsDef, ",")
        var columns []Column

        for _, colStr := range columnsStr </span><span class="cov8" title="1">{
                colStr = strings.TrimSpace(colStr)
                parts := strings.Fields(colStr)
                if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid column definition: %s", colStr)
                }</span>

                <span class="cov8" title="1">colName := parts[0]
                colType, err := ParseDataType(parts[1])
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid column type: %v", err)
                }</span>

                // 检查是否可为空（简化处理）
                <span class="cov8" title="1">nullable := true
                for _, part := range parts[2:] </span><span class="cov0" title="0">{
                        if strings.ToUpper(part) == "NOT" &amp;&amp; len(parts) &gt; 3 &amp;&amp; strings.ToUpper(parts[3]) == "NULL" </span><span class="cov0" title="0">{
                                nullable = false
                                break</span>
                        }
                }

                <span class="cov8" title="1">columns = append(columns, Column{
                        Name:     colName,
                        Type:     colType,
                        Nullable: nullable,
                })</span>
        }

        // 创建表
        <span class="cov8" title="1">p.Tables[tableName] = &amp;Table{
                Name:    tableName,
                Columns: columns,
                Rows:    make([]Row, 0),
        }

        fmt.Printf("Table '%s' created successfully\n", tableName)
        return nil</span>
}

// parseInsert 解析INSERT语句
func (p *SQLParser) parseInsert(sql string) error <span class="cov8" title="1">{
        // 简化的INSERT解析，格式: INSERT INTO table_name VALUES (val1, val2, ...)
        re := regexp.MustCompile(`INSERT\s+INTO\s+(\w+)\s+VALUES\s*\((.+)\)`)
        matches := re.FindStringSubmatch(sql)
        if len(matches) != 3 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid INSERT syntax: %s", sql)
        }</span>

        <span class="cov8" title="1">tableName := matches[1]
        valuesStr := matches[2]

        // 检查表是否存在
        table, exists := p.Tables[tableName]
        if !exists </span><span class="cov8" title="1">{
                return fmt.Errorf("table '%s' does not exist", tableName)
        }</span>

        // 解析值
        <span class="cov8" title="1">valuesStr = strings.TrimSpace(valuesStr)
        valueStrings := strings.Split(valuesStr, ",")

        if len(valueStrings) != len(table.Columns) </span><span class="cov8" title="1">{
                return fmt.Errorf("column count mismatch: expected %d, got %d", len(table.Columns), len(valueStrings))
        }</span>

        <span class="cov8" title="1">var values []interface{}
        for i, valueStr := range valueStrings </span><span class="cov8" title="1">{
                valueStr = strings.TrimSpace(valueStr)
                value, err := ParseValue(valueStr, table.Columns[i].Type)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error parsing value '%s': %v", valueStr, err)
                }</span>
                <span class="cov8" title="1">values = append(values, value)</span>
        }

        // 添加行到表
        <span class="cov8" title="1">table.Rows = append(table.Rows, Row{Values: values})

        fmt.Printf("Rows inserted into table '%s' successfully\n", tableName)
        return nil</span>
}

// parseSelect 解析SELECT语句
func (p *SQLParser) parseSelect(sql string) error <span class="cov0" title="0">{
        // 简化的SELECT解析，格式: SELECT * FROM table_name
        re := regexp.MustCompile(`SELECT\s+\*\s+FROM\s+(\w+)`)
        matches := re.FindStringSubmatch(sql)
        if len(matches) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid SELECT syntax: %s", sql)
        }</span>

        <span class="cov0" title="0">tableName := matches[1]
        table, exists := p.Tables[tableName]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("table '%s' does not exist", tableName)
        }</span>

        // 打印表头
        <span class="cov0" title="0">header := make([]string, len(table.Columns))
        for i, col := range table.Columns </span><span class="cov0" title="0">{
                header[i] = col.Name
        }</span>
        <span class="cov0" title="0">fmt.Println(strings.Join(header, " | "))

        // 打印分隔线
        separator := make([]string, len(table.Columns))
        for i := range table.Columns </span><span class="cov0" title="0">{
                separator[i] = strings.Repeat("-", len(header[i]))
        }</span>
        <span class="cov0" title="0">fmt.Println(strings.Join(separator, "-+-"))

        // 打印数据行
        for _, row := range table.Rows </span><span class="cov0" title="0">{
                rowStr := make([]string, len(row.Values))
                for i, value := range row.Values </span><span class="cov0" title="0">{
                        rowStr[i] = ValueToString(value, table.Columns[i].Type)
                }</span>
                <span class="cov0" title="0">fmt.Println(strings.Join(rowStr, " | "))</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import (
        "encoding/binary"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
)

// StorageEngine 存储引擎
type StorageEngine struct {
        dataDir string
}

// NewStorageEngine 创建新的存储引擎
func NewStorageEngine(dataDir string) (*StorageEngine, error) <span class="cov8" title="1">{
        if err := os.MkdirAll(dataDir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create data directory: %v", err)
        }</span>
        
        <span class="cov8" title="1">return &amp;StorageEngine{
                dataDir: dataDir,
        }, nil</span>
}

// SaveTable 保存表结构和数据到文件
func (s *StorageEngine) SaveTable(table *Table) error <span class="cov8" title="1">{
        // 保存表结构
        if err := s.saveTableSchema(table); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save table schema: %v", err)
        }</span>
        
        // 保存表数据
        <span class="cov8" title="1">if err := s.saveTableData(table); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save table data: %v", err)
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

// saveTableSchema 保存表结构到文件
func (s *StorageEngine) saveTableSchema(table *Table) error <span class="cov8" title="1">{
        schemaPath := filepath.Join(s.dataDir, table.Name+".schema.json")
        
        data, err := json.MarshalIndent(table, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal schema: %v", err)
        }</span>
        
        <span class="cov8" title="1">if err := os.WriteFile(schemaPath, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write schema file: %v", err)
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

// saveTableData 保存表数据到文件
func (s *StorageEngine) saveTableData(table *Table) error <span class="cov8" title="1">{
        dataPath := filepath.Join(s.dataDir, table.Name+".data")
        
        file, err := os.Create(dataPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create data file: %v", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()
        
        // 写入行数
        if err := binary.Write(file, binary.LittleEndian, uint32(len(table.Rows))); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write row count: %v", err)
        }</span>
        
        // 写入每一行数据
        <span class="cov8" title="1">for _, row := range table.Rows </span><span class="cov8" title="1">{
                if err := s.writeRow(file, row, table.Columns); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write row: %v", err)
                }</span>
        }
        
        <span class="cov8" title="1">return nil</span>
}

// writeRow 写入一行数据
func (s *StorageEngine) writeRow(file *os.File, row Row, columns []Column) error <span class="cov8" title="1">{
        // 写入列数
        if err := binary.Write(file, binary.LittleEndian, uint32(len(row.Values))); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        // 写入每一列的数据
        <span class="cov8" title="1">for i, value := range row.Values </span><span class="cov8" title="1">{
                if err := s.writeValue(file, value, columns[i].Type); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        
        <span class="cov8" title="1">return nil</span>
}

// writeValue 写入单个值
func (s *StorageEngine) writeValue(file *os.File, value interface{}, dataType DataType) error <span class="cov8" title="1">{
        // 写入数据类型
        if err := binary.Write(file, binary.LittleEndian, uint8(dataType)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">switch v := value.(type) </span>{
        case int:<span class="cov8" title="1">
                if err := binary.Write(file, binary.LittleEndian, int64(v)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case int64:<span class="cov0" title="0">
                if err := binary.Write(file, binary.LittleEndian, v); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case float64:<span class="cov8" title="1">
                if err := binary.Write(file, binary.LittleEndian, v); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case bool:<span class="cov8" title="1">
                var boolValue uint8
                if v </span><span class="cov8" title="1">{
                        boolValue = 1
                }</span>
                <span class="cov8" title="1">if err := binary.Write(file, binary.LittleEndian, boolValue); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case string:<span class="cov8" title="1">
                // 写入字符串长度
                if err := binary.Write(file, binary.LittleEndian, uint32(len(v))); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // 写入字符串内容
                <span class="cov8" title="1">if _, err := file.WriteString(v); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported value type: %T", value)</span>
        }
        
        <span class="cov8" title="1">return nil</span>
}

// LoadTable 从文件加载表结构和数据
func (s *StorageEngine) LoadTable(tableName string) (*Table, error) <span class="cov8" title="1">{
        // 加载表结构
        schemaPath := filepath.Join(s.dataDir, tableName+".schema.json")
        schemaData, err := os.ReadFile(schemaPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read schema file: %v", err)
        }</span>
        
        <span class="cov8" title="1">var table Table
        if err := json.Unmarshal(schemaData, &amp;table); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal schema: %v", err)
        }</span>
        
        <span class="cov8" title="1">table.Rows = make([]Row, 0)
        
        // 加载表数据
        dataPath := filepath.Join(s.dataDir, tableName+".data")
        file, err := os.Open(dataPath)
        if err != nil </span><span class="cov0" title="0">{
                // 如果数据文件不存在，返回空表
                return &amp;table, nil
        }</span>
        <span class="cov8" title="1">defer file.Close()
        
        // 读取行数
        var rowCount uint32
        if err := binary.Read(file, binary.LittleEndian, &amp;rowCount); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read row count: %v", err)
        }</span>
        
        // 读取每一行数据
        <span class="cov8" title="1">for i := uint32(0); i &lt; rowCount; i++ </span><span class="cov8" title="1">{
                row, err := s.readRow(file, table.Columns)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to read row %d: %v", i, err)
                }</span>
                <span class="cov8" title="1">table.Rows = append(table.Rows, row)</span>
        }
        
        <span class="cov8" title="1">return &amp;table, nil</span>
}

// readRow 从文件读取一行数据
func (s *StorageEngine) readRow(file *os.File, columns []Column) (Row, error) <span class="cov8" title="1">{
        // 读取列数
        var colCount uint32
        if err := binary.Read(file, binary.LittleEndian, &amp;colCount); err != nil </span><span class="cov0" title="0">{
                return Row{}, err
        }</span>
        
        <span class="cov8" title="1">if int(colCount) != len(columns) </span><span class="cov0" title="0">{
                return Row{}, fmt.Errorf("column count mismatch: expected %d, got %d", len(columns), colCount)
        }</span>
        
        // 读取每一列的数据
        <span class="cov8" title="1">values := make([]interface{}, colCount)
        for i := uint32(0); i &lt; colCount; i++ </span><span class="cov8" title="1">{
                value, err := s.readValue(file)
                if err != nil </span><span class="cov0" title="0">{
                        return Row{}, err
                }</span>
                <span class="cov8" title="1">values[i] = value</span>
        }
        
        <span class="cov8" title="1">return Row{Values: values}, nil</span>
}

// readValue 从文件读取单个值
func (s *StorageEngine) readValue(file *os.File) (interface{}, error) <span class="cov8" title="1">{
        // 读取数据类型
        var dataType uint8
        if err := binary.Read(file, binary.LittleEndian, &amp;dataType); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov8" title="1">switch DataType(dataType) </span>{
        case TypeInt:<span class="cov8" title="1">
                var value int64
                if err := binary.Read(file, binary.LittleEndian, &amp;value); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return int(value), nil</span>
        case TypeFloat:<span class="cov0" title="0">
                var value float64
                if err := binary.Read(file, binary.LittleEndian, &amp;value); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return value, nil</span>
        case TypeBool:<span class="cov0" title="0">
                var value uint8
                if err := binary.Read(file, binary.LittleEndian, &amp;value); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return value != 0, nil</span>
        case TypeVarchar, TypeText:<span class="cov8" title="1">
                // 读取字符串长度
                var length uint32
                if err := binary.Read(file, binary.LittleEndian, &amp;length); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                
                // 读取字符串内容
                <span class="cov8" title="1">str := make([]byte, length)
                if _, err := file.Read(str); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                
                <span class="cov8" title="1">return string(str), nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported data type: %d", dataType)</span>
        }
}</pre>
		
		<pre class="file" id="file8" style="display: none">package main

import (
        "fmt"
        "strconv"
        "strings"
)

// DataType 定义数据类型
type DataType int

const (
        TypeInt DataType = iota
        TypeVarchar
        TypeText
        TypeFloat
        TypeBool
)

// Column 定义表列结构
type Column struct {
        Name     string
        Type     DataType
        Nullable bool
}

// Row 表示一行数据
type Row struct {
        Values []interface{}
}

// Table 定义表结构
type Table struct {
        Name    string
        Columns []Column
        Rows    []Row
}

// String 返回数据类型的字符串表示
func (dt DataType) String() string <span class="cov8" title="1">{
        switch dt </span>{
        case TypeInt:<span class="cov8" title="1">
                return "INT"</span>
        case TypeVarchar:<span class="cov8" title="1">
                return "VARCHAR"</span>
        case TypeText:<span class="cov0" title="0">
                return "TEXT"</span>
        case TypeFloat:<span class="cov8" title="1">
                return "FLOAT"</span>
        case TypeBool:<span class="cov8" title="1">
                return "BOOL"</span>
        default:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        }
}

// MarshalJSON 实现JSON序列化
func (dt DataType) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        return []byte(`"` + dt.String() + `"`), nil
}</span>

// UnmarshalJSON 实现JSON反序列化
func (dt *DataType) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        // 去除引号
        str := strings.Trim(string(data), `"`)
        
        parsed, err := ParseDataType(str)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">*dt = parsed
        return nil</span>
}

// ParseDataType 从字符串解析数据类型
func ParseDataType(s string) (DataType, error) <span class="cov8" title="1">{
        switch strings.ToUpper(s) </span>{
        case "INT", "INTEGER":<span class="cov8" title="1">
                return TypeInt, nil</span>
        case "VARCHAR":<span class="cov8" title="1">
                return TypeVarchar, nil</span>
        case "TEXT":<span class="cov0" title="0">
                return TypeText, nil</span>
        case "FLOAT", "DOUBLE":<span class="cov8" title="1">
                return TypeFloat, nil</span>
        case "BOOL", "BOOLEAN":<span class="cov8" title="1">
                return TypeBool, nil</span>
        default:<span class="cov0" title="0">
                return TypeInt, fmt.Errorf("unknown data type: %s", s)</span>
        }
}

// ParseValue 根据数据类型解析值
func ParseValue(value string, dataType DataType) (interface{}, error) <span class="cov8" title="1">{
        // 去除引号
        value = strings.TrimSpace(value)
        if (dataType == TypeVarchar || dataType == TypeText) &amp;&amp; 
           strings.HasPrefix(value, "'") &amp;&amp; strings.HasSuffix(value, "'") </span><span class="cov8" title="1">{
                value = value[1 : len(value)-1]
        }</span>

        <span class="cov8" title="1">switch dataType </span>{
        case TypeInt:<span class="cov8" title="1">
                return strconv.Atoi(value)</span>
        case TypeFloat:<span class="cov8" title="1">
                return strconv.ParseFloat(value, 64)</span>
        case TypeBool:<span class="cov8" title="1">
                lower := strings.ToLower(value)
                if lower == "true" || lower == "1" </span><span class="cov8" title="1">{
                        return true, nil
                }</span> else<span class="cov8" title="1"> if lower == "false" || lower == "0" </span><span class="cov8" title="1">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, fmt.Errorf("invalid boolean value: %s", value)</span>
        case TypeVarchar, TypeText:<span class="cov8" title="1">
                return value, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported data type: %d", dataType)</span>
        }
}

// ValueToString 将值转换为字符串用于存储
func ValueToString(value interface{}, dataType DataType) string <span class="cov0" title="0">{
        switch dataType </span>{
        case TypeInt, TypeFloat, TypeBool:<span class="cov0" title="0">
                return fmt.Sprintf("%v", value)</span>
        case TypeVarchar, TypeText:<span class="cov0" title="0">
                return fmt.Sprintf("'%v'", value)</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("%v", value)</span>
        }
}</pre>
		
		<pre class="file" id="file9" style="display: none">package anyDictV2

import "github.com/aid297/aid/array/anyArrayV2"

type (
        Attributer[K comparable, V any] interface{ Register(anyDict *AnyDict[K, V]) }

        AttrMap[K comparable, V any] struct{ dict map[K]V }
        AttrCap[K comparable, V any] struct{ cap int }
)

func Map[K comparable, V any](dict map[K]V) AttrMap[K, V] <span class="cov0" title="0">{ return AttrMap[K, V]{dict: dict} }</span>
func (my AttrMap[K, V]) Register(anyDict *AnyDict[K, V]) <span class="cov0" title="0">{
        anyDict.keys = anyArrayV2.New(anyArrayV2.Cap[K](len(my.dict)))
        anyDict.values = anyArrayV2.New(anyArrayV2.Cap[V](len(my.dict)))
        for idx := range my.dict </span><span class="cov0" title="0">{
                anyDict.data[idx] = my.dict[idx]
                anyDict.keys = anyDict.keys.Append(idx)
                anyDict.values = anyDict.values.Append(my.dict[idx])
        }</span>
}

func Cap[K comparable, V any](cap int) AttrCap[K, V] <span class="cov0" title="0">{ return AttrCap[K, V]{cap: cap} }</span>
func (my AttrCap[K, V]) Register(anyDict *AnyDict[K, V]) <span class="cov0" title="0">{
        anyDict.data = make(map[K]V, my.cap)
        anyDict.keys = anyArrayV2.New(anyArrayV2.Cap[K](my.cap))
        anyDict.values = anyArrayV2.New(anyArrayV2.Cap[V](my.cap))
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package anyDictV2

import (
        "encoding/json"
        "fmt"
        "reflect"
        "sync"

        "github.com/aid297/aid/array/anyArrayV2"
)

type AnyDict[K comparable, V any] struct {
        data   map[K]V
        keys   anyArrayV2.AnyArray[K]
        values anyArrayV2.AnyArray[V]
        mu     *sync.RWMutex
}

func New[K comparable, V any](attrs ...Attributer[K, V]) AnyDict[K, V] <span class="cov0" title="0">{
        return AnyDict[K, V]{data: make(map[K]V), mu: &amp;sync.RWMutex{}}.SetAttrs(attrs...)
}</span>

func (my AnyDict[K, V]) SetAttrs(attrs ...Attributer[K, V]) AnyDict[K, V] <span class="cov0" title="0">{
        if len(attrs) &gt; 0 </span><span class="cov0" title="0">{
                for idx := range attrs </span><span class="cov0" title="0">{
                        attrs[idx].Register(&amp;my)
                }</span>
        }
        <span class="cov0" title="0">return my</span>
}

func (my AnyDict[K, V]) Lock() AnyDict[K, V] <span class="cov0" title="0">{
        my.mu.Lock()
        return my
}</span>

func (my AnyDict[K, V]) Unlock() AnyDict[K, V] <span class="cov0" title="0">{
        my.mu.Unlock()
        return my
}</span>

func (my AnyDict[K, V]) RLock() AnyDict[K, V] <span class="cov0" title="0">{
        my.mu.RLock()
        return my
}</span>

func (my AnyDict[K, V]) RUnlock() AnyDict[K, V] <span class="cov0" title="0">{
        my.mu.RUnlock()
        return my
}</span>

func (my AnyDict[K, V]) ToString() string <span class="cov0" title="0">{ return fmt.Sprintf("%v", my.data) }</span>

func (my AnyDict[K, V]) ToMap() map[K]V <span class="cov0" title="0">{ return my.data }</span>

func (my AnyDict[K, V]) IsEmpty() bool <span class="cov0" title="0">{ return len(my.data) == 0 }</span>

func (my AnyDict[K, V]) IsNotEmpty() bool <span class="cov0" title="0">{ return !my.IsEmpty() }</span>

func (my AnyDict[K, V]) Has(key K) bool <span class="cov0" title="0">{
        _, ok := my.data[key]
        return ok
}</span>

func (my AnyDict[K, V]) SetValue(k K, v V) AnyDict[K, V] <span class="cov0" title="0">{
        if my.keys.In(k) </span><span class="cov0" title="0">{
                idx := my.keys.GetIndexByValue(k)
                my.keys = my.keys.SetValue(idx, k)
                my.values = my.values.SetValue(idx, v)
        }</span> else<span class="cov0" title="0"> {
                my.keys = my.keys.Append(k)
                my.values = my.values.Append(v)
        }</span>

        <span class="cov0" title="0">my.data[k] = v
        return my</span>
}

func (my AnyDict[K, V]) GetValueByKey(key K) (V, bool) <span class="cov0" title="0">{
        v, ok := my.data[key]
        return v, ok
}</span>

func (my AnyDict[K, V]) GetValuesByKeys(keys ...K) anyArrayV2.AnyArray[V] <span class="cov0" title="0">{
        res := anyArrayV2.New(anyArrayV2.Cap[V](len(keys)))

        for idx := range keys </span><span class="cov0" title="0">{
                if my.keys.In(keys[idx]) </span><span class="cov0" title="0">{
                        res = res.Append(my.data[keys[idx]])
                }</span>
        }

        <span class="cov0" title="0">return res</span>
}

func (my AnyDict[K, V]) GetKeyByValue(value V) (K, bool) <span class="cov0" title="0">{
        var k K
        for idx := range my.data </span><span class="cov0" title="0">{
                if reflect.DeepEqual(value, my.data[idx]) </span><span class="cov0" title="0">{
                        return idx, true
                }</span>
        }
        <span class="cov0" title="0">return k, false</span>
}

func (my AnyDict[K, V]) GetKeysByValues(values ...V) anyArrayV2.AnyArray[K] <span class="cov0" title="0">{
        res := anyArrayV2.New(anyArrayV2.Cap[K](len(values)))

        for idx := range values </span><span class="cov0" title="0">{
                if k, ok := my.GetKeyByValue(values[idx]); ok </span><span class="cov0" title="0">{
                        res = res.Append(k)
                }</span>
        }

        <span class="cov0" title="0">return res</span>
}

func (my AnyDict[K, V]) HasKey(key K) bool <span class="cov0" title="0">{ return my.keys.In(key) }</span>

func (my AnyDict[K, V]) HasKeys(keys ...K) bool <span class="cov0" title="0">{ return my.keys.In(keys...) }</span>

func (my AnyDict[K, V]) HasValue(value V) bool <span class="cov0" title="0">{ return my.values.In(value) }</span>

func (my AnyDict[K, V]) HasValues(values ...V) bool <span class="cov0" title="0">{ return my.values.In(values...) }</span>

func (my AnyDict[K, V]) HasKeyDefault(key K, existFn func(v V) V, notExistFn func() V) AnyDict[K, V] <span class="cov0" title="0">{
        if v, e := my.GetValueByKey(key); e </span><span class="cov0" title="0">{
                my = my.SetValue(key, existFn(v))
        }</span> else<span class="cov0" title="0"> {
                my = my.SetValue(key, notExistFn())
        }</span>

        <span class="cov0" title="0">return my</span>
}

func (my AnyDict[K, V]) GetKeys() anyArrayV2.AnyArray[K] <span class="cov0" title="0">{ return my.keys }</span>

func (my AnyDict[K, V]) GetValues() anyArrayV2.AnyArray[V] <span class="cov0" title="0">{ return my.values }</span>

func (my AnyDict[K, V]) Length() int <span class="cov0" title="0">{ return len(my.data) }</span>

func (my AnyDict[K, V]) LengthNotEmpty() int <span class="cov0" title="0">{ return my.RemoveEmpty().Length() }</span>

func (my AnyDict[K, V]) Filter(fn func(item V) bool) AnyDict[K, V] <span class="cov0" title="0">{
        res := New(Cap[K, V](my.Length()))

        for idx := range my.values.ToSlice() </span><span class="cov0" title="0">{
                if fn(my.values.GetValue(idx)) </span><span class="cov0" title="0">{
                        res = res.SetValue(my.keys.GetValue(idx), my.values.GetValue(idx))
                }</span>
        }

        <span class="cov0" title="0">return res</span>
}

func (my AnyDict[K, V]) RemoveEmpty() AnyDict[K, V] <span class="cov0" title="0">{
        return my.Filter(func(item V) bool </span><span class="cov0" title="0">{
                ref := reflect.ValueOf(item)

                if ref.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                        if ref.IsNil() </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov0" title="0">if ref.Elem().IsZero() </span><span class="cov0" title="0">{
                                return false
                        }</span>
                } else<span class="cov0" title="0"> {
                        if ref.IsZero() </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }

                <span class="cov0" title="0">return true</span>
        })
}

func (my AnyDict[K, V]) Join(sep string) string <span class="cov0" title="0">{ return my.values.Join(sep) }</span>

func (my AnyDict[K, V]) JoinNotEmpty(sep string) string <span class="cov0" title="0">{ return my.values.JoinNotEmpty(sep) }</span>

func (my AnyDict[K, V]) InKey(keys ...V) bool <span class="cov0" title="0">{ return my.values.In(keys...) }</span>

func (my AnyDict[K, V]) NotInKey(keys ...V) bool <span class="cov0" title="0">{ return !my.values.In(keys...) }</span>

func (my AnyDict[K, V]) InValue(values ...V) bool <span class="cov0" title="0">{ return my.values.In(values...) }</span>

func (my AnyDict[K, V]) NotInValue(values ...V) bool <span class="cov0" title="0">{ return !my.values.In(values...) }</span>

func (my AnyDict[K, V]) AllEmpty() bool <span class="cov0" title="0">{ return my.values.AllEmpty() }</span>

func (my AnyDict[K, V]) AnyEmpty() bool <span class="cov0" title="0">{ return my.values.AnyEmpty() }</span>

func (my AnyDict[K, V]) RemoveByKey(key K) AnyDict[K, V] <span class="cov0" title="0">{
        if my.keys.In(key) </span><span class="cov0" title="0">{
                idx := my.keys.GetIndexByValue(key)
                my.keys = my.keys.RemoveByIndex(idx)
                my.values = my.values.RemoveByIndex(idx)

                newData := New(Cap[K, V](len(my.data) - 1))
                for idx := range my.keys.ToSlice() </span><span class="cov0" title="0">{
                        newData = newData.SetValue(my.keys.GetValue(idx), my.values.GetValue(idx))
                }</span>

                <span class="cov0" title="0">return newData</span>
        }

        <span class="cov0" title="0">return my</span>
}

func (my AnyDict[K, V]) RemoveByKeys(keys ...K) AnyDict[K, V] <span class="cov0" title="0">{
        for idx := range keys </span><span class="cov0" title="0">{
                my = my.RemoveByKey(keys[idx])
        }</span>

        <span class="cov0" title="0">return my</span>
}

func (my AnyDict[K, V]) RemoveByValue(value V) AnyDict[K, V] <span class="cov0" title="0">{
        if my.values.In(value) </span><span class="cov0" title="0">{
                idx := my.values.GetIndexByValue(value)
                my.keys = my.keys.RemoveByIndex(idx)
                my.values = my.values.RemoveByIndex(idx)

                newData := New(Cap[K, V](len(my.data) - 1))
                for idx := range my.keys.ToSlice() </span><span class="cov0" title="0">{
                        newData = newData.SetValue(my.keys.GetValue(idx), my.values.GetValue(idx))
                }</span>

                <span class="cov0" title="0">return newData</span>
        }

        <span class="cov0" title="0">return my</span>
}

func (my AnyDict[K, V]) RemoveByValues(values ...V) AnyDict[K, V] <span class="cov0" title="0">{
        for idx := range values </span><span class="cov0" title="0">{
                my = my.RemoveByValue(values[idx])
        }</span>

        <span class="cov0" title="0">return my</span>
}

func (my AnyDict[K, V]) Every(fn func(key K, value V) V) AnyDict[K, V] <span class="cov0" title="0">{
        for idx := range my.keys.ToSlice() </span><span class="cov0" title="0">{
                k := my.keys.GetValue(idx)
                v := my.values.GetValue(idx)
                newV := fn(k, v)
                my = my.SetValue(k, newV)
        }</span>

        <span class="cov0" title="0">return my</span>
}

func (my AnyDict[K, V]) Each(fn func(key K, value V)) AnyDict[K, V] <span class="cov0" title="0">{
        for idx := range my.keys.ToSlice() </span><span class="cov0" title="0">{
                k := my.keys.GetValue(idx)
                v := my.values.GetValue(idx)
                fn(k, v)
        }</span>

        <span class="cov0" title="0">return my</span>
}

func (my AnyDict[K, V]) Clean() AnyDict[K, V] <span class="cov0" title="0">{
        my.keys.Clean()
        my.values.Clean()
        my.data = make(map[K]V)
        return my
}</span>

// MarshalJSON 实现接口：json序列化
func (my AnyDict[K, V]) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{ return json.Marshal(&amp;my.data) }</span>

// UnmarshalJSON 实现接口：json反序列化
func (my AnyDict[K, V]) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{ return json.Unmarshal(data, &amp;my.data) }</span>

// Cast 转换所有值并创建新AnyDict
func Cast[K comparable, SRC, DST any](src AnyDict[K, SRC], fn func(key K, value SRC) DST) AnyDict[K, DST] <span class="cov0" title="0">{
        var d = New[K, DST]()

        for key, value := range src.data </span><span class="cov0" title="0">{
                d = d.SetValue(key, fn(key, value))
        }</span>

        <span class="cov0" title="0">return d</span>
}

// Zip 组合键值对为一个新的有序map
func Zip[K comparable, V any](keys []K, values []V) AnyDict[K, V] <span class="cov0" title="0">{
        var d = New[K, V]()
        for idx, key := range keys </span><span class="cov0" title="0">{
                d = d.SetValue(key, values[idx])
        }</span>

        <span class="cov0" title="0">return d</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package dict

import (
        "encoding/json"
        "fmt"
        "reflect"
        "strings"
        "sync"

        "github.com/aid297/aid/array"
)

type (
        // AnyDict 任意类型字典
        AnyDict[K comparable, V any] struct {
                data   map[K]V
                keys   []K
                values []V
                mu     sync.RWMutex
        }

        // AnyOrderlyItem 可排序的任意类型字典
        AnyOrderlyItem[K comparable, V any] struct {
                Key   K
                Value V
        }
)

// New 根据map创建无序map
func New[K comparable, V any](m map[K]V) *AnyDict[K, V] <span class="cov0" title="0">{
        d := Make[K, V]()

        for key, value := range m </span><span class="cov0" title="0">{
                d.Set(key, value)
        }</span>

        <span class="cov0" title="0">return d</span>
}

// Make 创建空有序列表
func Make[K comparable, V any]() *AnyDict[K, V] <span class="cov8" title="1">{
        return &amp;AnyDict[K, V]{
                data:   make(map[K]V),
                keys:   make([]K, 0),
                values: make([]V, 0),
                mu:     sync.RWMutex{},
        }
}</span>

// Lock 加锁：写锁
func (my *AnyDict[K, V]) Lock() *AnyDict[K, V] <span class="cov0" title="0">{
        my.mu.Lock()
        return my
}</span>

// Unlock 解锁：写锁
func (my *AnyDict[K, V]) Unlock() *AnyDict[K, V] <span class="cov0" title="0">{
        my.mu.Unlock()
        return my
}</span>

// RLock 加锁：读锁
func (my *AnyDict[K, V]) RLock() *AnyDict[K, V] <span class="cov0" title="0">{
        my.mu.RLock()
        return my
}</span>

// RUnlock 解锁：读锁
func (my *AnyDict[K, V]) RUnlock() *AnyDict[K, V] <span class="cov0" title="0">{
        my.mu.RUnlock()
        return my
}</span>

func (my *AnyDict[K, V]) getKeyByIndex(idx int) K <span class="cov8" title="1">{ return my.keys[idx] }</span>

// GetKeyByIndex 通过索引获取键
func (my *AnyDict[K, V]) GetKeyByIndex(idx int) K <span class="cov8" title="1">{
        return my.getKeyByIndex(idx)
}</span>

func (my *AnyDict[K, V]) getKeysByIndexes(indexes ...int) *array.AnyArray[K] <span class="cov8" title="1">{
        keys := make([]K, 0, len(indexes))

        for _, idx := range indexes </span><span class="cov8" title="1">{
                keys = append(keys, my.getKeyByIndex(idx))
        }</span>

        <span class="cov8" title="1">return array.New(keys)</span>
}

// GetKeysByIndexes 通过索引获取多个键
func (my *AnyDict[K, V]) GetKeysByIndexes(indexes ...int) *array.AnyArray[K] <span class="cov8" title="1">{

        return my.getKeysByIndexes(indexes...)
}</span>

func (my *AnyDict[K, V]) getKeyByValue(value V) K <span class="cov8" title="1">{
        var zero K

        for key, val := range my.data </span><span class="cov8" title="1">{
                if reflect.DeepEqual(val, value) </span><span class="cov8" title="1">{
                        return key
                }</span>
        }

        <span class="cov0" title="0">return zero</span>
}

// GetKeyByValue 通过值获取键
func (my *AnyDict[K, V]) GetKeyByValue(value V) K <span class="cov8" title="1">{
        return my.getKeyByValue(value)
}</span>

func (my *AnyDict[K, V]) getKeysByValues(values ...V) *array.AnyArray[K] <span class="cov8" title="1">{
        var ret = make([]K, 0)

        for _, value := range values </span><span class="cov8" title="1">{
                ret = append(ret, my.getKeyByValue(value))
        }</span>

        <span class="cov8" title="1">return array.New(ret)</span>
}

// GetKeysByValues 通过值获取多个键
func (my *AnyDict[K, V]) GetKeysByValues(values ...V) *array.AnyArray[K] <span class="cov8" title="1">{
        return my.getKeysByValues(values...)
}</span>

func (my *AnyDict[K, V]) getValueByIndex(index int) V <span class="cov8" title="1">{ return my.values[index] }</span>

// GetValueByIndex 通过索引获取值
func (my *AnyDict[K, V]) GetValueByIndex(index int) V <span class="cov8" title="1">{
        return my.getValueByIndex(index)
}</span>

func (my *AnyDict[K, V]) getValuesByIndexes(indexes ...int) *array.AnyArray[V] <span class="cov8" title="1">{
        values := make([]V, 0, len(indexes))

        for _, idx := range indexes </span><span class="cov8" title="1">{
                values = append(values, my.values[idx])
        }</span>

        <span class="cov8" title="1">return array.New(values)</span>
}

// GetValsByIndexes 通过索引获取多个值
func (my *AnyDict[K, V]) GetValsByIndexes(indexes ...int) *array.AnyArray[V] <span class="cov0" title="0">{
        return my.GetValuesByIndexes(indexes...)
}</span>

// GetValuesByIndexes 通过索引获取多个值
func (my *AnyDict[K, V]) GetValuesByIndexes(indexes ...int) *array.AnyArray[V] <span class="cov8" title="1">{

        return my.getValuesByIndexes(indexes...)
}</span>

func (my *AnyDict[K, V]) getValueByKey(key K) V <span class="cov8" title="1">{ return my.data[key] }</span>

// GetValueByKey 通过键获取值
func (my *AnyDict[K, V]) GetValueByKey(key K) V <span class="cov8" title="1">{
        return my.getValueByKey(key)
}</span>

func (my *AnyDict[K, V]) getValuesByKeys(keys ...K) *array.AnyArray[V] <span class="cov8" title="1">{
        values := make([]V, 0, len(keys))

        for _, key := range keys </span><span class="cov8" title="1">{
                values = append(values, my.data[key])
        }</span>

        <span class="cov8" title="1">return array.New(values)</span>
}

// GetValuesByKeys 通过值获取多个键
func (my *AnyDict[K, V]) GetValuesByKeys(keys ...K) *array.AnyArray[V] <span class="cov8" title="1">{
        return my.getValuesByKeys(keys...)
}</span>

func (my *AnyDict[K, V]) getIndexByKey(key K) int <span class="cov8" title="1">{
        for i, k := range my.keys </span><span class="cov8" title="1">{
                if k == key </span><span class="cov8" title="1">{
                        return i
                }</span>
        }

        <span class="cov0" title="0">return -1</span>
}

// GetIndexByKey 通过键获取索引
func (my *AnyDict[K, V]) GetIndexByKey(key K) int <span class="cov8" title="1">{
        return my.getIndexByKey(key)
}</span>

func (my *AnyDict[K, V]) getIndexesByKeys(keys ...K) *array.AnyArray[int] <span class="cov8" title="1">{
        var ret = make([]int, 0)

        for _, key := range keys </span><span class="cov8" title="1">{
                for idx, k := range my.keys </span><span class="cov8" title="1">{
                        if k == key </span><span class="cov8" title="1">{
                                ret = append(ret, idx)
                        }</span>
                }
        }

        <span class="cov8" title="1">return array.New(ret)</span>
}

// GetIndexesByKeys 通过键获取多个索引
func (my *AnyDict[K, V]) GetIndexesByKeys(keys ...K) *array.AnyArray[int] <span class="cov8" title="1">{
        return my.getIndexesByKeys(keys...)
}</span>

func (my *AnyDict[K, V]) getIndexByValue(value V) int <span class="cov8" title="1">{
        for idx, val := range my.values </span><span class="cov8" title="1">{
                if reflect.DeepEqual(val, value) </span><span class="cov8" title="1">{
                        return idx
                }</span>
        }

        <span class="cov0" title="0">return -1</span>
}

// GetIndexByValue 通过值获取索引
func (my *AnyDict[K, V]) GetIndexByValue(value V) int <span class="cov8" title="1">{
        return my.getIndexByValue(value)
}</span>

func (my *AnyDict[K, V]) getIndexesByValues(values ...V) *array.AnyArray[int] <span class="cov8" title="1">{
        var ret = make([]int, 0)

        for _, value := range values </span><span class="cov8" title="1">{
                for idx, val := range my.values </span><span class="cov8" title="1">{
                        if reflect.DeepEqual(val, value) </span><span class="cov8" title="1">{
                                ret = append(ret, idx)
                        }</span>
                }
        }

        <span class="cov8" title="1">return array.New(ret)</span>
}

// GetIndexesByVals 通过值获取多个索引
func (my *AnyDict[K, V]) GetIndexesByVals(vals ...V) *array.AnyArray[int] <span class="cov0" title="0">{
        return my.GetIndexesByValues(vals...)
}</span>

// GetIndexesByValues 通过值获取多个索引
func (my *AnyDict[K, V]) GetIndexesByValues(values ...V) *array.AnyArray[int] <span class="cov8" title="1">{

        return my.getIndexesByValues(values...)
}</span>

// hasKey 判断是否有键
func (my *AnyDict[K, V]) hasKey(key K) bool <span class="cov0" title="0">{
        return my.getIndexByKey(key) &gt; -1
}</span>

// HasKey 检查键是否存在
func (my *AnyDict[K, V]) HasKey(key K) bool <span class="cov0" title="0">{

        return my.hasKey(key)
}</span>

// HasKeys 检查多个键是否全部存在
func (my *AnyDict[K, V]) HasKeys(keys ...K) bool <span class="cov0" title="0">{

        return my.getIndexesByKeys(keys...).Len() == len(keys)
}</span>

// HasValue 检查值是否存在
func (my *AnyDict[K, V]) HasValue(value V) bool <span class="cov0" title="0">{
        return my.getIndexByValue(value) &gt; -1
}</span>

// HasValues 检查多个值是否全部存在
func (my *AnyDict[K, V]) HasValues(values ...V) bool <span class="cov0" title="0">{
        return my.getIndexesByValues(values...).Len() == len(values)
}</span>

// HasIndex 检查索引是否存在
func (my *AnyDict[K, V]) HasIndex(index int) bool <span class="cov0" title="0">{
        var zero K

        return !reflect.DeepEqual(my.getKeyByIndex(index), zero)
}</span>

// HasIndexes 检查多个索引是否全部存在
func (my *AnyDict[K, V]) HasIndexes(indexes ...int) bool <span class="cov0" title="0">{
        return my.getKeysByIndexes(indexes...).Len() == len(indexes)
}</span>

func (my *AnyDict[K, V]) hasKeyDefault(key K, existFn func(v V), notExistFn func() V) *AnyDict[K, V] <span class="cov0" title="0">{
        if v, e := my.get(key); e </span><span class="cov0" title="0">{
                existFn(v)
        }</span> else<span class="cov0" title="0"> {
                my.set(key, notExistFn())
        }</span>

        <span class="cov0" title="0">return my</span>
}

// HasKeyDefault 判断key是否存在，并执行后续操作
func (my *AnyDict[K, V]) HasKeyDefault(key K, existFn func(v V), notExistFn func() V) *AnyDict[K, V] <span class="cov0" title="0">{

        return my.hasKeyDefault(key, existFn, notExistFn)
}</span>

func (my *AnyDict[K, V]) len() int <span class="cov8" title="1">{ return len(my.keys) }</span>

// Len 获取长度
func (my *AnyDict[K, V]) Len() int <span class="cov8" title="1">{

        return my.len()
}</span>

func (my *AnyDict[K, V]) lenWithoutEmpty() int <span class="cov0" title="0">{ return my.copy().removeEmpty().len() }</span>

// LenWithoutEmpty 判断非0值的长度
func (my *AnyDict[K, V]) LenWithoutEmpty() int <span class="cov0" title="0">{
        return my.lenWithoutEmpty()
}</span>

func (my *AnyDict[K, V]) isEmpty() bool <span class="cov8" title="1">{ return my.len() == 0 }</span>

// IsEmpty 判断是否为空map
func (my *AnyDict[K, V]) IsEmpty() bool <span class="cov8" title="1">{ return my.isEmpty() }</span>

func (my *AnyDict[K, V]) set(key K, value V) *AnyDict[K, V] <span class="cov8" title="1">{
        my.data[key] = value
        my.keys = append(my.keys, key)
        my.values = append(my.values, value)

        return my
}</span>

// Set 设置键值对
func (my *AnyDict[K, V]) Set(key K, value V) *AnyDict[K, V] <span class="cov8" title="1">{ return my.set(key, value) }</span>

func (my *AnyDict[K, V]) get(key K) (V, bool) <span class="cov0" title="0">{
        v, e := my.data[key]
        return v, e
}</span>

// Get 通过键获取值，同时获取exist
func (my *AnyDict[K, V]) Get(key K) (V, bool) <span class="cov0" title="0">{ return my.get(key) }</span>

func (my *AnyDict[K, V]) copy() *AnyDict[K, V] <span class="cov8" title="1">{
        var d = Make[K, V]()

        for idx, key := range my.keys </span><span class="cov8" title="1">{
                d.set(key, my.values[idx])
        }</span>

        <span class="cov8" title="1">return d</span>
}

// Copy 复制一个新的map
func (my *AnyDict[K, V]) Copy() *AnyDict[K, V] <span class="cov8" title="1">{ return my.copy() }</span>

func (my *AnyDict[K, V]) toOrderlyMap() []AnyOrderlyItem[K, V] <span class="cov0" title="0">{
        var items = make([]AnyOrderlyItem[K, V], 0, len(my.keys))

        for idx, key := range my.keys </span><span class="cov0" title="0">{
                items = append(items, AnyOrderlyItem[K, V]{Key: key, Value: my.values[idx]})
        }</span>

        <span class="cov0" title="0">return items</span>
}

// ToOrderlyMap 导出一个可排序map
func (my *AnyDict[K, V]) ToOrderlyMap() []AnyOrderlyItem[K, V] <span class="cov0" title="0">{ return my.toOrderlyMap() }</span>

func (my *AnyDict[K, V]) toMap() map[K]V <span class="cov8" title="1">{ return my.data }</span>

// ToMap 获取一个普通map
func (my *AnyDict[K, V]) ToMap() map[K]V <span class="cov8" title="1">{ return my.toMap() }</span>

func (my *AnyDict[K, V]) toString() string <span class="cov0" title="0">{ return fmt.Sprintf("%v", my.data) }</span>

// ToString 获取字符串
func (my *AnyDict[K, V]) ToString() string <span class="cov0" title="0">{ return my.toString() }</span>

func (my *AnyDict[K, V]) getKeys() *array.AnyArray[K] <span class="cov8" title="1">{ return array.New(my.keys) }</span>

// GetKeys 获取所有键：*array.AnyArray[K]
func (my *AnyDict[K, V]) GetKeys() *array.AnyArray[K] <span class="cov8" title="1">{

        return my.getKeys()
}</span>

func (my *AnyDict[K, V]) getValues() *array.AnyArray[V] <span class="cov8" title="1">{ return array.New(my.values) }</span>

// GetValues 获取所有值：*array.AnyArray[V]
func (my *AnyDict[K, V]) GetValues() *array.AnyArray[V] <span class="cov8" title="1">{ return my.getValues() }</span>

func (my *AnyDict[K, V]) getIndexes() *array.AnyArray[int] <span class="cov8" title="1">{
        var ret = make([]int, 0, len(my.keys))

        for i := range my.keys </span><span class="cov8" title="1">{
                ret = append(ret, i)
        }</span>

        <span class="cov8" title="1">return array.New(ret)</span>
}

// GetIndexes 获取所有索引：*array.AnyArray[int]
func (my *AnyDict[K, V]) GetIndexes() *array.AnyArray[int] <span class="cov0" title="0">{ return my.getIndexes() }</span>

func (my *AnyDict[K, V]) firstKey() K <span class="cov8" title="1">{ return my.keys[0] }</span>

// FirstKey 获取第一个键
func (my *AnyDict[K, V]) FirstKey() K <span class="cov8" title="1">{ return my.firstKey() }</span>

func (my *AnyDict[K, V]) firstValue() V <span class="cov8" title="1">{ return my.values[0] }</span>

// FirstValue 获取第一个值
func (my *AnyDict[K, V]) FirstValue() V <span class="cov8" title="1">{ return my.firstValue() }</span>

func (my *AnyDict[K, V]) lastKey() K <span class="cov8" title="1">{ return my.keys[len(my.keys)-1] }</span>

// LastKey 获取最后一个键
func (my *AnyDict[K, V]) LastKey() K <span class="cov8" title="1">{ return my.lastKey() }</span>

func (my *AnyDict[K, V]) lastValue() V <span class="cov8" title="1">{ return my.values[len(my.values)-1] }</span>

// LastValue 获取最后一个值
func (my *AnyDict[K, V]) LastValue() V <span class="cov8" title="1">{ return my.lastValue() }</span>

func (my *AnyDict[K, V]) filter(fn func(key K, value V) bool) *AnyDict[K, V] <span class="cov8" title="1">{
        var d = Make[K, V]()

        for key, value := range my.data </span><span class="cov8" title="1">{
                if fn(key, value) </span><span class="cov8" title="1">{
                        d.set(key, value)
                }</span>
        }

        <span class="cov8" title="1">return d</span>
}

// Filter 通过键值对过滤
func (my *AnyDict[K, V]) Filter(fn func(key K, value V) bool) *AnyDict[K, V] <span class="cov8" title="1">{
        d := my.filter(fn)
        my.data = d.data
        my.keys = d.keys
        my.values = d.values
        return my
}</span>

func (my *AnyDict[K, V]) removeByKey(key K) *AnyDict[K, V] <span class="cov8" title="1">{
        var d = Make[K, V]()

        for idx, k := range my.keys </span><span class="cov8" title="1">{
                if k == key </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">d.set(k, my.values[idx])</span>
        }

        <span class="cov8" title="1">return d</span>
}

// RemoveByKey 通过键移除元素
func (my *AnyDict[K, V]) RemoveByKey(key K) *AnyDict[K, V] <span class="cov8" title="1">{
        d := my.removeByKey(key)
        my.data = d.data
        my.keys = d.keys
        my.values = d.values
        return my
}</span>

func (my *AnyDict[K, V]) removeByValue(value V) *AnyDict[K, V] <span class="cov8" title="1">{
        var d = Make[K, V]()

        for idx, val := range my.values </span><span class="cov8" title="1">{
                if reflect.DeepEqual(val, value) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">d.set(my.keys[idx], val)</span>
        }

        <span class="cov8" title="1">return d</span>
}

// RemoveByValue 通过值移除元素
func (my *AnyDict[K, V]) RemoveByValue(value V) *AnyDict[K, V] <span class="cov8" title="1">{
        d := my.removeByValue(value)
        my.data = d.data
        my.keys = d.keys
        my.values = d.values
        return my
}</span>

func (my *AnyDict[K, V]) removeEmpty() *AnyDict[K, V] <span class="cov8" title="1">{
        d := Make[K, V]()

        for idx, value := range my.values </span><span class="cov8" title="1">{
                ref := reflect.ValueOf(value)

                if ref.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                        if ref.IsNil() </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if ref.Elem().IsZero() </span><span class="cov0" title="0">{
                                continue</span>
                        }
                } else<span class="cov8" title="1"> {
                        if ref.IsZero() </span><span class="cov8" title="1">{
                                continue</span>
                        }
                }

                <span class="cov8" title="1">d.set(my.keys[idx], value)</span>
        }

        <span class="cov8" title="1">return d</span>
}

// RemoveEmpty 移除0值元素
func (my *AnyDict[K, V]) RemoveEmpty() *AnyDict[K, V] <span class="cov8" title="1">{
        d := my.removeEmpty()
        my.data = d.data
        my.keys = d.keys
        my.values = d.values
        return my
}</span>

func (my *AnyDict[K, V]) join(sep string) string <span class="cov8" title="1">{
        var values = make([]string, 0, len(my.values))

        for _, value := range my.values </span><span class="cov8" title="1">{
                values = append(values, fmt.Sprintf("%v", value))
        }</span>

        <span class="cov8" title="1">return strings.Join(values, sep)</span>
}

// Join 将所有值转为字符串并拼接
func (my *AnyDict[K, V]) Join(seps ...string) string <span class="cov8" title="1">{
        if len(seps) == 0 </span><span class="cov0" title="0">{
                return my.join(" ")
        }</span> else<span class="cov8" title="1"> {
                return my.join(seps[0])
        }</span>
}

func (my *AnyDict[K, V]) joinWithoutEmpty(sep string) string <span class="cov8" title="1">{
        return my.copy().removeEmpty().join(sep)
}</span>

// JoinWithoutEmpty 将去掉0值后转为字符串并拼接
func (my *AnyDict[K, V]) JoinWithoutEmpty(seps ...string) string <span class="cov8" title="1">{
        if len(seps) == 0 </span><span class="cov0" title="0">{
                return my.joinWithoutEmpty(" ")
        }</span> else<span class="cov8" title="1"> {
                return my.joinWithoutEmpty(seps[0])
        }</span>
}

func (my *AnyDict[K, V]) inKeys(keys ...K) bool <span class="cov8" title="1">{
        return my.getIndexesByKeys(keys...).Len() == len(keys)
}</span>

// InKeys 检查多个键是否存在
func (my *AnyDict[K, V]) InKeys(keys ...K) bool <span class="cov8" title="1">{ return my.inKeys(keys...) }</span>

// NotInKeys 检查多个键是否不存在
func (my *AnyDict[K, V]) NotInKeys(keys ...K) bool <span class="cov0" title="0">{ return !my.inKeys(keys...) }</span>

func (my *AnyDict[K, V]) inValues(values ...V) bool <span class="cov8" title="1">{
        return my.getIndexesByValues(values...).Len() == len(values)
}</span>

// InValues 检查多个值是否存在
func (my *AnyDict[K, V]) InValues(values ...V) bool <span class="cov8" title="1">{ return my.inValues(values...) }</span>

// NotInValues 检查多个值是否不存在
func (my *AnyDict[K, V]) NotInValues(values ...V) bool <span class="cov0" title="0">{ return !my.inValues(values...) }</span>

func (my *AnyDict[K, V]) every(fn func(key K, value V) (K, V)) *AnyDict[K, V] <span class="cov8" title="1">{
        var d = Make[K, V]()

        for key, value := range my.data </span><span class="cov8" title="1">{
                k, v := fn(key, value)
                d.set(k, v)
        }</span>

        <span class="cov8" title="1">return d</span>
}

// Every 遍历所有元素并回填
func (my *AnyDict[K, V]) Every(fn func(key K, value V) (K, V)) *AnyDict[K, V] <span class="cov8" title="1">{
        d := my.every(fn)
        my.data = d.data
        my.keys = d.keys
        my.values = d.values
        return my
}</span>

func (my *AnyDict[K, V]) each(fn func(key K, value V)) *AnyDict[K, V] <span class="cov8" title="1">{
        for key, value := range my.data </span><span class="cov8" title="1">{
                fn(key, value)
        }</span>
        <span class="cov8" title="1">return my</span>
}

// Each 遍历所有元素
func (my *AnyDict[K, V]) Each(fn func(key K, value V)) *AnyDict[K, V] <span class="cov8" title="1">{ return my.each(fn) }</span>

func (my *AnyDict[K, V]) clean() *AnyDict[K, V] <span class="cov8" title="1">{
        my.data = make(map[K]V)
        my.keys = make([]K, 0)
        my.values = make([]V, 0)
        return my
}</span>

// Clean 清空
func (my *AnyDict[K, V]) Clean() *AnyDict[K, V] <span class="cov8" title="1">{ return my.clean() }</span>

func (my *AnyDict[K, V]) marshalJson() ([]byte, error) <span class="cov8" title="1">{ return json.Marshal(&amp;my.data) }</span>

// MarshalJSON json接口实现：序列化
func (my *AnyDict[K, V]) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{ return my.marshalJson() }</span>

func (my *AnyDict[K, V]) unmarshalJson(data []byte) error <span class="cov8" title="1">{ return json.Unmarshal(data, &amp;my.data) }</span>

// UnmarshalJSON json接口实现：反序列化
func (my *AnyDict[K, V]) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        if err := my.unmarshalJson(data); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">my.keys = make([]K, 0)
        my.values = make([]V, 0)
        for key, value := range my.data </span><span class="cov8" title="1">{
                my.keys = append(my.keys, key)
                my.values = append(my.values, value)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Cast 转换所有值并创建新AnyDict
func Cast[K comparable, SRC, DST any](src *AnyDict[K, SRC], fn func(key K, value SRC) DST) *AnyDict[K, DST] <span class="cov0" title="0">{
        var d = Make[K, DST]()

        for key, value := range src.data </span><span class="cov0" title="0">{
                d.set(key, fn(key, value))
        }</span>

        <span class="cov0" title="0">return d</span>
}

// Zip 组合键值对为一个新的有序map
func Zip[K comparable, V any](keys []K, values []V) *AnyDict[K, V] <span class="cov0" title="0">{
        var d = Make[K, V]()
        for idx, key := range keys </span><span class="cov0" title="0">{
                d.Set(key, values[idx])
        }</span>

        <span class="cov0" title="0">return d</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package digest

import "golang.org/x/crypto/bcrypt"

// BcryptHash 使用 bcrypt 对密码进行加密
func BcryptHash(password string) string <span class="cov0" title="0">{
        bytes, _ := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        return string(bytes)
}</span>

// BcryptCheck 对比明文密码和数据库的哈希值
func BcryptCheck(password, hash string) bool <span class="cov0" title="0">{
        err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
        return err == nil
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package digest

import (
        "crypto/md5"
        "encoding/hex"
)

// Md5 编码
func Md5(original []byte) (string, error) <span class="cov0" title="0">{
        hash := md5.New()
        if _, err := hash.Write(original); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return hex.EncodeToString(hash.Sum(nil)), nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package digest

import (
        "crypto/sha256"
        "encoding/hex"
)

// Sha256 摘要算法
func Sha256(original []byte) (string, error) <span class="cov0" title="0">{
        hash := sha256.New()
        if _, err := hash.Write(original); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">shaString := hex.EncodeToString(hash.Sum(nil))

        return shaString, nil</span>
}

// Sha256Sum256 摘要算法
func Sha256Sum256(original []byte) string <span class="cov0" title="0">{
        hash := sha256.Sum256(original)
        return hex.EncodeToString(hash[:])
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package digest

import (
        "github.com/tjfoc/gmsm/sm3"

        "encoding/hex"
)

// Sm3 生成sm3摘要
func Sm3(original []byte) string <span class="cov0" title="0">{
        h := sm3.New()
        if _, err := h.Write(original); err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return hex.EncodeToString(h.Sum(nil))</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package excel

import (
        "fmt"
        "reflect"

        "github.com/aid297/aid/array"
        "github.com/aid297/aid/myError"
        "github.com/aid297/aid/operation"
)

type (
        SetCellError struct{ myError.MyError }
        ReadError    struct{ myError.MyError }
        WriteError   struct{ myError.MyError }
)

var (
        SetCellErr SetCellError
        ReadErr    ReadError
        WriteErr   WriteError
)

func (*ReadError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;ReadError{myError.MyError{Msg: array.NewDestruction("读取数据错误", msg).JoinWithoutEmpty("：")}}
}</span>

func (*ReadError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;ReadError{myError.MyError{Msg: fmt.Errorf("读取数据错误"+operation.Ternary(err != nil, "：%w", "%w"), err).Error()}}
}</span>

func (*ReadError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;ReadError{myError.MyError{Msg: "读取数据错误"}}
}</span>

func (my *ReadError) Error() string <span class="cov0" title="0">{ return my.Msg }</span>

func (my *ReadError) Is(target error) bool <span class="cov0" title="0">{ return reflect.DeepEqual(target, &amp;ReadErr) }</span>

func (*SetCellError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;SetCellError{myError.MyError{Msg: array.NewDestruction("设置单元格错误", msg).JoinWithoutEmpty("：")}}
}</span>

func (*SetCellError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;SetCellError{myError.MyError{Msg: fmt.Errorf("设置单元格错误"+operation.Ternary(err != nil, "：%w", "%w"), err).Error()}}
}</span>

func (*SetCellError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;SetCellError{myError.MyError{Msg: "设置单元格错误"}}
}</span>

func (my *SetCellError) Error() string <span class="cov0" title="0">{ return my.Msg }</span>

func (my *SetCellError) Is(target error) bool <span class="cov0" title="0">{ return reflect.DeepEqual(target, &amp;SetCellErr) }</span>

func (*WriteError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;WriteError{myError.MyError{Msg: array.NewDestruction("写入数据错误", msg).JoinWithoutEmpty("：")}}
}</span>

func (*WriteError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;WriteError{myError.MyError{Msg: fmt.Errorf("写入数据错误"+operation.Ternary(err != nil, "：%w", "%w"), err).Error()}}
}</span>

func (*WriteError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;WriteError{myError.MyError{Msg: "写入数据错误"}}
}</span>

func (my *WriteError) Error() string <span class="cov0" title="0">{ return my.Msg }</span>

func (my *WriteError) Is(target error) bool <span class="cov0" title="0">{ return reflect.DeepEqual(target, &amp;WriteErr) }</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package excelV2

type (
        CellAttributer interface{ Register(cell *Cell) }

        AttrCellContent       struct{ content any }
        AttrCellContentType   struct{ contentType CellContentType }
        AttrCellCoordinate    struct{ coordinate string }
        AttrCellFontRGB       struct{ rgb string }
        AttrCellPatternRGB    struct{ rgb string }
        AttrCellFontBold      struct{ fontBold bool }
        AttrCellFontItalic    struct{ fontItalic bool }
        AttrCellFontSize      struct{ fontSize float64 }
        AttrCellBorderRGB     struct{ top, bottom, left, right string }
        AttrCellBorderStyle   struct{ top, bottom, left, right int }
        AttrCellDiagonalRGB   struct{ up, down string }
        AttrCellDiagonalStyle struct{ up, down int }
        AttrCellWrapText      struct{ wrapText bool }
)

func (AttrCellContent) Set(val any) CellAttributer <span class="cov8" title="1">{ return AttrCellContent{val} }</span>
func (my AttrCellContent) Register(cell *Cell)     <span class="cov8" title="1">{ cell.content = my.content }</span>

func (AttrCellContentType) Set(val CellContentType) CellAttributer <span class="cov8" title="1">{ return AttrCellContentType{val} }</span>
func (my AttrCellContentType) Register(cell *Cell)                 <span class="cov8" title="1">{ cell.contentType = my.contentType }</span>

func (AttrCellCoordinate) Set(val string) CellAttributer <span class="cov8" title="1">{ return AttrCellCoordinate{val} }</span>
func (my AttrCellCoordinate) Register(cell *Cell)        <span class="cov8" title="1">{ cell.coordinate = my.coordinate }</span>

func (AttrCellFontRGB) Set(val string) CellAttributer <span class="cov8" title="1">{ return AttrCellFontRGB{val} }</span>
func (my AttrCellFontRGB) Register(cell *Cell)        <span class="cov8" title="1">{ cell.fontRGB = my.rgb }</span>

func (AttrCellPatternRGB) Set(val string) CellAttributer <span class="cov8" title="1">{ return AttrCellPatternRGB{val} }</span>
func (my AttrCellPatternRGB) Register(cell *Cell)        <span class="cov8" title="1">{ cell.patternRGB = my.rgb }</span>

func (AttrCellFontBold) Set(val bool) CellAttributer <span class="cov0" title="0">{ return AttrCellFontBold{val} }</span>
func (AttrCellFontBold) SetTrue() CellAttributer     <span class="cov8" title="1">{ return AttrCellFontBold{true} }</span>
func (AttrCellFontBold) SetFalse() CellAttributer    <span class="cov0" title="0">{ return AttrCellFontBold{false} }</span>
func (my AttrCellFontBold) Register(cell *Cell)      <span class="cov8" title="1">{ cell.fontBold = my.fontBold }</span>

func (AttrCellFontItalic) Set(val bool) CellAttributer <span class="cov0" title="0">{ return AttrCellFontItalic{val} }</span>
func (AttrCellFontItalic) SetTrue() CellAttributer     <span class="cov0" title="0">{ return AttrCellFontItalic{true} }</span>
func (AttrCellFontItalic) SetFalse() CellAttributer    <span class="cov8" title="1">{ return AttrCellFontItalic{false} }</span>
func (my AttrCellFontItalic) Register(cell *Cell)      <span class="cov8" title="1">{ cell.fontItalic = my.fontItalic }</span>

func (AttrCellFontSize) Set(val float64) CellAttributer <span class="cov8" title="1">{ return AttrCellFontSize{val} }</span>
func (my AttrCellFontSize) Register(cell *Cell)         <span class="cov8" title="1">{ cell.fontSize = my.fontSize }</span>

func (AttrCellBorderRGB) Set(top, bottom, left, right string) CellAttributer <span class="cov8" title="1">{
        return AttrCellBorderRGB{top, bottom, left, right}
}</span>
func (my AttrCellBorderRGB) Register(cell *Cell) <span class="cov8" title="1">{
        cell.borderTopRGB = my.top
        cell.borderBottomRGB = my.bottom
        cell.borderLeftRGB = my.left
        cell.borderRightRGB = my.right
}</span>

func (AttrCellBorderStyle) Set(top, bottom, left, right int) CellAttributer <span class="cov8" title="1">{
        return AttrCellBorderStyle{top, bottom, left, right}
}</span>
func (my AttrCellBorderStyle) Register(cell *Cell) <span class="cov8" title="1">{
        cell.borderTopStyle = my.top
        cell.borderBottomStyle = my.bottom
        cell.borderLeftStyle = my.left
        cell.borderRightStyle = my.right
}</span>

func (AttrCellDiagonalRGB) Set(up, down string) CellAttributer <span class="cov8" title="1">{ return AttrCellDiagonalRGB{up, down} }</span>
func (my AttrCellDiagonalRGB) Register(cell *Cell) <span class="cov8" title="1">{
        cell.borderDiagonalUpRGB = my.up
        cell.borderDiagonalDownRGB = my.down
}</span>

func (AttrCellDiagonalStyle) Set(up, down int) CellAttributer <span class="cov8" title="1">{ return AttrCellDiagonalStyle{up, down} }</span>
func (my AttrCellDiagonalStyle) Register(cell *Cell) <span class="cov8" title="1">{
        cell.borderDiagonalUpStyle = my.up
        cell.borderDiagonalDownStyle = my.down
}</span>

func (AttrCellWrapText) Set(val bool) CellAttributer <span class="cov0" title="0">{ return AttrCellWrapText{val} }</span>
func (AttrCellWrapText) SetTrue() CellAttributer     <span class="cov8" title="1">{ return AttrCellWrapText{true} }</span>
func (AttrCellWrapText) SetFalse() CellAttributer    <span class="cov0" title="0">{ return AttrCellWrapText{false} }</span>
func (my AttrCellWrapText) Register(cell *Cell)      <span class="cov8" title="1">{ cell.wrapText = my.wrapText }</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package excelV2

import (
        "sync"

        "github.com/aid297/aid/array/anyArrayV2"
)

type (
        Cell struct {
                lock                                                                                                                 sync.RWMutex
                content                                                                                                              any
                contentType                                                                                                          CellContentType
                coordinate, fontRGB, patternRGB                                                                                      string
                fontBold, fontItalic                                                                                                 bool
                fontFamily                                                                                                           string
                fontSize                                                                                                             float64
                borderTopRGB, borderBottomRGB, borderLeftRGB, borderRightRGB, borderDiagonalUpRGB, borderDiagonalDownRGB             string
                borderTopStyle, borderBottomStyle, borderLeftStyle, borderRightStyle, borderDiagonalUpStyle, borderDiagonalDownStyle int
                wrapText                                                                                                             bool
        }

        // border 单元格边框
        border struct {
                Type  string
                RGB   string
                Style int
        }
)

const (
        CellContentTypeAny     CellContentType = "any"
        CellContentTypeFormula CellContentType = "formula"
        CellContentTypeInt     CellContentType = "int"
        CellContentTypeFloat   CellContentType = "float64"
        CellContentTypeBool    CellContentType = "bool"
        CellContentTypeTime    CellContentType = "time"
)

func (*Cell) New(attrs ...CellAttributer) *Cell <span class="cov8" title="1">{
        return (&amp;Cell{lock: sync.RWMutex{}, contentType: CellContentTypeAny}).setAttrs(attrs...)
}</span>

func (*Cell) NewAny(content any, attrs ...CellAttributer) *Cell <span class="cov0" title="0">{
        return APP.Cell.New(APP.CellAttr.Content.Set(content), APP.CellAttr.ContentType.Set(CellContentTypeAny)).setAttrs(attrs...)
}</span>

func (*Cell) NewFormula(content any, attrs ...CellAttributer) *Cell <span class="cov0" title="0">{
        return APP.Cell.New(APP.CellAttr.Content.Set(content), APP.CellAttr.ContentType.Set(CellContentTypeFormula)).setAttrs(attrs...)
}</span>

func (*Cell) NewInt(content any, attrs ...CellAttributer) *Cell <span class="cov0" title="0">{
        return APP.Cell.New(APP.CellAttr.Content.Set(content), APP.CellAttr.ContentType.Set(CellContentTypeInt)).setAttrs(attrs...)
}</span>

func (*Cell) NewFloat(content any, attrs ...CellAttributer) *Cell <span class="cov0" title="0">{
        return APP.Cell.New(APP.CellAttr.Content.Set(content), APP.CellAttr.ContentType.Set(CellContentTypeFloat)).setAttrs(attrs...)
}</span>

func (*Cell) NewBool(content any, attrs ...CellAttributer) *Cell <span class="cov0" title="0">{
        return APP.Cell.New(APP.CellAttr.Content.Set(content), APP.CellAttr.ContentType.Set(CellContentTypeBool)).setAttrs(attrs...)
}</span>

func (*Cell) NewTime(content any, attrs ...CellAttributer) *Cell <span class="cov0" title="0">{
        return APP.Cell.New(APP.CellAttr.Content.Set(content), APP.CellAttr.ContentType.Set(CellContentTypeTime)).setAttrs(attrs...)
}</span>

func (my *Cell) setAttrs(attrs ...CellAttributer) *Cell <span class="cov8" title="1">{
        for idx := range attrs </span><span class="cov8" title="1">{
                attrs[idx].Register(my)
        }</span>
        <span class="cov8" title="1">return my</span>
}
func (my *Cell) SetAttrs(attrs ...CellAttributer) *Cell <span class="cov0" title="0">{
        my.lock.Lock()
        defer my.lock.Unlock()
        return my.setAttrs(attrs...)
}</span>

func (my *Cell) getContent() any <span class="cov8" title="1">{ return my.content }</span>
func (my *Cell) GetContent() any <span class="cov8" title="1">{
        my.lock.RLock()
        defer my.lock.RUnlock()
        return my.getContent()
}</span>
func (my *Cell) getContentType() CellContentType <span class="cov8" title="1">{ return my.contentType }</span>
func (my *Cell) GetContentType() CellContentType <span class="cov8" title="1">{
        my.lock.RLock()
        defer my.lock.RUnlock()
        return my.getContentType()
}</span>
func (my *Cell) getCoordinate() string <span class="cov8" title="1">{ return my.coordinate }</span>
func (my *Cell) GetCoordinate() string <span class="cov8" title="1">{
        my.lock.RLock()
        defer my.lock.RUnlock()
        return my.getCoordinate()
}</span>
func (my *Cell) getFontRGB() string <span class="cov8" title="1">{ return my.fontRGB }</span>
func (my *Cell) GetFontRGB() string <span class="cov8" title="1">{
        my.lock.RLock()
        defer my.lock.RUnlock()
        return my.getFontRGB()
}</span>
func (my *Cell) getPatternRGB() string <span class="cov8" title="1">{ return my.patternRGB }</span>
func (my *Cell) GetPatternRGB() string <span class="cov8" title="1">{
        my.lock.RLock()
        defer my.lock.RUnlock()
        return my.getPatternRGB()
}</span>
func (my *Cell) getFontBold() bool <span class="cov8" title="1">{ return my.fontBold }</span>
func (my *Cell) GetFontBold() bool <span class="cov8" title="1">{
        my.lock.RLock()
        defer my.lock.RUnlock()
        return my.getFontBold()
}</span>
func (my *Cell) getFontItalic() bool <span class="cov8" title="1">{ return my.fontItalic }</span>
func (my *Cell) GetFontItalic() bool <span class="cov8" title="1">{
        my.lock.RLock()
        defer my.lock.RUnlock()
        return my.getFontItalic()
}</span>
func (my *Cell) getFontFamily() string <span class="cov8" title="1">{ return my.fontFamily }</span>
func (my *Cell) GetFontFamily() string <span class="cov8" title="1">{
        my.lock.RLock()
        defer my.lock.RUnlock()
        return my.getFontFamily()
}</span>
func (my *Cell) getFontSize() float64 <span class="cov8" title="1">{ return my.fontSize }</span>
func (my *Cell) GetFontSize() float64 <span class="cov8" title="1">{
        my.lock.RLock()
        defer my.lock.RUnlock()
        return my.getFontSize()
}</span>
func (my *Cell) getBorder() anyArrayV2.AnyArray[border] <span class="cov8" title="1">{
        borders := anyArrayV2.New[border]()

        if my.borderTopRGB != "" </span><span class="cov0" title="0">{
                borders = borders.Append(border{Type: "top", RGB: my.borderTopRGB, Style: my.borderTopStyle})
        }</span>

        <span class="cov8" title="1">if my.borderBottomRGB != "" </span><span class="cov0" title="0">{
                borders = borders.Append(border{Type: "bottom", RGB: my.borderBottomRGB, Style: my.borderBottomStyle})
        }</span>

        <span class="cov8" title="1">if my.borderLeftRGB != "" </span><span class="cov0" title="0">{
                borders = borders.Append(border{Type: "left", RGB: my.borderLeftRGB, Style: my.borderLeftStyle})
        }</span>

        <span class="cov8" title="1">if my.borderRightRGB != "" </span><span class="cov0" title="0">{
                borders = borders.Append(border{Type: "right", RGB: my.borderRightRGB, Style: my.borderRightStyle})
        }</span>

        <span class="cov8" title="1">if my.borderDiagonalUpRGB != "" </span><span class="cov0" title="0">{
                borders = borders.Append(border{Type: "diagonalUp", RGB: my.borderDiagonalUpRGB, Style: my.borderDiagonalUpStyle})
        }</span>

        <span class="cov8" title="1">if my.borderDiagonalDownRGB != "" </span><span class="cov0" title="0">{
                borders = borders.Append(border{Type: "diagonalDown", RGB: my.borderDiagonalDownRGB, Style: my.borderDiagonalDownStyle})
        }</span>

        <span class="cov8" title="1">return borders</span>
}
func (my *Cell) GetBorder() anyArrayV2.AnyArray[border] <span class="cov8" title="1">{
        my.lock.RLock()
        defer my.lock.RUnlock()
        return my.getBorder()
}</span>
func (my *Cell) getWrapText() bool <span class="cov8" title="1">{ return my.wrapText }</span>
func (my *Cell) GetWrapText() bool <span class="cov8" title="1">{
        my.lock.RLock()
        defer my.lock.RUnlock()
        return my.getWrapText()
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package excelV2

type (
        ReaderAttributer interface{ Register(reader *Reader) }

        AttrReaderFilename    struct{ filename string }
        AttrReaderSheetName   struct{ sheetName string }
        AttrReaderOriginalRow struct{ originalRow uint }
        AttrReaderFinishedRow struct{ finishedRow uint }
        AttrReaderOriginalCol struct{ originalCol uint }
        AttrReaderFinishedCol struct{ finishedCol uint }
)

func (AttrReaderFilename) Set(val string) ReaderAttributer <span class="cov0" title="0">{ return AttrReaderFilename{val} }</span>
func (my AttrReaderFilename) Register(reader *Reader)      <span class="cov0" title="0">{ reader.filename = my.filename }</span>

func (AttrReaderSheetName) Set(val string) ReaderAttributer <span class="cov0" title="0">{ return AttrReaderSheetName{val} }</span>
func (my AttrReaderSheetName) Register(reader *Reader)      <span class="cov0" title="0">{ reader.sheetName = my.sheetName }</span>

func (AttrReaderOriginalRow) Set(val uint) ReaderAttributer <span class="cov0" title="0">{ return AttrReaderOriginalRow{val} }</span>
func (my AttrReaderOriginalRow) Register(reader *Reader)    <span class="cov0" title="0">{ reader.originalRow = my.originalRow }</span>

func (AttrReaderFinishedRow) Set(val uint) ReaderAttributer <span class="cov0" title="0">{ return AttrReaderFinishedRow{val} }</span>
func (my AttrReaderFinishedRow) Register(reader *Reader)    <span class="cov0" title="0">{ reader.finishedRow = my.finishedRow }</span>

func (AttrReaderOriginalCol) Set(val uint) ReaderAttributer <span class="cov0" title="0">{ return AttrReaderOriginalCol{val} }</span>
func (my AttrReaderOriginalCol) Register(reader *Reader) <span class="cov0" title="0">{
        reader.originalColNo = my.originalCol
        reader.originalColTxt, reader.Error = ColumnNumberToText(int(my.originalCol))
}</span>

func (AttrReaderFinishedCol) Set(val uint) ReaderAttributer <span class="cov0" title="0">{ return AttrReaderFinishedCol{val} }</span>
func (my AttrReaderFinishedCol) Register(reader *Reader) <span class="cov0" title="0">{
        reader.finishedColNo = my.finishedCol
        reader.finishedColTxt, reader.Error = ColumnNumberToText(int(my.finishedCol))
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package excelV2

import (
        "fmt"
        "reflect"
        "strconv"
        "strings"
        "sync"

        "github.com/xuri/excelize/v2"
)

type (
        Reader struct {
                Error          error
                lock           sync.RWMutex
                rawFile        *excelize.File
                filename       string
                sheetName      string
                originalRow    uint
                finishedRow    uint
                originalColNo  uint
                originalColTxt string
                finishedColNo  uint
                finishedColTxt string
                originalData   [][]string
                dataMap        map[string]string
                dataMaps       []map[string]string
        }
)

func (*Reader) New(attrs ...ReaderAttributer) *Reader <span class="cov8" title="1">{
        return (&amp;Reader{lock: sync.RWMutex{}, sheetName: "Sheet 1", originalRow: 1, originalColNo: 1, originalData: make([][]string, 0), dataMap: make(map[string]string), dataMaps: make([]map[string]string, 0)}).setAttrs(attrs...)
}</span>

func (my *Reader) setAttrs(attrs ...ReaderAttributer) *Reader <span class="cov8" title="1">{
        for i := range attrs </span><span class="cov0" title="0">{
                attrs[i].Register(my)
        }</span>
        <span class="cov8" title="1">return my</span>
}

func (my *Reader) SetAttrs(attrs ...ReaderAttributer) *Reader <span class="cov0" title="0">{
        my.lock.Lock()
        defer my.lock.Unlock()
        return my.setAttrs(attrs...)
}</span>

func (my *Reader) read() *Reader <span class="cov0" title="0">{
        var (
                err  error
                rows = make([][]string, 0)
        )

        if my.filename == "" </span><span class="cov0" title="0">{
                my.Error = ErrFilenameRequired
                return my
        }</span>

        <span class="cov0" title="0">if my.sheetName == "" </span><span class="cov0" title="0">{
                my.Error = ErrSheetNameRequired
                return my
        }</span>

        <span class="cov0" title="0">if my.rawFile, err = excelize.OpenFile(fmt.Sprintf(my.filename)); err != nil </span><span class="cov0" title="0">{
                my.Error = fmt.Errorf("%w：%w", ErrOpen, err)
                return my
        }</span>

        <span class="cov0" title="0">defer func(r *Reader) </span><span class="cov0" title="0">{
                if err = r.rawFile.Close(); err != nil </span><span class="cov0" title="0">{
                        r.Error = fmt.Errorf("%w：%w", ErrClose, err)
                }</span>
        }(my)

        <span class="cov0" title="0">if rows, err = my.rawFile.GetRows(my.sheetName); err != nil </span><span class="cov0" title="0">{
                my.Error = fmt.Errorf("%w：%w", ErrRead, err)
                return my
        }</span>

        <span class="cov0" title="0">if len(rows) &gt; 0 </span><span class="cov0" title="0">{
                if my.finishedRow == 0 </span><span class="cov0" title="0">{
                        for rowNo := range rows[my.originalRow:] </span><span class="cov0" title="0">{
                                if my.finishedColNo == 0 </span><span class="cov0" title="0">{
                                        my.originalData[rowNo] = rows[rowNo][my.originalColNo:]
                                }</span> else<span class="cov0" title="0"> {
                                        my.originalData[rowNo] = rows[rowNo][my.originalColNo:my.finishedColNo]
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        for rowNo := range rows[my.originalRow:my.finishedRow] </span><span class="cov0" title="0">{
                                if my.finishedColNo == 0 </span><span class="cov0" title="0">{
                                        my.originalData[rowNo] = rows[rowNo][my.originalColNo:]
                                }</span> else<span class="cov0" title="0"> {
                                        my.originalData[rowNo] = rows[rowNo][my.originalColNo:my.finishedColNo]
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return my</span>
}

func (my *Reader) getOriginalData() [][]string <span class="cov8" title="1">{
        if len(my.originalData) == 0 &amp;&amp; my.Error == nil </span><span class="cov0" title="0">{
                my.read()
        }</span>

        <span class="cov8" title="1">return my.originalData</span>
}

func (my *Reader) GetOriginalData() [][]string <span class="cov0" title="0">{
        my.lock.Lock()
        defer my.lock.Unlock()
        return my.getOriginalData()
}</span>

func (my *Reader) GetMaps() []map[string]string <span class="cov0" title="0">{
        my.lock.Lock()
        defer my.lock.Unlock()

        my.getOriginalData()

        for row := range my.originalData </span><span class="cov0" title="0">{
                my.dataMaps[row] = make(map[string]string)
                for col := range my.originalData[row] </span><span class="cov0" title="0">{
                        var colTxt string
                        if colTxt, my.Error = ColumnNumberToText(col); my.Error != nil </span><span class="cov0" title="0">{
                                my.Error = fmt.Errorf("%w：行 %d 列索引 %d 转换为列名称错误", ErrColumnNumber, row+1, col+1)
                                return nil
                        }</span>

                        <span class="cov0" title="0">my.dataMaps[row][colTxt] = my.originalData[row][col]</span>
                }
        }

        <span class="cov0" title="0">return my.dataMaps</span>
}

func (my *Reader) GetMap() map[string]string <span class="cov0" title="0">{
        my.lock.Lock()
        defer my.lock.Unlock()

        my.getOriginalData()

        for row := range my.originalData </span><span class="cov0" title="0">{
                for col := range my.originalData[row] </span><span class="cov0" title="0">{
                        var colTxt string
                        if colTxt, my.Error = ColumnNumberToText(col); my.Error != nil </span><span class="cov0" title="0">{
                                my.Error = fmt.Errorf("%w：行 %d 列索引 %d 转换为列名称错误", ErrColumnNumber, row+1, col+1)
                                return nil
                        }</span>

                        <span class="cov0" title="0">my.dataMap[fmt.Sprintf("%s%d", colTxt, row)] = my.originalData[row][col]</span>
                }
        }

        <span class="cov0" title="0">return my.dataMap</span>
}

func (my *Reader) ToStruct(title []string, ret any) <span class="cov8" title="1">{
        my.lock.Lock()
        defer my.lock.Unlock()

        // 确保已读取原始数据
        my.getOriginalData()
        if my.Error != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if ret == nil </span><span class="cov0" title="0">{
                my.Error = fmt.Errorf("ret 不能为空")
                return
        }</span>

        <span class="cov8" title="1">rv := reflect.ValueOf(ret)
        if rv.Kind() != reflect.Ptr </span><span class="cov0" title="0">{
                my.Error = fmt.Errorf("ret 必须是指向切片的指针")
                return
        }</span>

        <span class="cov8" title="1">sliceVal := rv.Elem()
        if sliceVal.Kind() != reflect.Slice </span><span class="cov0" title="0">{
                my.Error = fmt.Errorf("ret 必须是指向切片的指针")
                return
        }</span>

        <span class="cov8" title="1">elemType := sliceVal.Type().Elem()
        isElemPtr := false
        structType := elemType
        if elemType.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                isElemPtr = true
                structType = elemType.Elem()
        }</span>

        <span class="cov8" title="1">if structType.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                my.Error = fmt.Errorf("切片元素类型必须是结构体或结构体指针")
                return
        }</span>

        // 构建字段名映射（小写），支持字段名和 `json` tag
        <span class="cov8" title="1">fieldIndex := make(map[string]int)
        for i := 0; i &lt; structType.NumField(); i++ </span><span class="cov8" title="1">{
                f := structType.Field(i)
                // 跳过未导出字段
                if f.PkgPath != "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // 优先使用 `excel` tag，其次 `json` tag，最后字段名
                // 支持 tag 值为 "-" 表示忽略该字段
                <span class="cov8" title="1">added := false

                if etag := f.Tag.Get("excel"); etag != "" </span><span class="cov8" title="1">{
                        if etag == "-" </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">parts := strings.Split(etag, ",")
                        if parts[0] != "" </span><span class="cov8" title="1">{
                                fieldIndex[strings.ToLower(parts[0])] = i
                                added = true
                        }</span>
                }

                // 无论是否存在 excel tag，都尝试注册 json tag（允许同时使用两种 tag）
                <span class="cov8" title="1">if jtag := f.Tag.Get("json"); jtag != "" </span><span class="cov8" title="1">{
                        if jtag == "-" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">parts := strings.Split(jtag, ",")
                        if parts[0] != "" </span><span class="cov8" title="1">{
                                fieldIndex[strings.ToLower(parts[0])] = i
                                added = true
                        }</span>
                }

                <span class="cov8" title="1">if !added </span><span class="cov8" title="1">{
                        name := strings.ToLower(f.Name)
                        fieldIndex[name] = i
                }</span>
        }

        // 遍历每一行并进行转换
        <span class="cov8" title="1">for rowIdx := range my.originalData </span><span class="cov8" title="1">{
                row := my.originalData[rowIdx]

                // 创建元素实例（总是先创建指针，然后根据需要 append 值或指针）
                newPtr := reflect.New(structType) // *T
                structVal := newPtr.Elem()

                for colIdx, colName := range title </span><span class="cov8" title="1">{
                        if colIdx &gt;= len(row) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">raw := row[colIdx]
                        key := strings.ToLower(strings.TrimSpace(colName))
                        if key == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">fi, ok := fieldIndex[key]
                        if !ok </span><span class="cov8" title="1">{
                                // 未找到字段，跳过
                                continue</span>
                        }

                        <span class="cov8" title="1">f := structVal.Field(fi)
                        if !f.CanSet() </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // 处理指针字段
                        <span class="cov8" title="1">targetType := f.Type()
                        isPtrField := false
                        if targetType.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                                isPtrField = true
                                targetType = targetType.Elem()
                        }</span>

                        // 转换字符串到目标类型
                        <span class="cov8" title="1">converted, err := convertStringToReflectValue(raw, targetType)
                        if err != nil </span><span class="cov8" title="1">{
                                my.Error = fmt.Errorf("第 %d 行列 %s 转换失败：%w", rowIdx+1, colName, err)
                                return
                        }</span>

                        <span class="cov8" title="1">if isPtrField </span><span class="cov8" title="1">{
                                ptr := reflect.New(targetType)
                                ptr.Elem().Set(converted)
                                f.Set(ptr)
                        }</span> else<span class="cov8" title="1"> {
                                f.Set(converted)
                        }</span>
                }

                // append 到切片
                <span class="cov8" title="1">if isElemPtr </span><span class="cov8" title="1">{
                        sliceVal.Set(reflect.Append(sliceVal, newPtr))
                }</span> else<span class="cov8" title="1"> {
                        sliceVal.Set(reflect.Append(sliceVal, newPtr.Elem()))
                }</span>
        }
}

// convertStringToReflectValue 将字符串转换为给定的 reflect.Kind 的值(非指针)
func convertStringToReflectValue(s string, t reflect.Type) (reflect.Value, error) <span class="cov8" title="1">{
        // 空字符串返回零值
        if s == "" </span><span class="cov8" title="1">{
                return reflect.Zero(t), nil
        }</span>

        <span class="cov8" title="1">switch t.Kind() </span>{
        case reflect.String:<span class="cov8" title="1">
                return reflect.ValueOf(s).Convert(t), nil</span>
        case reflect.Bool:<span class="cov8" title="1">
                b, err := strconv.ParseBool(s)
                if err != nil </span><span class="cov0" title="0">{
                        return reflect.Value{}, err
                }</span>
                <span class="cov8" title="1">return reflect.ValueOf(b).Convert(t), nil</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                i, err := strconv.ParseInt(s, 10, t.Bits())
                if err != nil </span><span class="cov8" title="1">{
                        return reflect.Value{}, err
                }</span>
                <span class="cov8" title="1">return reflect.ValueOf(i).Convert(t), nil</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:<span class="cov0" title="0">
                u, err := strconv.ParseUint(s, 10, t.Bits())
                if err != nil </span><span class="cov0" title="0">{
                        return reflect.Value{}, err
                }</span>
                <span class="cov0" title="0">return reflect.ValueOf(u).Convert(t), nil</span>
        case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                f, err := strconv.ParseFloat(s, t.Bits())
                if err != nil </span><span class="cov0" title="0">{
                        return reflect.Value{}, err
                }</span>
                <span class="cov0" title="0">return reflect.ValueOf(f).Convert(t), nil</span>
        case reflect.Struct:<span class="cov0" title="0">
                // 支持 time.Time? 如果需要可以扩展
                return reflect.Zero(t), fmt.Errorf("不支持将字符串直接转换为 struct 类型 (%s)", t.String())</span>
        default:<span class="cov8" title="1">
                return reflect.Zero(t), fmt.Errorf("不支持的目标类型: %s", t.Kind().String())</span>
        }
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package excelV2

type (
        RowAttributer interface{ Register(row *Row) }

        AttrCells  struct{ cells []*Cell }
        AttrNumber struct{ number uint64 }
)

func (AttrCells) Set(cells ...*Cell) RowAttributer <span class="cov0" title="0">{ return AttrCells{cells: cells} }</span>
func (my AttrCells) Register(row *Row)             <span class="cov0" title="0">{ row.cells = my.cells }</span>

func (AttrNumber) Set(number uint64) RowAttributer <span class="cov0" title="0">{ return AttrNumber{number: number} }</span>
func (my AttrNumber) Register(row *Row)            <span class="cov0" title="0">{ row.number = my.number }</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package excelV2

import "sync"

type Row struct {
        lock   sync.RWMutex
        cells  []*Cell
        number uint64
}

func (*Row) New(attrs ...RowAttributer) *Row <span class="cov0" title="0">{
        return (&amp;Row{lock: sync.RWMutex{}}).setAttrs(attrs...)
}</span>

func (my *Row) setAttrs(attrs ...RowAttributer) *Row <span class="cov0" title="0">{
        for i := range attrs </span><span class="cov0" title="0">{
                attrs[i].Register(my)
        }</span>

        <span class="cov0" title="0">return my</span>
}

func (my *Row) SetAttrs(attrs ...RowAttributer) *Row <span class="cov0" title="0">{
        my.lock.Lock()
        defer my.lock.Unlock()
        return my.setAttrs(attrs...)
}</span>

func (my *Row) getCells() []*Cell <span class="cov0" title="0">{ return my.cells }</span>
func (my *Row) GetCells() []*Cell <span class="cov0" title="0">{
        my.lock.RLock()
        defer my.lock.RUnlock()
        return my.getCells()
}</span>

func (my *Row) getNumber() uint64 <span class="cov0" title="0">{ return my.number }</span>
func (my *Row) GetNumber() uint64 <span class="cov0" title="0">{
        my.lock.RLock()
        defer my.lock.RUnlock()
        return my.getNumber()
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package excelV2

import (
        "github.com/xuri/excelize/v2"
)

// ColumnNumberToText 列索引转文字
func ColumnNumberToText(columnNumber int) (string, error) <span class="cov8" title="1">{
        return excelize.ColumnNumberToName(columnNumber)
}</span>

// ColumnTextToNumber 列文字转索引
func ColumnTextToNumber(columnText string) int <span class="cov0" title="0">{
        result := 0
        for i, char := range columnText </span><span class="cov0" title="0">{
                result += (int(char - 'A' + 1)) * pow(26, len(columnText)-i-1)
        }</span>

        <span class="cov0" title="0">return result</span>
}

// pow 是一个简单的幂函数计算，用于26进制转换
func pow(base, exponent int) int <span class="cov0" title="0">{
        result := 1
        for range exponent </span><span class="cov0" title="0">{
                result *= base
        }</span>

        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package excelV2

import (
        "fmt"

        "github.com/aid297/aid/operation/operationV2"
)

type (
        WriterAttributer interface{ Register(writer *Writer) }

        AttrWriterFilename  struct{ filename string }
        AttrWriterSheetName struct{ sheetName string }
        AttrWriterCells     struct{ cells []*Cell }
        AttrWriterRows      struct {
                rows     []*Row
                offset   int
                isOffset bool
        }
)

func (AttrWriterSheetName) Set(val string) WriterAttributer <span class="cov8" title="1">{ return AttrWriterSheetName{val} }</span>
func (my AttrWriterSheetName) Register(writer *Writer)      <span class="cov8" title="1">{ writer.sheetName = my.sheetName }</span>

func (AttrWriterFilename) Set(val string) WriterAttributer <span class="cov0" title="0">{ return AttrWriterFilename{val} }</span>
func (my AttrWriterFilename) Register(writer *Writer)      <span class="cov0" title="0">{ writer.filename = my.filename }</span>

func (AttrWriterCells) Set(vals ...*Cell) WriterAttributer <span class="cov0" title="0">{ return AttrWriterCells{vals} }</span>
func (my AttrWriterCells) Register(writer *Writer) <span class="cov0" title="0">{
        for _, cell := range my.cells </span><span class="cov0" title="0">{
                writer.setCell(cell)
        }</span>
}

func (AttrWriterRows) Set(vals ...*Row) WriterAttributer <span class="cov0" title="0">{ return AttrWriterRows{rows: vals} }</span>
func (AttrWriterRows) Append(offset int, vals ...*Row) WriterAttributer <span class="cov0" title="0">{
        return AttrWriterRows{rows: vals, offset: offset, isOffset: true}
}</span>
func (my AttrWriterRows) Register(writer *Writer) <span class="cov0" title="0">{
        for rn, row := range my.rows </span><span class="cov0" title="0">{
                rn = operationV2.NewTernary(operationV2.TrueValue(rn+my.offset-1), operationV2.FalseValue(rn)).GetByValue(my.isOffset)
                rn = operationV2.NewTernary(operationV2.TrueValue(int(row.getNumber())), operationV2.FalseValue(rn)).GetByValue(row.getNumber() &gt; 0)
                for cn, cell := range row.cells </span><span class="cov0" title="0">{
                        if cell.getCoordinate() != "" </span><span class="cov0" title="0">{
                                writer.setCell(cell)
                        }</span> else<span class="cov0" title="0"> {
                                writeCell(cell, rn, cn, writer)
                        }</span>
                }
        }
}

func writeCell(cell *Cell, rn, cn int, writer *Writer) <span class="cov8" title="1">{
        var (
                err error
                col string
        )

        if col, err = ColumnNumberToText(cn + 1); err != nil </span><span class="cov0" title="0">{
                writer.Error = fmt.Errorf("%w：行 %d 列索引 %d 转换为列名称错误", ErrColumnNumber, rn+1, cn+1)
                return
        }</span>

        <span class="cov8" title="1">writer.setCell(cell.setAttrs(APP.CellAttr.Coordinate.Set(fmt.Sprintf("%s%d", col, rn+1))))</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package excelV2

import (
        "fmt"
        "net/http"
        "net/url"
        "reflect"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/spf13/cast"
        "github.com/xuri/excelize/v2"

        "github.com/aid297/aid/str"
)

type Writer struct {
        Error      error
        lock       sync.RWMutex
        rawFile    *excelize.File
        filename   string
        sheetName  string
        isSheetSet bool
}

func (*Writer) New(attrs ...WriterAttributer) *Writer <span class="cov8" title="1">{
        return (&amp;Writer{lock: sync.RWMutex{}, rawFile: excelize.NewFile()}).setAttrs(attrs...)
}</span>

func (my *Writer) setAttrs(attrs ...WriterAttributer) *Writer <span class="cov8" title="1">{
        for i := range attrs </span><span class="cov8" title="1">{
                attrs[i].Register(my)
        }</span>
        <span class="cov8" title="1">return my</span>
}

func (my *Writer) SetAttrs(attrs ...WriterAttributer) *Writer <span class="cov0" title="0">{
        my.lock.Lock()
        defer my.lock.Unlock()
        return my.setAttrs(attrs...)
}</span>

func (my *Writer) getFilename() string <span class="cov0" title="0">{ return my.filename }</span>
func (my *Writer) GetFilename() string <span class="cov0" title="0">{
        my.lock.RLock()
        defer my.lock.RUnlock()
        return my.getFilename()
}</span>
func (my *Writer) getSheetName() string <span class="cov0" title="0">{ return my.sheetName }</span>
func (my *Writer) GetSheetName() string <span class="cov0" title="0">{
        my.lock.RLock()
        defer my.lock.RUnlock()
        return my.getSheetName()
}</span>

// setCell 设置 cells 值和格式
func (my *Writer) setCell(cell *Cell) *Writer <span class="cov8" title="1">{
        return my.setSheet().setCellValue(cell).setCellStyle(cell)
}</span>

// setCellValue 设置 cells 值
func (my *Writer) setCellValue(cell *Cell) *Writer <span class="cov8" title="1">{
        var err error

        switch cell.GetContentType() </span>{
        case CellContentTypeFormula:<span class="cov0" title="0">
                if err = my.rawFile.SetCellFormula(my.sheetName, cell.GetCoordinate(), cast.ToString(cell.GetContent())); err != nil </span><span class="cov0" title="0">{
                        my.Error = fmt.Errorf("%w：%s %s %w", ErrWriteCellFormula, cell.GetCoordinate(), cell.GetContent(), err)
                        return my
                }</span>
        case CellContentTypeInt:<span class="cov8" title="1">
                if err = my.rawFile.SetCellInt(my.sheetName, cell.GetCoordinate(), cast.ToInt(cell.GetContent())); err != nil </span><span class="cov0" title="0">{
                        my.Error = fmt.Errorf("%w：%s %s %w", ErrWriteCellInt, cell.GetCoordinate(), cell.GetContent(), err)
                        return my
                }</span>
        case CellContentTypeFloat:<span class="cov8" title="1">
                if err = my.rawFile.SetCellFloat(my.sheetName, cell.GetCoordinate(), cast.ToFloat64(cell.GetContent()), 2, 64); err != nil </span><span class="cov0" title="0">{
                        my.Error = fmt.Errorf("%w：%s %s %w", ErrWriteCellFloat, cell.GetCoordinate(), cell.GetContent(), err)
                        return my
                }</span>
        case CellContentTypeBool:<span class="cov8" title="1">
                if err = my.rawFile.SetCellBool(my.sheetName, cell.GetCoordinate(), cast.ToBool(cell.GetContent())); err != nil </span><span class="cov0" title="0">{
                        my.Error = fmt.Errorf("%w：%s %s %w", ErrWriteCellBool, cell.GetCoordinate(), cell.GetContent(), err)
                        return my
                }</span>
        case CellContentTypeTime:<span class="cov8" title="1">
                if err = my.rawFile.SetCellValue(my.sheetName, cell.GetCoordinate(), cast.ToTime(cell.GetContent())); err != nil </span><span class="cov0" title="0">{
                        my.Error = fmt.Errorf("%w：%s %s %w", ErrWriteCellTime, cell.GetCoordinate(), cell.GetContent(), err)
                        return my
                }</span>
        default:<span class="cov8" title="1">
                if err = my.rawFile.SetCellValue(my.sheetName, cell.GetCoordinate(), cell.GetContent()); err != nil </span><span class="cov0" title="0">{
                        my.Error = fmt.Errorf("%w：%s %s %w", ErrWriteCellAny, cell.GetCoordinate(), cell.GetContent(), err)
                        return my
                }</span>
        }

        <span class="cov8" title="1">return my</span>
}

// setCellStyle 设置 cells 格式
func (my *Writer) setCellStyle(cell *Cell) *Writer <span class="cov8" title="1">{
        fill := excelize.Fill{Type: "pattern", Pattern: 0, Color: []string{""}}
        if cell.GetPatternRGB() != "" </span><span class="cov0" title="0">{
                fill.Pattern = 1
                fill.Color[0] = cell.GetPatternRGB()
        }</span>

        <span class="cov8" title="1">var borders = make([]excelize.Border, 0)
        if cell.GetBorder().LengthNotEmpty() &gt; 0 </span><span class="cov0" title="0">{
                cell.GetBorder().Each(func(_ int, item border) </span><span class="cov0" title="0">{
                        borders = append(borders, excelize.Border{
                                Type:  item.Type,
                                Color: item.RGB,
                                Style: item.Style,
                        })
                }</span>)
        }

        <span class="cov8" title="1">if style, err := my.rawFile.NewStyle(&amp;excelize.Style{
                Font: &amp;excelize.Font{
                        Bold:   cell.GetFontBold(),
                        Italic: cell.GetFontItalic(),
                        Family: cell.GetFontFamily(),
                        Size:   cell.GetFontSize(),
                        Color:  cell.GetFontRGB(),
                },
                Alignment: &amp;excelize.Alignment{WrapText: cell.GetWrapText()},
                Fill:      fill,
                Border:    borders,
        }); err != nil </span><span class="cov0" title="0">{
                my.Error = fmt.Errorf("%w：%s", ErrSetFont, cell.GetCoordinate())
        }</span> else<span class="cov8" title="1"> {
                my.Error = my.rawFile.SetCellStyle(my.sheetName, cell.GetCoordinate(), cell.GetCoordinate(), style)
        }</span>

        <span class="cov8" title="1">return my</span>
}

func (my *Writer) createSheet(sheetName string) *Writer <span class="cov8" title="1">{
        if sheetName == "" </span><span class="cov0" title="0">{
                my.Error = ErrSheetNameRequired
                return my
        }</span>
        <span class="cov8" title="1">sheetIndex, err := my.rawFile.NewSheet(sheetName)
        if err != nil </span><span class="cov0" title="0">{
                my.Error = fmt.Errorf("%w：%w", ErrCreateSheet, err)
                return my
        }</span>

        <span class="cov8" title="1">my.rawFile.SetActiveSheet(sheetIndex)
        my.sheetName = my.rawFile.GetSheetName(sheetIndex)

        return my</span>
}

// CreateSheet 创建工作表
func (my *Writer) CreateSheet(sheetName string) *Writer <span class="cov0" title="0">{
        my.lock.Lock()
        defer my.lock.Unlock()
        return my.createSheet(sheetName)
}</span>

func (my *Writer) setSheet() *Writer <span class="cov8" title="1">{
        var (
                sheetIndex int
                err        error
        )

        if my.isSheetSet </span><span class="cov8" title="1">{
                return my
        }</span>

        <span class="cov8" title="1">if my.sheetName == "" </span><span class="cov0" title="0">{
                my.Error = ErrSheetNameRequired
                return my
        }</span>

        <span class="cov8" title="1">if sheetIndex, err = my.rawFile.GetSheetIndex(my.sheetName); err != nil </span><span class="cov0" title="0">{
                my.Error = fmt.Errorf("%w：%w %s", ErrSetSheet, err, my.sheetName)
                return my
        }</span>

        <span class="cov8" title="1">if sheetIndex == -1 </span><span class="cov8" title="1">{
                // sheet 不存在，创建sheet
                my.createSheet(my.sheetName)
        }</span> else<span class="cov8" title="1"> {
                // sheet 存在，设置为活动sheet
                my.rawFile.SetActiveSheet(sheetIndex)
        }</span>

        <span class="cov8" title="1">my.isSheetSet = true
        return my</span>
}

// Save 保存文件
func (my *Writer) Save() *Writer <span class="cov0" title="0">{
        var err error

        my.lock.Lock()

        if my.filename == "" </span><span class="cov0" title="0">{
                my.Error = ErrFilenameRequired
                return my
        }</span>

        <span class="cov0" title="0">if err = my.rawFile.SaveAs(my.filename); err != nil </span><span class="cov0" title="0">{
                my.Error = fmt.Errorf("%w：%w", ErrSave, err)
                return my
        }</span>

        <span class="cov0" title="0">my.lock.Unlock()
        return my</span>
}

func (my *Writer) FromStruct(data any, title []string, offset int, attrs ...CellAttributer) *Writer <span class="cov8" title="1">{
        my.lock.Lock()
        defer my.lock.Unlock()
        if defaultOffset := 1; offset &lt;= 0 </span><span class="cov0" title="0">{
                offset = defaultOffset
        }</span>
        <span class="cov8" title="1">if data == nil </span><span class="cov0" title="0">{
                my.Error = fmt.Errorf("data 不能为空")
                return my
        }</span>

        <span class="cov8" title="1">rv := reflect.ValueOf(data)
        if rv.Kind() != reflect.Ptr </span><span class="cov0" title="0">{
                my.Error = fmt.Errorf("data 必须是指向切片的指针")
                return my
        }</span>

        <span class="cov8" title="1">sv := rv.Elem()
        if sv.Kind() != reflect.Slice </span><span class="cov0" title="0">{
                my.Error = fmt.Errorf("data 必须是指向切片的指针")
                return my
        }</span>

        <span class="cov8" title="1">elemType := sv.Type().Elem()
        isElemPtr := false
        structType := elemType
        if elemType.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                isElemPtr = true
                structType = elemType.Elem()
        }</span>

        <span class="cov8" title="1">if structType.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                my.Error = fmt.Errorf("切片元素必须为结构体或结构体指针")
                return my
        }</span>

        // 构建字段映射：优先 excel tag, 然后 json tag, 最后字段名（小写）
        <span class="cov8" title="1">fieldIndex := make(map[string]int)
        for i := 0; i &lt; structType.NumField(); i++ </span><span class="cov8" title="1">{
                f := structType.Field(i)
                if f.PkgPath != "" </span><span class="cov0" title="0">{ // unexported
                        continue</span>
                }
                <span class="cov8" title="1">if et := f.Tag.Get("excel"); et != "" </span><span class="cov8" title="1">{
                        if et == "-" </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">parts := strings.Split(et, ",")
                        if parts[0] != "" </span><span class="cov8" title="1">{
                                fieldIndex[strings.ToLower(parts[0])] = i
                        }</span>
                }
                <span class="cov8" title="1">if jt := f.Tag.Get("json"); jt != "" </span><span class="cov8" title="1">{
                        if jt == "-" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">parts := strings.Split(jt, ",")
                        if parts[0] != "" </span><span class="cov8" title="1">{
                                fieldIndex[strings.ToLower(parts[0])] = i
                        }</span>
                }
                <span class="cov8" title="1">name := strings.ToLower(f.Name)
                fieldIndex[name] = i</span>
        }

        // 写标题（如果提供）
        // writeCell 使用 rn/cn 为 0-based index
        <span class="cov8" title="1">rn := offset - 1
        if len(title) &gt; 0 </span><span class="cov8" title="1">{
                for cn, t := range title </span><span class="cov8" title="1">{
                        cell := APP.Cell.New(APP.CellAttr.Content.Set(t), APP.CellAttr.ContentType.Set(CellContentTypeAny))
                        writeCell(cell, rn, cn, my)
                }</span>
                <span class="cov8" title="1">rn++</span>
        }

        // 遍历切片元素并写入
        <span class="cov8" title="1">for i := 0; i &lt; sv.Len(); i++ </span><span class="cov8" title="1">{
                item := sv.Index(i)
                if isElemPtr </span><span class="cov8" title="1">{
                        if item.IsNil() </span><span class="cov8" title="1">{
                                // skip nil pointer element
                                continue</span>
                        }
                        <span class="cov8" title="1">item = item.Elem()</span>
                }

                // 对于每一列，根据 title 找到字段并写入
                <span class="cov8" title="1">for cn, t := range title </span><span class="cov8" title="1">{
                        key := strings.ToLower(strings.TrimSpace(t))
                        if key == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">fi, ok := fieldIndex[key]
                        if !ok </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">f := item.Field(fi)
                        sf := structType.Field(fi)
                        // 未导出字段或不可设置跳过
                        if !f.IsValid() || !f.CanInterface() </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // prepare per-field attributes from struct tags
                        <span class="cov8" title="1">localAttrs := make([]CellAttributer, 0)
                        if v := strings.TrimSpace(sf.Tag.Get("excel-font-size")); v != "" </span><span class="cov8" title="1">{
                                if fv, err := strconv.ParseFloat(v, 64); err == nil </span><span class="cov8" title="1">{
                                        localAttrs = append(localAttrs, AttrCellFontSize{}.Set(fv))
                                }</span>
                        }
                        <span class="cov8" title="1">if v := strings.TrimSpace(sf.Tag.Get("excel-font-rgb")); v != "" </span><span class="cov8" title="1">{
                                localAttrs = append(localAttrs, AttrCellFontRGB{}.Set(v))
                        }</span>
                        <span class="cov8" title="1">if v := strings.TrimSpace(sf.Tag.Get("excel-pattern-rgb")); v != "" </span><span class="cov8" title="1">{
                                localAttrs = append(localAttrs, AttrCellPatternRGB{}.Set(v))
                        }</span>
                        <span class="cov8" title="1">if v := strings.TrimSpace(sf.Tag.Get("excel-font-bold")); v != "" </span><span class="cov8" title="1">{
                                if b, err := strconv.ParseBool(v); err == nil </span><span class="cov8" title="1">{
                                        if b </span><span class="cov8" title="1">{
                                                localAttrs = append(localAttrs, AttrCellFontBold{}.SetTrue())
                                        }</span> else<span class="cov0" title="0"> {
                                                localAttrs = append(localAttrs, AttrCellFontBold{}.SetFalse())
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">if v := strings.TrimSpace(sf.Tag.Get("excel-font-italic")); v != "" </span><span class="cov8" title="1">{
                                if b, err := strconv.ParseBool(v); err == nil </span><span class="cov8" title="1">{
                                        if b </span><span class="cov0" title="0">{
                                                localAttrs = append(localAttrs, AttrCellFontItalic{}.SetTrue())
                                        }</span> else<span class="cov8" title="1"> {
                                                localAttrs = append(localAttrs, AttrCellFontItalic{}.SetFalse())
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">if v := strings.TrimSpace(sf.Tag.Get("excel-border-rgb")); v != "" </span><span class="cov8" title="1">{
                                parts := strings.Split(v, ",")
                                for len(parts) &lt; 4 </span><span class="cov0" title="0">{
                                        parts = append(parts, "")
                                }</span>
                                <span class="cov8" title="1">localAttrs = append(localAttrs, AttrCellBorderRGB{}.Set(strings.TrimSpace(parts[0]), strings.TrimSpace(parts[1]), strings.TrimSpace(parts[2]), strings.TrimSpace(parts[3])))</span>
                        }
                        <span class="cov8" title="1">if v := strings.TrimSpace(sf.Tag.Get("excel-border-style")); v != "" </span><span class="cov8" title="1">{
                                parts := strings.Split(v, ",")
                                ints := make([]int, 4)
                                for idx := 0; idx &lt; 4 &amp;&amp; idx &lt; len(parts); idx++ </span><span class="cov8" title="1">{
                                        if iv, err := strconv.Atoi(strings.TrimSpace(parts[idx])); err == nil </span><span class="cov8" title="1">{
                                                ints[idx] = iv
                                        }</span>
                                }
                                <span class="cov8" title="1">localAttrs = append(localAttrs, AttrCellBorderStyle{}.Set(ints[0], ints[1], ints[2], ints[3]))</span>
                        }
                        <span class="cov8" title="1">if v := strings.TrimSpace(sf.Tag.Get("excel-diagonal-rgb")); v != "" </span><span class="cov8" title="1">{
                                parts := strings.Split(v, ",")
                                up, down := "", ""
                                if len(parts) &gt; 0 </span><span class="cov8" title="1">{
                                        up = strings.TrimSpace(parts[0])
                                }</span>
                                <span class="cov8" title="1">if len(parts) &gt; 1 </span><span class="cov8" title="1">{
                                        down = strings.TrimSpace(parts[1])
                                }</span>
                                <span class="cov8" title="1">localAttrs = append(localAttrs, AttrCellDiagonalRGB{}.Set(up, down))</span>
                        }
                        <span class="cov8" title="1">if v := strings.TrimSpace(sf.Tag.Get("excel-diagonal-style")); v != "" </span><span class="cov8" title="1">{
                                parts := strings.Split(v, ",")
                                up, down := 0, 0
                                if len(parts) &gt; 0 </span><span class="cov8" title="1">{
                                        if iv, err := strconv.Atoi(strings.TrimSpace(parts[0])); err == nil </span><span class="cov8" title="1">{
                                                up = iv
                                        }</span>
                                }
                                <span class="cov8" title="1">if len(parts) &gt; 1 </span><span class="cov8" title="1">{
                                        if iv, err := strconv.Atoi(strings.TrimSpace(parts[1])); err == nil </span><span class="cov8" title="1">{
                                                down = iv
                                        }</span>
                                }
                                <span class="cov8" title="1">localAttrs = append(localAttrs, AttrCellDiagonalStyle{}.Set(up, down))</span>
                        }
                        <span class="cov8" title="1">if v := strings.TrimSpace(sf.Tag.Get("excel-wrap-text")); v != "" </span><span class="cov8" title="1">{
                                if b, err := strconv.ParseBool(v); err == nil </span><span class="cov8" title="1">{
                                        if b </span><span class="cov8" title="1">{
                                                localAttrs = append(localAttrs, AttrCellWrapText{}.SetTrue())
                                        }</span> else<span class="cov0" title="0"> {
                                                localAttrs = append(localAttrs, AttrCellWrapText{}.SetFalse())
                                        }</span>
                                }
                        }

                        // 处理指针字段
                        <span class="cov8" title="1">if f.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                                if f.IsNil() </span><span class="cov0" title="0">{
                                        // 空指针写空值
                                        merged := make([]CellAttributer, 0, len(attrs)+len(localAttrs))
                                        merged = append(merged, attrs...)
                                        merged = append(merged, localAttrs...)
                                        cell := APP.Cell.New(APP.CellAttr.Content.Set(""), APP.CellAttr.ContentType.Set(CellContentTypeAny)).setAttrs(merged...)
                                        writeCell(cell, rn+i, cn, my)
                                        continue</span>
                                }
                                <span class="cov8" title="1">f = f.Elem()</span>
                        }

                        <span class="cov8" title="1">var content any
                        var ctype CellContentType = CellContentTypeAny

                        switch f.Kind() </span>{
                        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                                content = int(f.Int())
                                ctype = CellContentTypeInt</span>
                        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:<span class="cov0" title="0">
                                content = int(f.Uint())
                                ctype = CellContentTypeInt</span>
                        case reflect.Float32, reflect.Float64:<span class="cov8" title="1">
                                content = f.Float()
                                ctype = CellContentTypeFloat</span>
                        case reflect.Bool:<span class="cov8" title="1">
                                content = f.Bool()
                                ctype = CellContentTypeBool</span>
                        case reflect.String:<span class="cov8" title="1">
                                content = f.String()
                                ctype = CellContentTypeAny</span>
                        case reflect.Struct:<span class="cov8" title="1">
                                // special case: time.Time
                                if f.Type() == reflect.TypeOf(time.Time{}) </span><span class="cov8" title="1">{
                                        content = f.Interface()
                                        ctype = CellContentTypeTime
                                }</span> else<span class="cov0" title="0"> {
                                        // unsupported struct, marshal to string via fmt
                                        content = fmt.Sprintf("%v", f.Interface())
                                        ctype = CellContentTypeAny
                                }</span>
                        default:<span class="cov0" title="0">
                                // fallback to string representation
                                content = fmt.Sprintf("%v", f.Interface())
                                ctype = CellContentTypeAny</span>
                        }

                        <span class="cov8" title="1">cell := APP.Cell.New(APP.CellAttr.Content.Set(content), APP.CellAttr.ContentType.Set(ctype))
                        writeCell(cell, rn+i, cn, my)</span>
                }
        }

        <span class="cov8" title="1">return my</span>
}

// Download 下载文件
func (my *Writer) Download(w http.ResponseWriter) *Writer <span class="cov0" title="0">{
        my.lock.Lock()
        defer my.lock.Unlock()

        w.Header().Set("Content-Type", "application/octet-stream")
        w.Header().Set("Content-Disposition", str.APP.Buffer.JoinString("attachment; filename=%s", url.QueryEscape(my.filename)))
        w.Header().Set("Content-Transfer-Encoding", "binary")
        w.Header().Set("Access-Control-Expose-Headers", "Content-Disposition")

        my.Error = my.rawFile.Write(w)
        return my
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package excel

import (
        "time"

        "github.com/aid297/aid/array"
)

type (
        // CellContentType 单元格内容类型
        CellContentType string

        // Cell Excel单元格
        Cell struct {
                content                                                                                                              any
                contentType                                                                                                          CellContentType
                coordinate, fontRgb, patternRgb                                                                                      string
                fontBold, fontItalic                                                                                                 bool
                fontFamily                                                                                                           string
                fontSize                                                                                                             float64
                borderTopRgb, borderBottomRgb, borderLeftRgb, borderRightRgb, borderDiagonalUpRgb, borderDiagonalDownRgb             string
                borderTopStyle, borderBottomStyle, borderLeftStyle, borderRightStyle, borderDiagonalUpStyle, borderDiagonalDownStyle int
                wrapText                                                                                                             bool
        }

        // border 单元格边框
        border struct {
                Type  string
                Rgb   string
                Style int
        }
)

var CellApp Cell

func (*Cell) NewByAny(content any) *Cell        <span class="cov0" title="0">{ return NewCellAny(content) }</span>
func (*Cell) NewByInt(content any) *Cell        <span class="cov0" title="0">{ return NewCellInt(content) }</span>
func (*Cell) NewByFloat64(content any) *Cell    <span class="cov0" title="0">{ return NewCellFloat64(content) }</span>
func (*Cell) NewByBool(content any) *Cell       <span class="cov0" title="0">{ return NewCellBool(content) }</span>
func (*Cell) NewByTime(content time.Time) *Cell <span class="cov0" title="0">{ return NewCellTime(content) }</span>
func (*Cell) NewByFormula(content string) *Cell <span class="cov0" title="0">{ return NewCellFormula(content) }</span>

const (
        CellContentTypeAny     CellContentType = "any"
        CellContentTypeFormula CellContentType = "formula"
        CellContentTypeInt     CellContentType = "int"
        CellContentTypeFloat64 CellContentType = "float64"
        CellContentTypeBool    CellContentType = "bool"
        CellContentTypeTime    CellContentType = "time"
)

// NewCellAny 实例化：任意值
//
//go:fix 推荐使用：NewByAny方法
func NewCellAny(content any) *Cell <span class="cov0" title="0">{
        return &amp;Cell{content: content, contentType: CellContentTypeAny}
}</span>

// NewCellInt 实例化：整数
//
//go:fix 推荐使用：NewByInt方法
func NewCellInt(content any) *Cell <span class="cov0" title="0">{
        return &amp;Cell{content: content, contentType: CellContentTypeInt}
}</span>

// NewCellFloat64 实例化：浮点
//
//go:fix 推荐使用：NewByFloat64方法
func NewCellFloat64(content any) *Cell <span class="cov0" title="0">{
        return &amp;Cell{content: content, contentType: CellContentTypeFloat64}
}</span>

// NewCellBool 实例化：布尔
//
//go:fix 推荐使用：NewByBool方法
func NewCellBool(content any) *Cell <span class="cov0" title="0">{
        return &amp;Cell{content: content, contentType: CellContentTypeBool}
}</span>

// NewCellTime 实例化：时间
//
//go:fix 推荐使用：NewByTime方法
func NewCellTime(content time.Time) *Cell <span class="cov0" title="0">{
        return &amp;Cell{content: content, contentType: CellContentTypeTime}
}</span>

// NewCellFormula 实例化：公式
//
//go:fix 推荐使用：NewByFormula方法
func NewCellFormula(content string) *Cell <span class="cov0" title="0">{
        return &amp;Cell{content: content, contentType: CellContentTypeFormula}
}</span>

// GetBorder 获取边框
func (my *Cell) GetBorder() *array.AnyArray[border] <span class="cov0" title="0">{
        borders := array.Make[border](0)

        if my.borderTopRgb != "" </span><span class="cov0" title="0">{
                borders.Append(border{Type: "top", Rgb: my.borderTopRgb, Style: my.borderTopStyle})
        }</span>

        <span class="cov0" title="0">if my.borderBottomRgb != "" </span><span class="cov0" title="0">{
                borders.Append(border{Type: "bottom", Rgb: my.borderBottomRgb, Style: my.borderBottomStyle})
        }</span>

        <span class="cov0" title="0">if my.borderLeftRgb != "" </span><span class="cov0" title="0">{
                borders.Append(border{Type: "left", Rgb: my.borderLeftRgb, Style: my.borderLeftStyle})
        }</span>

        <span class="cov0" title="0">if my.borderRightRgb != "" </span><span class="cov0" title="0">{
                borders.Append(border{Type: "right", Rgb: my.borderRightRgb, Style: my.borderRightStyle})
        }</span>

        <span class="cov0" title="0">if my.borderDiagonalUpRgb != "" </span><span class="cov0" title="0">{
                borders.Append(border{Type: "diagonalUp", Rgb: my.borderDiagonalUpRgb, Style: my.borderDiagonalUpStyle})
        }</span>

        <span class="cov0" title="0">if my.borderDiagonalDownRgb != "" </span><span class="cov0" title="0">{
                borders.Append(border{Type: "diagonalDown", Rgb: my.borderDiagonalDownRgb, Style: my.borderDiagonalDownStyle})
        }</span>

        <span class="cov0" title="0">return borders</span>
}

// SetWrapText 设置自动换行
func (my *Cell) SetWrapText(wrapText bool) *Cell <span class="cov0" title="0">{
        my.wrapText = wrapText

        return my
}</span>

// GetWrapText 获取自动换行
func (my *Cell) GetWrapText() bool <span class="cov0" title="0">{ return my.wrapText }</span>

// SetBorderSurrounding 设置四周边框
func (my *Cell) SetBorderSurrounding(borderRgb string, borderStyle int, condition bool) *Cell <span class="cov0" title="0">{
        if condition </span><span class="cov0" title="0">{
                my.borderTopRgb = borderRgb
                my.borderBottomRgb = borderRgb
                my.borderLeftRgb = borderRgb
                my.borderRightRgb = borderRgb
                my.borderTopStyle = borderStyle
                my.borderBottomStyle = borderStyle
                my.borderLeftStyle = borderStyle
                my.borderRightStyle = borderStyle
        }</span>

        <span class="cov0" title="0">return my</span>
}

// SetBorderSurroundingFunc 设置四周边框 函数
func (my *Cell) SetBorderSurroundingFunc(condition func() (string, int, bool)) *Cell <span class="cov0" title="0">{
        if condition != nil </span><span class="cov0" title="0">{
                my.SetBorderSurrounding(condition())
        }</span>

        <span class="cov0" title="0">return my</span>
}

// SetBorderTopRgb 设置边框颜色：上
func (my *Cell) SetBorderTopRgb(borderTopRgb string, condition bool) *Cell <span class="cov0" title="0">{
        if condition </span><span class="cov0" title="0">{
                my.borderTopRgb = borderTopRgb
        }</span>

        <span class="cov0" title="0">return my</span>
}

// SetBorderTopRbgFunc 设置边框颜色：上 函数
func (my *Cell) SetBorderTopRbgFunc(condition func() (string, bool)) *Cell <span class="cov0" title="0">{
        if condition != nil </span><span class="cov0" title="0">{
                my.SetBorderTopRgb(condition())
        }</span>

        <span class="cov0" title="0">return my</span>
}

// SetBorderTopStyle 设置边框样式：上
func (my *Cell) SetBorderTopStyle(borderTopStyle int, condition bool) *Cell <span class="cov0" title="0">{
        if condition </span><span class="cov0" title="0">{
                my.borderTopStyle = borderTopStyle
        }</span>

        <span class="cov0" title="0">return my</span>
}

// SetBorderTopStyleFunc 设置边框样式：上 函数
func (my *Cell) SetBorderTopStyleFunc(condition func() (int, bool)) *Cell <span class="cov0" title="0">{
        if condition != nil </span><span class="cov0" title="0">{
                my.SetBorderTopStyle(condition())
        }</span>

        <span class="cov0" title="0">return my</span>
}

// SetBorderBottomRgb 设置边框颜色：下
func (my *Cell) SetBorderBottomRgb(borderBottomRgb string, condition bool) *Cell <span class="cov0" title="0">{
        if condition </span><span class="cov0" title="0">{
                my.borderBottomRgb = borderBottomRgb
        }</span>

        <span class="cov0" title="0">return my</span>
}

// SetBorderBottomRbgFunc 设置边框颜色：下 函数
func (my *Cell) SetBorderBottomRbgFunc(condition func() (string, bool)) *Cell <span class="cov0" title="0">{
        if condition != nil </span><span class="cov0" title="0">{
                my.SetBorderBottomRgb(condition())
        }</span>

        <span class="cov0" title="0">return my</span>
}

// SetBorderBottomStyle 设置边框样式：下
func (my *Cell) SetBorderBottomStyle(borderBottomStyle int, condition bool) *Cell <span class="cov0" title="0">{
        if condition </span><span class="cov0" title="0">{
                my.borderBottomStyle = borderBottomStyle
        }</span>

        <span class="cov0" title="0">return my</span>
}

// SetBorderBottomStyleFunc 设置边框样式：下 函数
func (my *Cell) SetBorderBottomStyleFunc(condition func() (int, bool)) *Cell <span class="cov0" title="0">{
        if condition != nil </span><span class="cov0" title="0">{
                my.SetBorderBottomStyle(condition())
        }</span>

        <span class="cov0" title="0">return my</span>
}

// SetBorderLeftRgb 设置边框颜色：左
func (my *Cell) SetBorderLeftRgb(borderLeftRgb string, condition bool) *Cell <span class="cov0" title="0">{
        if condition </span><span class="cov0" title="0">{
                my.borderLeftRgb = borderLeftRgb
        }</span>

        <span class="cov0" title="0">return my</span>
}

// SetBorderLeftRbgFunc 设置边框颜色：左 函数
func (my *Cell) SetBorderLeftRbgFunc(condition func() (string, bool)) *Cell <span class="cov0" title="0">{
        if condition != nil </span><span class="cov0" title="0">{
                my.SetBorderLeftRgb(condition())
        }</span>

        <span class="cov0" title="0">return my</span>
}

// SetBorderLeftStyle 设置边框样式：左
func (my *Cell) SetBorderLeftStyle(borderLeftStyle int, condition bool) *Cell <span class="cov0" title="0">{
        if condition </span><span class="cov0" title="0">{
                my.borderLeftStyle = borderLeftStyle
        }</span>

        <span class="cov0" title="0">return my</span>
}

// SetBorderLeftStyleFunc 设置边框样式：左 函数
func (my *Cell) SetBorderLeftStyleFunc(condition func() (int, bool)) *Cell <span class="cov0" title="0">{
        if condition != nil </span><span class="cov0" title="0">{
                my.SetBorderLeftStyle(condition())
        }</span>

        <span class="cov0" title="0">return my</span>
}

// SetBorderRightRgb 设置边框颜色：右
func (my *Cell) SetBorderRightRgb(borderRightRgb string, condition bool) *Cell <span class="cov0" title="0">{
        if condition </span><span class="cov0" title="0">{
                my.borderRightRgb = borderRightRgb
        }</span>

        <span class="cov0" title="0">return my</span>
}

// SetBorderRightRbgFunc 设置边框颜色：右 函数
func (my *Cell) SetBorderRightRbgFunc(condition func() (string, bool)) *Cell <span class="cov0" title="0">{
        if condition != nil </span><span class="cov0" title="0">{
                my.SetBorderRightRgb(condition())
        }</span>

        <span class="cov0" title="0">return my</span>
}

// SetBorderRightStyle 设置边框样式：右
func (my *Cell) SetBorderRightStyle(borderRightStyle int, condition bool) *Cell <span class="cov0" title="0">{
        if condition </span><span class="cov0" title="0">{
                my.borderRightStyle = borderRightStyle
        }</span>

        <span class="cov0" title="0">return my</span>
}

// SetBorderRightStyleFunc 设置边框样式：右 函数
func (my *Cell) SetBorderRightStyleFunc(condition func() (int, bool)) *Cell <span class="cov0" title="0">{
        if condition != nil </span><span class="cov0" title="0">{
                my.SetBorderRightStyle(condition())
        }</span>

        <span class="cov0" title="0">return my</span>
}

// SetBorderDiagonalUpRgb 设置边框颜色：对角线上
func (my *Cell) SetBorderDiagonalUpRgb(borderDiagonalUpRgb string, condition bool) *Cell <span class="cov0" title="0">{
        if condition </span><span class="cov0" title="0">{
                my.borderDiagonalUpRgb = borderDiagonalUpRgb
        }</span>

        <span class="cov0" title="0">return my</span>
}

// SetBorderDiagonalUpRbgFunc 设置边框颜色：对角线上 函数
func (my *Cell) SetBorderDiagonalUpRbgFunc(condition func() (string, bool)) *Cell <span class="cov0" title="0">{
        if condition != nil </span><span class="cov0" title="0">{
                my.SetBorderDiagonalUpRgb(condition())
        }</span>

        <span class="cov0" title="0">return my</span>
}

// SetBorderDiagonalUpStyle 设置边框样式：对角线上
func (my *Cell) SetBorderDiagonalUpStyle(borderDiagonalUpStyle int, condition bool) *Cell <span class="cov0" title="0">{
        if condition </span><span class="cov0" title="0">{
                my.borderDiagonalUpStyle = borderDiagonalUpStyle
        }</span>

        <span class="cov0" title="0">return my</span>
}

// SetBorderDiagonalUpStyleFunc 设置边框样式：对角线上 函数
func (my *Cell) SetBorderDiagonalUpStyleFunc(condition func() (int, bool)) *Cell <span class="cov0" title="0">{
        if condition != nil </span><span class="cov0" title="0">{
                my.SetBorderDiagonalUpStyle(condition())
        }</span>

        <span class="cov0" title="0">return my</span>
}

// SetBorderDiagonalDownRgb 设置边框颜色：对角线下
func (my *Cell) SetBorderDiagonalDownRgb(borderDiagonalDownRgb string, condition bool) *Cell <span class="cov0" title="0">{
        if condition </span><span class="cov0" title="0">{
                my.borderDiagonalDownRgb = borderDiagonalDownRgb
        }</span>

        <span class="cov0" title="0">return my</span>
}

// SetBorderDiagonalDownRbgFunc 设置边框颜色：对角线下 函数
func (my *Cell) SetBorderDiagonalDownRbgFunc(condition func() (string, bool)) *Cell <span class="cov0" title="0">{
        if condition != nil </span><span class="cov0" title="0">{
                my.SetBorderDiagonalDownRgb(condition())
        }</span>

        <span class="cov0" title="0">return my</span>
}

// SetBorderDiagonalDownStyle 设置边框样式：对角线下
func (my *Cell) SetBorderDiagonalDownStyle(borderDiagonalDownStyle int, condition bool) *Cell <span class="cov0" title="0">{
        if condition </span><span class="cov0" title="0">{
                my.borderDiagonalDownStyle = borderDiagonalDownStyle
        }</span>

        <span class="cov0" title="0">return my</span>
}

// SetBorderDiagonalDownStyleFunc 设置边框样式：对角线下 函数
func (my *Cell) SetBorderDiagonalDownStyleFunc(condition func() (int, bool)) *Cell <span class="cov0" title="0">{
        if condition != nil </span><span class="cov0" title="0">{
                my.SetBorderDiagonalDownStyle(condition())
        }</span>

        <span class="cov0" title="0">return my</span>
}

// GetFontRgb 获取字体颜色
func (my *Cell) GetFontRgb() string <span class="cov0" title="0">{ return my.fontRgb }</span>

// SetFontRgb 设置字体颜色
func (my *Cell) SetFontRgb(fontRgb string, condition bool) *Cell <span class="cov0" title="0">{
        if condition </span><span class="cov0" title="0">{
                my.fontRgb = fontRgb
        }</span>

        <span class="cov0" title="0">return my</span>
}

// SetFontRgbFunc 设置字体颜色：函数
func (my *Cell) SetFontRgbFunc(condition func() (string, bool)) *Cell <span class="cov0" title="0">{
        if condition != nil </span><span class="cov0" title="0">{
                my.SetFontRgb(condition())
        }</span>

        <span class="cov0" title="0">return my</span>
}

// GetPatternRgb 获取填充色
func (my *Cell) GetPatternRgb() string <span class="cov0" title="0">{ return my.patternRgb }</span>

// SetPatternRgb 设置填充色
func (my *Cell) SetPatternRgb(patternRgb string, condition bool) *Cell <span class="cov0" title="0">{
        if condition </span><span class="cov0" title="0">{
                my.patternRgb = patternRgb
        }</span>

        <span class="cov0" title="0">return my</span>
}

// SetPatternRgbFunc 设置填充色：函数
func (my *Cell) SetPatternRgbFunc(condition func() (string, bool)) *Cell <span class="cov0" title="0">{
        if condition != nil </span><span class="cov0" title="0">{
                my.SetPatternRgb(condition())
        }</span>

        <span class="cov0" title="0">return my</span>
}

// GetFontBold 获取字体粗体
func (my *Cell) GetFontBold() bool <span class="cov0" title="0">{ return my.fontBold }</span>

// SetFontBold 设置字体粗体
func (my *Cell) SetFontBold(fontBold bool, condition bool) *Cell <span class="cov0" title="0">{
        if condition </span><span class="cov0" title="0">{
                my.fontBold = fontBold
        }</span>

        <span class="cov0" title="0">return my</span>
}

// SetFontBoldFunc 设置字体粗体：函数
func (my *Cell) SetFontBoldFunc(condition func() (bool, bool)) *Cell <span class="cov0" title="0">{
        if condition != nil </span><span class="cov0" title="0">{
                my.SetFontBold(condition())
        }</span>

        <span class="cov0" title="0">return my</span>
}

// GetFontItalic 获取字体斜体
func (my *Cell) GetFontItalic() bool <span class="cov0" title="0">{ return my.fontItalic }</span>

// SetFontItalic 设置字体斜体
func (my *Cell) SetFontItalic(fontItalic bool, condition bool) *Cell <span class="cov0" title="0">{
        if condition </span><span class="cov0" title="0">{
                my.fontItalic = fontItalic
        }</span>

        <span class="cov0" title="0">return my</span>
}

// SetFontItalicFunc 设置字体斜体：函数
func (my *Cell) SetFontItalicFunc(condition func() (bool, bool)) *Cell <span class="cov0" title="0">{
        if condition != nil </span><span class="cov0" title="0">{
                my.SetFontItalic(condition())
        }</span>

        <span class="cov0" title="0">return my</span>
}

// GetFontFamily 获取字体
func (my *Cell) GetFontFamily() string <span class="cov0" title="0">{ return my.fontFamily }</span>

// SetFontFamily 设置字体
func (my *Cell) SetFontFamily(fontFamily string, condition bool) *Cell <span class="cov0" title="0">{
        if condition </span><span class="cov0" title="0">{
                my.fontFamily = fontFamily
        }</span>

        <span class="cov0" title="0">return my</span>
}

// SetFontFamilyFunc 设置字体：函数
func (my *Cell) SetFontFamilyFunc(condition func() (string, bool)) *Cell <span class="cov0" title="0">{
        if condition != nil </span><span class="cov0" title="0">{
                my.SetFontFamily(condition())
        }</span>

        <span class="cov0" title="0">return my</span>
}

// GetFontSize 获取字体字号
func (my *Cell) GetFontSize() float64 <span class="cov0" title="0">{ return my.fontSize }</span>

// SetFontSize 设置字体字号
func (my *Cell) SetFontSize(fontSize float64, condition bool) *Cell <span class="cov0" title="0">{
        if condition </span><span class="cov0" title="0">{
                my.fontSize = fontSize
        }</span>

        <span class="cov0" title="0">return my</span>
}

// SetFontSizeFunc 设置字体字号：函数
func (my *Cell) SetFontSizeFunc(condition func() (float64, bool)) *Cell <span class="cov0" title="0">{
        if condition != nil </span><span class="cov0" title="0">{
                my.SetFontSize(condition())
        }</span>

        <span class="cov0" title="0">return my</span>
}

// Init 初始化
func (my *Cell) Init(content any) *Cell <span class="cov0" title="0">{
        my.content = content

        return my
}</span>

// GetContent 获取内容
func (my *Cell) GetContent() any <span class="cov0" title="0">{ return my.content }</span>

// SetContent 设置内容
func (my *Cell) SetContent(content any) *Cell <span class="cov0" title="0">{
        my.content = content

        return my
}</span>

// GetCoordinate 获取单元格坐标
func (my *Cell) GetCoordinate() string <span class="cov0" title="0">{ return my.coordinate }</span>

// SetCoordinate 设置单元格坐标
func (my *Cell) SetCoordinate(coordinate string) *Cell <span class="cov0" title="0">{
        my.coordinate = coordinate

        return my
}</span>

// GetContentType 获取单元格类型
func (my *Cell) GetContentType() CellContentType <span class="cov0" title="0">{ return my.contentType }</span>

// SetContentType 设置单元格类型
func (my *Cell) SetContentType(contentType CellContentType) *Cell <span class="cov0" title="0">{
        my.contentType = contentType

        return my
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package excel

import (
        "fmt"

        "github.com/go-gota/gota/dataframe"
        "github.com/go-gota/gota/series"
        "github.com/xuri/excelize/v2"

        "github.com/aid297/aid/array"
        "github.com/aid297/aid/dict"
)

// Reader Excel读取器
type Reader struct {
        Err         error
        data        *dict.AnyDict[uint64, *array.AnyArray[string]]
        excel       *excelize.File
        sheetName   string
        originalRow int
        finishedRow int
        titleRow    int
        titles      *array.AnyArray[string]
}

var ReaderApp Reader

func (*Reader) New() *Reader <span class="cov0" title="0">{ return NewReader() }</span>

// NewReader 构造函数
//
//go:fix 推荐使用New方法
func NewReader() *Reader <span class="cov0" title="0">{
        return &amp;Reader{data: dict.Make[uint64, *array.AnyArray[string]]()}
}</span>

// AutoRead 自动读取（默认第一行是表头，从第二行开始，默认Sheet名称为：Sheet1）
func (my *Reader) AutoRead(filename ...any) *Reader <span class="cov0" title="0">{
        return my.
                OpenFile(filename...).
                SetOriginalRow(2).
                SetTitleRow(1).
                SetSheetName("Sheet1").
                ReadTitle().
                Read()
}</span>

// AutoReadBySheetName 自动读取（默认第一行是表头，从第二行开始）
func (my *Reader) AutoReadBySheetName(sheetName string, filename ...any) *Reader <span class="cov0" title="0">{
        return my.
                OpenFile(filename...).
                SetOriginalRow(2).
                SetTitleRow(1).
                SetSheetName(sheetName).
                ReadTitle().
                Read()
}</span>

// Data 获取数据：有序字典
func (my *Reader) Data() *dict.AnyDict[uint64, *array.AnyArray[string]] <span class="cov0" title="0">{ return my.data }</span>

// DataWithTitle 获取数据：带有title的有序字典
func (my *Reader) DataWithTitle() (*dict.AnyDict[uint64, *dict.AnyDict[string, string]], error) <span class="cov0" title="0">{
        newDict := dict.Make[uint64, *dict.AnyDict[string, string]]()

        for idx, value := range my.data.ToMap() </span><span class="cov0" title="0">{
                newDict.Set(idx, dict.Zip(my.titles.ToSlice(), value.ToSlice()))
        }</span>

        <span class="cov0" title="0">return newDict, nil</span>
}

// SetDataByRow 设置单行数据
func (my *Reader) SetDataByRow(rowNumber uint64, data []string) *Reader <span class="cov0" title="0">{
        my.data.Set(rowNumber, array.New(data))

        return my
}</span>

// GetSheetName 获取工作表名称
func (my *Reader) GetSheetName() string <span class="cov0" title="0">{ return my.sheetName }</span>

// SetSheetName 设置工作表名称
func (my *Reader) SetSheetName(sheetName string) *Reader <span class="cov0" title="0">{
        my.sheetName = sheetName

        return my
}</span>

// GetOriginalRow 获取读取起始行
func (my *Reader) GetOriginalRow() int <span class="cov0" title="0">{ return my.originalRow }</span>

// SetOriginalRow 设置读取起始行
func (my *Reader) SetOriginalRow(originalRow int) *Reader <span class="cov0" title="0">{
        my.originalRow = originalRow - 1

        return my
}</span>

// GetFinishedRow 获取读取终止行
func (my *Reader) GetFinishedRow() int <span class="cov0" title="0">{ return my.finishedRow }</span>

// SetFinishedRow 设置读取终止行
func (my *Reader) SetFinishedRow(finishedRow int) *Reader <span class="cov0" title="0">{
        my.finishedRow = finishedRow - 1

        return my
}</span>

// GetTitleRow 获取表头行
func (my *Reader) GetTitleRow() int <span class="cov0" title="0">{ return my.titleRow }</span>

// SetTitleRow 设置表头行
func (my *Reader) SetTitleRow(titleRow int) *Reader <span class="cov0" title="0">{
        my.titleRow = titleRow - 1

        return my
}</span>

// GetTitle 获取表头
func (my *Reader) GetTitle() *array.AnyArray[string] <span class="cov0" title="0">{ return my.titles }</span>

// SetTitle 设置表头
func (my *Reader) SetTitle(titles []string) *Reader <span class="cov0" title="0">{
        if len(titles) == 0 </span><span class="cov0" title="0">{
                my.Err = ReadErr.New("表头不能为空")
                return my
        }</span>
        <span class="cov0" title="0">my.titles = array.New(titles)

        return my</span>
}

// OpenFile 打开文件
func (my *Reader) OpenFile(filename ...any) *Reader <span class="cov0" title="0">{
        if filename[0].(string) == "" </span><span class="cov0" title="0">{
                my.Err = ReadErr.New("文件名不能为空")
                return my
        }</span>
        <span class="cov0" title="0">f, err := excelize.OpenFile(fmt.Sprintf(filename[0].(string), filename[1:]...))
        if err != nil </span><span class="cov0" title="0">{
                my.Err = ReadErr.Wrap(fmt.Errorf("打开文件错误：%w", err))
                return my
        }</span>
        <span class="cov0" title="0">my.excel = f

        defer func(r *Reader) </span><span class="cov0" title="0">{
                if err = r.excel.Close(); err != nil </span><span class="cov0" title="0">{
                        r.Err = ReadErr.New("文件关闭错误")
                }</span>
        }(my)

        <span class="cov0" title="0">my.SetTitleRow(1)
        my.SetOriginalRow(2)
        my.data = dict.Make[uint64, *array.AnyArray[string]]()

        return my</span>
}

// ReadTitle 读取表头
func (my *Reader) ReadTitle() *Reader <span class="cov0" title="0">{
        if my.GetSheetName() == "" </span><span class="cov0" title="0">{
                my.Err = ReadErr.New("未设置工作表名称")
                return my
        }</span>

        <span class="cov0" title="0">rows, err := my.excel.GetRows(my.GetSheetName())
        if err != nil </span><span class="cov0" title="0">{
                my.Err = ReadErr.New("读取表头错误")
                return my
        }</span>
        <span class="cov0" title="0">my.SetTitle(rows[my.GetTitleRow()])

        return my</span>
}

// Read 读取Excel
func (my *Reader) Read() *Reader <span class="cov0" title="0">{
        if my.GetSheetName() == "" </span><span class="cov0" title="0">{
                my.Err = ReadErr.New("未设置工作表名称")
                return my
        }</span>

        <span class="cov0" title="0">rows, err := my.excel.GetRows(my.GetSheetName())
        if err != nil </span><span class="cov0" title="0">{
                my.Err = ReadErr.Wrap(err)
                return my
        }</span>

        <span class="cov0" title="0">if my.finishedRow == 0 </span><span class="cov0" title="0">{
                for rowNumber, values := range rows[my.GetOriginalRow():] </span><span class="cov0" title="0">{
                        my.SetDataByRow(uint64(rowNumber), values)
                }</span>
        } else<span class="cov0" title="0"> {
                for rowNumber, values := range rows[my.GetOriginalRow():my.GetFinishedRow()] </span><span class="cov0" title="0">{
                        my.SetDataByRow(uint64(rowNumber), values)
                }</span>
        }

        <span class="cov0" title="0">return my</span>
}

// ToDataFrameDefaultType 获取DataFrame类型数据 通过Excel表头自定义数据类型
func (my *Reader) ToDataFrameDefaultType() dataframe.DataFrame <span class="cov0" title="0">{
        titleWithType := make(map[string]series.Type)
        for _, title := range my.GetTitle().ToSlice() </span><span class="cov0" title="0">{
                titleWithType[title] = series.String
        }</span>

        <span class="cov0" title="0">return my.ToDataFrame(titleWithType)</span>
}

// ToDataFrame 获取DataFrame类型数据
func (my *Reader) ToDataFrame(titleWithType map[string]series.Type) dataframe.DataFrame <span class="cov0" title="0">{
        if my.GetSheetName() == "" </span><span class="cov0" title="0">{
                my.Err = ReadErr.New("未设置工作表名称")
                return dataframe.DataFrame{}
        }</span>

        <span class="cov0" title="0">var _content [][]string

        rows, err := my.excel.GetRows(my.GetSheetName())
        if err != nil </span><span class="cov0" title="0">{
                my.Err = ReadErr.Wrap(err)
                return dataframe.DataFrame{}
        }</span>

        <span class="cov0" title="0">if my.finishedRow == 0 </span><span class="cov0" title="0">{
                _content = rows[my.GetTitleRow():]
        }</span> else<span class="cov0" title="0"> {
                _content = rows[my.GetTitleRow():my.GetFinishedRow()]
        }</span>

        <span class="cov0" title="0">return dataframe.LoadRecords(
                _content,
                dataframe.DetectTypes(false),
                dataframe.DefaultType(series.String),
                dataframe.WithTypes(titleWithType),
        )</span>
}

// ToDataFrameDetectType 获取DataFrame类型数据 通过自动探寻数据类型
func (my *Reader) ToDataFrameDetectType() dataframe.DataFrame <span class="cov0" title="0">{
        if my.GetSheetName() == "" </span><span class="cov0" title="0">{
                my.Err = ReadErr.New("未设置工作表名称")
                return dataframe.DataFrame{}
        }</span>

        <span class="cov0" title="0">var _content [][]string

        rows, err := my.excel.GetRows(my.GetSheetName())
        if err != nil </span><span class="cov0" title="0">{
                my.Err = ReadErr.Wrap(err)
                return dataframe.DataFrame{}
        }</span>

        <span class="cov0" title="0">if my.finishedRow == 0 </span><span class="cov0" title="0">{
                _content = rows[my.GetTitleRow():]
        }</span> else<span class="cov0" title="0"> {
                _content = rows[my.GetTitleRow():my.GetFinishedRow()]
        }</span>

        <span class="cov0" title="0">return dataframe.LoadRecords(
                _content,
                dataframe.DetectTypes(true),
                dataframe.DefaultType(series.String),
        )</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package excel

import (
        "fmt"

        "github.com/aid297/aid/array"

        "github.com/xuri/excelize/v2"
)

// Row Excel行
type Row struct {
        Err       error
        cells     *array.AnyArray[*Cell]
        rowNumber uint64
}

var RowApp Row

func (*Row) New() *Row <span class="cov0" title="0">{ return NewRow() }</span>

// NewRow 构造函数
//
//go:fix 推荐使用New方法
func NewRow() *Row <span class="cov0" title="0">{ return &amp;Row{} }</span>

// GetCells 获取单元格组
func (my *Row) GetCells() *array.AnyArray[*Cell] <span class="cov0" title="0">{ return my.cells }</span>

// SetCells 设置单元格组
func (my *Row) SetCells(cells []*Cell) *Row <span class="cov0" title="0">{
        if my.GetRowNumber() == 0 </span><span class="cov0" title="0">{
                my.Err = SetCellErr.New("行标必须大于0")
                return my
        }</span>

        <span class="cov0" title="0">for colNumber, cell := range cells </span><span class="cov0" title="0">{
                if colText, err := excelize.ColumnNumberToName(colNumber + 1); err != nil </span><span class="cov0" title="0">{
                        my.Err = SetCellErr.Wrap(fmt.Errorf("列索引转列文字失败：%d，%d", my.GetRowNumber(), colNumber+1))
                        return my
                }</span> else<span class="cov0" title="0"> {
                        cell.SetCoordinate(fmt.Sprintf("%s%d", colText, my.GetRowNumber()))
                }</span>
        }
        <span class="cov0" title="0">my.cells = array.New(cells)

        return my</span>
}

// GetRowNumber 获取行标
func (my *Row) GetRowNumber() uint64 <span class="cov0" title="0">{ return my.rowNumber }</span>

// SetRowNumber 设置行标
func (my *Row) SetRowNumber(rowNumber uint64) *Row <span class="cov0" title="0">{
        my.rowNumber = rowNumber

        return my
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package excel

import (
        "time"

        "github.com/aid297/aid/dict"

        "github.com/xuri/excelize/v2"

        "github.com/aid297/aid/str"
)

// ColumnNumberToText 列索引转文字
func ColumnNumberToText(columnNumber int) (string, error) <span class="cov0" title="0">{
        return excelize.ColumnNumberToName(columnNumber)
}</span>

// ColumnTextToNumber 列文字转索引
func ColumnTextToNumber(columnText string) int <span class="cov0" title="0">{
        result := 0
        for i, char := range columnText </span><span class="cov0" title="0">{
                result += (int(char - 'A' + 1)) * pow(26, len(columnText)-i-1)
        }</span>

        <span class="cov0" title="0">return result</span>
}

// pow 是一个简单的幂函数计算，用于26进制转换
func pow(base, exponent int) int <span class="cov0" title="0">{
        result := 1
        for range exponent </span><span class="cov0" title="0">{
                result *= base
        }</span>

        <span class="cov0" title="0">return result</span>
}

func WriteDemo(filename string) <span class="cov0" title="0">{
        err := NewWriter(filename).
                CreateSheet("Sheet1").
                SetTitleRow([]string{"username", "nickname", "score"}, 1).
                SetRows([]*Row{
                        NewRow().
                                SetRowNumber(2).
                                SetCells([]*Cell{
                                        NewCellAny("zhangsan"),
                                        NewCellAny("张三"),
                                        NewCellAny(100).
                                                SetFontRgbFunc(func() (string, bool) </span><span class="cov0" title="0">{
                                                        if 100 &gt; 80 </span><span class="cov0" title="0">{
                                                                return "FF0000", true
                                                        }</span> else<span class="cov0" title="0"> {
                                                                return "", false
                                                        }</span>
                                                }).
                                                SetFontSize(28, true).
                                                SetFontBold(true, true).
                                                SetFontItalic(true, true),
                                }),
                        NewRow().
                                SetRowNumber(3).
                                SetCells([]*Cell{
                                        NewCellAny("lisi"),
                                        NewCellAny("李四"),
                                        NewCellAny(90).
                                                SetFontRgbFunc(func() (string, bool) <span class="cov0" title="0">{
                                                        if 90 &gt; 80 </span><span class="cov0" title="0">{
                                                                return "FF0000", true
                                                        }</span> else<span class="cov0" title="0"> {
                                                                return "", false
                                                        }</span>
                                                }).
                                                SetFontSize(28, true).
                                                SetFontBold(true, true).
                                                SetFontItalic(true, true),
                                }),
                        NewRow().
                                SetRowNumber(4).
                                SetCells([]*Cell{
                                        NewCellAny("wangwu"),
                                        NewCellAny("王五"),
                                        NewCellAny(80).
                                                SetFontRgbFunc(func() (string, bool) <span class="cov0" title="0">{
                                                        if 80 &gt; 90 </span><span class="cov0" title="0">{
                                                                return "FF0000", true
                                                        }</span> else<span class="cov0" title="0"> {
                                                                return "", false
                                                        }</span>
                                                }).
                                                SetFontSize(28, false).
                                                SetFontBold(true, false).
                                                SetFontItalic(true, false),
                                }),
                        NewRow().
                                SetRowNumber(5).
                                SetCells([]*Cell{
                                        NewCellAny("zhaoliu"),
                                        NewCellAny("赵六").
                                                SetPatternRgb("#00FF00", true),
                                        NewCellTime(time.Now()).
                                                SetFontRgbFunc(func() (string, bool) <span class="cov0" title="0">{
                                                        if 70 &gt; 80 </span><span class="cov0" title="0">{
                                                                return "FF0000", true
                                                        }</span> else<span class="cov0" title="0"> {
                                                                return "", false
                                                        }</span>
                                                }).
                                                SetFontSize(28, false).
                                                SetFontBold(true, false).
                                                SetFontItalic(true, false).
                                                SetBorderSurrounding("0000FF", 1, true),
                                }),
                }).
                Save()
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                str.NewTerminalLog("保存excel失败 %v").Error(err)
        }</span>
}

func ReadDemo(filename string) <span class="cov0" title="0">{
        excelData, err := NewReader().
                OpenFile(filename).
                SetOriginalRow(2).
                SetTitleRow(1).
                SetSheetName("Sheet1").
                ReadTitle().
                Read().
                DataWithTitle()
        if err != nil </span><span class="cov0" title="0">{
                str.NewTerminalLog("err: %v").Error(err)
        }</span>

        <span class="cov0" title="0">excelData.Each(func(key uint64, value *dict.AnyDict[string, string]) </span><span class="cov0" title="0">{
                username := value.GetValueByKey("username")
                nickname := value.GetValueByKey("nickname")
                score := value.GetValueByKey("score")

                str.NewTerminalLog("%d行: 姓名[%s]，昵称[%s]，分数[%s]").Success(key, username, nickname, score)
        }</span>)
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package excel

import (
        "fmt"
        "net/http"
        "net/url"
        "time"

        "github.com/xuri/excelize/v2"
)

// Writer Excel写入器
type Writer struct {
        Err       error
        filename  string
        excel     *excelize.File
        sheetName string
}

var WriterApp Writer

func (*Writer) New(filename ...any) *Writer <span class="cov0" title="0">{ return NewWriter(filename...) }</span>

// NewWriter 初始化
//
//go:fix 推荐使用：New方法
func NewWriter(filename ...any) *Writer <span class="cov0" title="0">{
        ins := &amp;Writer{}
        if filename[0].(string) == "" </span><span class="cov0" title="0">{
                ins.Err = WriteErr.New("文件名不能为空")
                return ins
        }</span>
        <span class="cov0" title="0">ins.filename = fmt.Sprintf(filename[0].(string), filename[1:]...)
        ins.excel = excelize.NewFile()

        return ins</span>
}

// GetFilename 获取文件名
func (my *Writer) GetFilename() string <span class="cov0" title="0">{ return my.filename }</span>

// SetFilename 设置文件名
func (my *Writer) SetFilename(filename string) *Writer <span class="cov0" title="0">{
        my.filename = filename

        return my
}</span>

// CreateSheet 创建工作表
func (my *Writer) CreateSheet(sheetName string) *Writer <span class="cov0" title="0">{
        if sheetName == "" </span><span class="cov0" title="0">{
                my.Err = WriteErr.New("工作表名称不能为空")
                return my
        }</span>
        <span class="cov0" title="0">sheetIndex, err := my.excel.NewSheet(sheetName)
        if err != nil </span><span class="cov0" title="0">{
                my.Err = WriteErr.Wrap(err)
                return my
        }</span>

        <span class="cov0" title="0">my.excel.SetActiveSheet(sheetIndex)
        my.sheetName = my.excel.GetSheetName(sheetIndex)

        return my</span>
}

// ActiveSheetByName 选择工作表（根据名称）
func (my *Writer) ActiveSheetByName(sheetName string) *Writer <span class="cov0" title="0">{
        if sheetName == "" </span><span class="cov0" title="0">{
                my.Err = WriteErr.New("工作表名称不能为空")
                return my
        }</span>
        <span class="cov0" title="0">sheetIndex, err := my.excel.GetSheetIndex(sheetName)
        if err != nil </span><span class="cov0" title="0">{
                my.Err = WriteErr.Wrap(err)
                return my
        }</span>

        <span class="cov0" title="0">my.excel.SetActiveSheet(sheetIndex)
        my.sheetName = sheetName

        return my</span>
}

// ActiveSheetByIndex 选择工作表（根据编号）
func (my *Writer) ActiveSheetByIndex(sheetIndex int) *Writer <span class="cov0" title="0">{
        if sheetIndex &lt; 0 </span><span class="cov0" title="0">{
                my.Err = WriteErr.New("工作表索引不能小于0")
                return my
        }</span>
        <span class="cov0" title="0">my.excel.SetActiveSheet(sheetIndex)
        my.sheetName = my.excel.GetSheetName(sheetIndex)

        return my</span>
}

// SetSheetName 设置sheet名称
func (my *Writer) SetSheetName(sheetName string) *Writer <span class="cov0" title="0">{
        my.excel.SetSheetName(my.sheetName, sheetName)
        my.sheetName = sheetName

        return my
}</span>

// setStyleFont 设置字体
func (my *Writer) setStyleFont(cell *Cell) <span class="cov0" title="0">{
        fill := excelize.Fill{Type: "pattern", Pattern: 0, Color: []string{""}}
        if cell.GetPatternRgb() != "" </span><span class="cov0" title="0">{
                fill.Pattern = 1
                fill.Color[0] = cell.GetPatternRgb()
        }</span>

        <span class="cov0" title="0">var borders = make([]excelize.Border, 0)
        if cell.GetBorder().Len() &gt; 0 </span><span class="cov0" title="0">{
                for _, border := range cell.GetBorder().ToSlice() </span><span class="cov0" title="0">{
                        borders = append(borders, excelize.Border{
                                Type:  border.Type,
                                Color: border.Rgb,
                                Style: border.Style,
                        })
                }</span>
        }

        <span class="cov0" title="0">if style, err := my.excel.NewStyle(&amp;excelize.Style{
                Font: &amp;excelize.Font{
                        Bold:   cell.GetFontBold(),
                        Italic: cell.GetFontItalic(),
                        Family: cell.GetFontFamily(),
                        Size:   cell.GetFontSize(),
                        Color:  cell.GetFontRgb(),
                },
                Alignment: &amp;excelize.Alignment{
                        WrapText: cell.GetWrapText(),
                },
                Fill:   fill,
                Border: borders,
        }); err != nil </span><span class="cov0" title="0">{
                my.Err = WriteErr.Wrap(fmt.Errorf("设置字体错误：%s", cell.GetCoordinate()))
        }</span> else<span class="cov0" title="0"> {
                my.Err = my.excel.SetCellStyle(my.sheetName, cell.GetCoordinate(), cell.GetCoordinate(), style)
        }</span>
}

// SetColumnWidthByIndex 设置单列宽：通过列索引
func (my *Writer) SetColumnWidthByIndex(col int, width float64) *Writer <span class="cov0" title="0">{
        my.SetColumnsWidthByIndex(col, col, width)

        return my
}</span>

// SetColumnWidthByText 设置单列宽：通过列名称
func (my *Writer) SetColumnWidthByText(col string, width float64) *Writer <span class="cov0" title="0">{
        my.SetColumnsWidthByText(col, col, width)

        return my
}</span>

// SetColumnsWidthByIndex 设置多列宽：通过列索引
func (my *Writer) SetColumnsWidthByIndex(startCol, endCol int, width float64) *Writer <span class="cov0" title="0">{
        startColText, err := ColumnNumberToText(startCol)
        if err != nil </span><span class="cov0" title="0">{
                my.Err = WriteErr.Wrap(fmt.Errorf("设置列宽错误：%s", err))
        }</span>

        <span class="cov0" title="0">endColText, err := ColumnNumberToText(endCol)
        if err != nil </span><span class="cov0" title="0">{
                my.Err = WriteErr.Wrap(fmt.Errorf("设置列宽错误：%s", err))
        }</span>

        <span class="cov0" title="0">if err = my.excel.SetColWidth(my.sheetName, startColText, endColText, width); err != nil </span><span class="cov0" title="0">{
                my.Err = WriteErr.Wrap(fmt.Errorf("设置列宽错误：%s", err))
        }</span>

        <span class="cov0" title="0">return my</span>
}

// SetColumnsWidthByText 设置多列宽：通过列名称
func (my *Writer) SetColumnsWidthByText(startCol, endCol string, width float64) *Writer <span class="cov0" title="0">{
        if err := my.excel.SetColWidth(my.sheetName, startCol, endCol, width); err != nil </span><span class="cov0" title="0">{
                my.Err = WriteErr.Wrap(fmt.Errorf("设置列宽错误：%s", err))
        }</span>

        <span class="cov0" title="0">return my</span>
}

// SetRows 设置行数据
func (my *Writer) SetRows(excelRows []*Row) *Writer <span class="cov0" title="0">{
        for _, row := range excelRows </span><span class="cov0" title="0">{
                my.AddRow(row)
        }</span>

        <span class="cov0" title="0">return my</span>
}

// AddRow 增加一行行数据
func (my *Writer) AddRow(excelRow *Row) *Writer <span class="cov0" title="0">{
        for _, cell := range excelRow.GetCells().ToSlice() </span><span class="cov0" title="0">{
                my.Err = my.excel.SetCellValue(my.sheetName, cell.GetCoordinate(), cell.GetContent())
                switch cell.GetContentType() </span>{
                case CellContentTypeFormula:<span class="cov0" title="0">
                        if err := my.excel.SetCellFormula(my.sheetName, cell.GetCoordinate(), cell.GetContent().(string)); err != nil </span><span class="cov0" title="0">{
                                my.Err = WriteErr.Wrap(fmt.Errorf("写入数据错误（公式）%s %s：%v", cell.GetCoordinate(), cell.GetContent(), err.Error()))
                                return my
                        }</span>
                case CellContentTypeAny:<span class="cov0" title="0">
                        if err := my.excel.SetCellValue(my.sheetName, cell.GetCoordinate(), cell.GetContent()); err != nil </span><span class="cov0" title="0">{
                                my.Err = WriteErr.Wrap(fmt.Errorf("写入ExcelCell（任意） %s %s：%v", cell.GetCoordinate(), cell.GetContent(), err.Error()))
                                return my
                        }</span>
                case CellContentTypeInt:<span class="cov0" title="0">
                        if err := my.excel.SetCellInt(my.sheetName, cell.GetCoordinate(), cell.GetContent().(int)); err != nil </span><span class="cov0" title="0">{
                                my.Err = WriteErr.Wrap(fmt.Errorf("写入ExcelCell（整数） %s %s：%v", cell.GetCoordinate(), cell.GetContent(), err.Error()))
                                return my
                        }</span>
                case CellContentTypeFloat64:<span class="cov0" title="0">
                        if err := my.excel.SetCellFloat(my.sheetName, cell.GetCoordinate(), cell.GetContent().(float64), 2, 64); err != nil </span><span class="cov0" title="0">{
                                my.Err = WriteErr.Wrap(fmt.Errorf("写入ExcelCell（浮点数） %s %s：%v", cell.GetCoordinate(), cell.GetContent(), err.Error()))
                                return my
                        }</span>
                case CellContentTypeBool:<span class="cov0" title="0">
                        if err := my.excel.SetCellBool(my.sheetName, cell.GetCoordinate(), cell.GetContent().(bool)); err != nil </span><span class="cov0" title="0">{
                                my.Err = WriteErr.Wrap(fmt.Errorf("写入ExcelCell（布尔） %s %s：%v", cell.GetCoordinate(), cell.GetContent(), err.Error()))
                                return my
                        }</span>
                case CellContentTypeTime:<span class="cov0" title="0">
                        if err := my.excel.SetCellValue(my.sheetName, cell.GetCoordinate(), cell.GetContent().(time.Time)); err != nil </span><span class="cov0" title="0">{
                                my.Err = WriteErr.Wrap(fmt.Errorf("写入ExcelCell（时间） %s %s：%v", cell.GetCoordinate(), cell.GetContent(), err.Error()))
                        }</span>
                }
                <span class="cov0" title="0">my.setStyleFont(cell)</span>
        }

        <span class="cov0" title="0">return my</span>
}

// SetTitleRow 设置标题行
func (my *Writer) SetTitleRow(titles []string, rowNumber uint64) *Writer <span class="cov0" title="0">{
        var (
                titleRow   *Row
                titleCells = make([]*Cell, len(titles))
        )

        if len(titles) &gt; 0 </span><span class="cov0" title="0">{
                for idx, title := range titles </span><span class="cov0" title="0">{
                        titleCells[idx] = NewCellAny(title)
                }</span>

                <span class="cov0" title="0">titleRow = NewRow().SetRowNumber(rowNumber).SetCells(titleCells)

                my.AddRow(titleRow)</span>
        }

        <span class="cov0" title="0">return my</span>
}

// Save 保存文件
func (my *Writer) Save() error <span class="cov0" title="0">{
        if my.filename == "" </span><span class="cov0" title="0">{
                return WriteErr.New("未设置文件名")
        }</span>

        <span class="cov0" title="0">return my.excel.SaveAs(my.filename)</span>
}

// Download 下载Excel
func (my *Writer) Download(writer http.ResponseWriter) error <span class="cov0" title="0">{
        </span><span class="cov0" title="0">{
                writer.Header().Set("Content-Type", "application/octet-stream")
                writer.Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=%s", url.QueryEscape(my.filename)))
                writer.Header().Set("Content-Transfer-Encoding", "binary")
                writer.Header().Set("Access-Control-Expose-Headers", "Content-Disposition")
        }</span>

        <span class="cov0" title="0">return my.excel.Write(writer)</span>
}

// GetExcelizeFile 获取excelize文件对象
func (my *Writer) GetExcelizeFile() *excelize.File <span class="cov0" title="0">{ return my.excel }</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package filesystem

import (
        "errors"
        "fmt"

        "github.com/aid297/aid/httpClient"
)

type (
        FileManager struct {
                Err            error
                dstDir, srcDir string
                fileBytes      []byte
                fileSize       int64
                config         *FileManagerConfig
                uploadMethods  map[FileManagerConfigDriver]func() (int64, error)
                deleteMethods  map[FileManagerConfigDriver]func() error
        }
        FileManagerConfigDriver string
        FileManagerConfig       struct {
                Username  string
                Password  string
                AuthTitle string
                Driver    FileManagerConfigDriver
        }
)

var FileManagerApp FileManager

func (*FileManager) New(config *FileManagerConfig) *FileManager <span class="cov0" title="0">{ return NewFileManager(config) }</span>
func (*FileManager) NewByLocalFile(srcDir, dstDir string, config *FileManagerConfig) (*FileManager, error) <span class="cov0" title="0">{
        return NewFileManagerByLocalFile(srcDir, dstDir, config)
}</span>
func (*FileManager) NewByBytes(srcFileBytes []byte, dstDir string, config *FileManagerConfig) *FileManager <span class="cov0" title="0">{
        return NewFileManagerByBytes(srcFileBytes, dstDir, config)
}</span>

const (
        FileManagerConfigDriverLocal FileManagerConfigDriver = "LOCAL"
        FileManagerConfigDriverNexus FileManagerConfigDriver = "NEXUS"
        FileManagerConfigDriverOss   FileManagerConfigDriver = "OSS"
)

// NewFileManager 初始化：文件管理
//
//go:fix 推荐使用 New方法
func NewFileManager(config *FileManagerConfig) *FileManager <span class="cov0" title="0">{
        fm := &amp;FileManager{
                config:        config,
                uploadMethods: make(map[FileManagerConfigDriver]func() (int64, error)),
                deleteMethods: make(map[FileManagerConfigDriver]func() error),
        }

        fm.uploadMethods = map[FileManagerConfigDriver]func() (int64, error){
                FileManagerConfigDriverLocal: fm.uploadToLocal,
                FileManagerConfigDriverNexus: fm.uploadToNexus,
                FileManagerConfigDriverOss:   fm.uploadToOss,
        }

        fm.deleteMethods = map[FileManagerConfigDriver]func() error{
                FileManagerConfigDriverLocal: fm.deleteFromLocal,
                FileManagerConfigDriverNexus: fm.deleteFromNexus,
                FileManagerConfigDriverOss:   fm.deleteFromOss,
        }

        return fm
}</span>

// NewFileManagerByLocalFile 初始化：文件管理器（通过本地文件）
//
//go:fix 推荐使用NewByLocalFile方法
func NewFileManagerByLocalFile(srcDir, dstDir string, config *FileManagerConfig) (*FileManager, error) <span class="cov0" title="0">{
        fs := NewFileSystemByAbsolute(srcDir)
        if !fs.IsExist </span><span class="cov0" title="0">{
                return nil, errors.New("目标文件不存在")
        }</span>

        <span class="cov0" title="0">fileBytes, err := fs.Read()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;FileManager{dstDir: dstDir, srcDir: srcDir, fileBytes: fileBytes, fileSize: int64(len(fileBytes)), config: config}, nil</span>
}

// NewFileManagerByBytes 实例化：文件管理器（通过字节）
//
//go:fix 推荐使用NewByBytes方法
func NewFileManagerByBytes(srcFileBytes []byte, dstDir string, config *FileManagerConfig) *FileManager <span class="cov0" title="0">{
        return &amp;FileManager{dstDir: dstDir, fileBytes: srcFileBytes, fileSize: int64(len(srcFileBytes)), config: config}
}</span>

// SetSrcDir 设置源文件
func (my *FileManager) SetSrcDir(srcDir string) (*FileManager, error) <span class="cov0" title="0">{
        fs := NewFileSystemByAbsolute(srcDir)
        if !fs.IsExist </span><span class="cov0" title="0">{
                return nil, errors.New("目标文件不存在")
        }</span>

        <span class="cov0" title="0">fileBytes, err := fs.Read()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">{
                my.srcDir = fs.GetDir()
                my.fileBytes = fileBytes
                my.fileSize = int64(len(fileBytes))
        }</span>

        <span class="cov0" title="0">return my, nil</span>
}

// SetDstDir 设置目标目录
func (my *FileManager) SetDstDir(dstDir string) *FileManager <span class="cov0" title="0">{
        my.dstDir = dstDir

        return my
}</span>

// Upload 上传文件
func (my *FileManager) Upload() (int64, error) <span class="cov0" title="0">{
        switch my.config.Driver </span>{
        case FileManagerConfigDriverLocal, FileManagerConfigDriverNexus, FileManagerConfigDriverOss:<span class="cov0" title="0">
                return my.uploadMethods[my.config.Driver]()</span>
        default:<span class="cov0" title="0">
                return 0, fmt.Errorf("不支持的驱动类型：%s", my.config.Driver)</span>
        }
}

// Delete 删除文件
func (my *FileManager) Delete() error <span class="cov0" title="0">{
        switch my.config.Driver </span>{
        case FileManagerConfigDriverLocal, FileManagerConfigDriverNexus, FileManagerConfigDriverOss:<span class="cov0" title="0">
                return my.deleteMethods[my.config.Driver]()</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("不支持的驱动类型：%s", my.config.Driver)</span>
        }
}

// 上传到本地
func (my *FileManager) uploadToLocal() (int64, error) <span class="cov0" title="0">{
        dst := FileSystemApp.NewByAbs(my.dstDir)

        return dst.WriteBytes(my.fileBytes)
}</span>

// 上传到nexus
func (my *FileManager) uploadToNexus() (int64, error) <span class="cov0" title="0">{
        client := httpClient.
                NewPut(my.dstDir).
                SetAuthorization(my.config.Username, my.config.Password, my.config.AuthTitle).
                SetHeaders(map[string][]string{"Content-Length": {fmt.Sprintf("%d", my.fileSize)}}).
                SetBody(my.fileBytes).
                Send()

        if client.Err != nil </span><span class="cov0" title="0">{
                return 0, client.Err
        }</span>

        <span class="cov0" title="0">return int64(len(my.fileBytes)), nil</span>
}

// 上传到oss
func (my *FileManager) uploadToOss() (int64, error) <span class="cov0" title="0">{ return 0, errors.New("暂不支持oss方式") }</span>

// 从本地删除文件
func (my *FileManager) deleteFromLocal() error <span class="cov0" title="0">{ return NewFileSystemByAbsolute(my.dstDir).DelFile() }</span>

// 从nexus删除文件
func (my *FileManager) deleteFromNexus() error <span class="cov0" title="0">{
        return httpClient.
                NewDelete(my.dstDir).
                SetAuthorization(my.config.Username, my.config.Password, my.config.AuthTitle).
                Send().Err
}</span>

// 从oss删除文件
func (my *FileManager) deleteFromOss() error <span class="cov0" title="0">{ return errors.New("暂不支持oss方式") }</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package filesystem

import (
        "errors"
        "fmt"
        "io"
        "log"
        "os"
        "path"
        "path/filepath"
        "runtime"
        "strings"
)

type (
        // FileSystem 文件系统
        FileSystem struct {
                dir     string
                IsExist bool
                IsDir   bool
                IsFile  bool
        }

        // FileSystemCopyFilesTarget 拷贝文件目标
        FileSystemCopyFilesTarget struct {
                Src         *FileSystem
                DstFilename string
        }
)

var FileSystemApp FileSystem

func (*FileSystem) NewByRel(dir string) *FileSystem <span class="cov8" title="1">{ return FileSystemApp.NewByRelative(dir) }</span>
func (*FileSystem) NewByAbs(dir string) *FileSystem <span class="cov0" title="0">{ return FileSystemApp.NewByAbsolute(dir) }</span>

// NewByRelative 实例化：文件系统（相对路径）
func (*FileSystem) NewByRelative(dir string) *FileSystem <span class="cov8" title="1">{
        ins := &amp;FileSystem{dir: filepath.Clean(filepath.Join(getRootPath(), dir))}

        return ins.init()
}</span>

// NewByAbsolute 实例化：文件系统（绝对路径）
func (*FileSystem) NewByAbsolute(dir string) *FileSystem <span class="cov0" title="0">{
        ins := &amp;FileSystem{dir: dir}

        return ins.init()
}</span>

// NewFileSystemByRelative 实例化：文件系统（相对路径）
//
//go:fix 推荐使用NewByRelative方法
func NewFileSystemByRelative(dir string) *FileSystem <span class="cov0" title="0">{
        ins := &amp;FileSystem{dir: filepath.Clean(filepath.Join(getRootPath(), dir))}

        return ins.init()
}</span>

// NewFileSystemByAbsolute 实例化：文件系统（绝对路径）
//
//go:fix 推荐使用NewByAbsolute方法
func NewFileSystemByAbsolute(dir string) *FileSystem <span class="cov0" title="0">{
        ins := &amp;FileSystem{dir: dir}

        return ins.init()
}</span>

// Copy 复制一个新的对象
func (my *FileSystem) Copy() *FileSystem <span class="cov8" title="1">{
        copied := *my

        return &amp;copied
}</span>

// SetDirByRelative 设置路径：相对路径
func (my *FileSystem) SetDirByRelative(dir string) *FileSystem <span class="cov0" title="0">{
        my.dir = filepath.Clean(filepath.Join(getRootPath(), dir))
        my.init()

        return my
}</span>

// SetDirByAbs 设置路径：绝对路径
func (my *FileSystem) SetDirByAbs(dir string) *FileSystem <span class="cov0" title="0">{
        my.dir = dir
        my.init()

        return my
}</span>

func (my *FileSystem) Join(dir string) *FileSystem <span class="cov8" title="1">{
        my.dir = filepath.Join(my.dir, dir)
        my.init()

        return my
}</span>

// Joins 增加若干路径
func (my *FileSystem) Joins(dir ...string) *FileSystem <span class="cov0" title="0">{
        for _, v := range dir </span><span class="cov0" title="0">{
                my.Join(v)
        }</span>

        <span class="cov0" title="0">my.init()

        return my</span>
}

func getRootPath() string <span class="cov8" title="1">{
        rootPath, _ := filepath.Abs(".")

        return rootPath
}</span>

// getCurrentPath 最终方案-全兼容
func getCurrentPath(paths ...string) string <span class="cov0" title="0">{
        dir := getGoBuildPath()

        if strings.Contains(dir, getTmpDir()) </span><span class="cov0" title="0">{
                return getGoRunPath()
        }</span>

        <span class="cov0" title="0">return dir</span>
}

// 获取系统临时目录，兼容go run
func getTmpDir() string <span class="cov0" title="0">{
        dir := os.Getenv("TEMP")

        if dir == "" </span><span class="cov0" title="0">{
                dir = os.Getenv("TMP")
        }</span>
        <span class="cov0" title="0">res, _ := filepath.EvalSymlinks(dir)

        return res</span>
}

// 获取当前执行文件绝对路径
func getGoBuildPath() string <span class="cov0" title="0">{
        exePath, err := os.Executable()

        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">res, _ := filepath.EvalSymlinks(filepath.Dir(exePath))

        return res</span>
}

// 获取当前执行文件绝对路径（go run）
func getGoRunPath() string <span class="cov0" title="0">{
        var abPath string
        _, filename, _, ok := runtime.Caller(0)

        if ok </span><span class="cov0" title="0">{
                abPath = path.Dir(filename)
        }</span>

        <span class="cov0" title="0">return abPath</span>
}

// 初始化
func (my *FileSystem) init() *FileSystem <span class="cov8" title="1">{
        var e error
        my.IsExist, e = my.Exist() // 检查文件是否存在
        if e != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("检查路径错误：%s", e.Error()))</span>
        }

        <span class="cov8" title="1">if my.IsExist </span><span class="cov8" title="1">{
                e = my.CheckPathType() // 检查路径类型
                if e != nil </span><span class="cov0" title="0">{
                        panic(fmt.Errorf("检查路径类型错误：%s", e.Error()))</span>
                }
        }

        <span class="cov8" title="1">return my</span>
}

// Exist 检查文件是否存在
func (my *FileSystem) Exist() (bool, error) <span class="cov8" title="1">{
        _, err := os.Stat(my.dir)
        if err == nil </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        <span class="cov8" title="1">if os.IsNotExist(err) </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov0" title="0">return false, err</span>
}

// IAmDir 检查当前路径是否是目录
func (my *FileSystem) IAmDir() (bool, error) <span class="cov0" title="0">{
        _, err := my.Exist()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">info, e := os.Stat(my.dir)
        if e != nil </span><span class="cov0" title="0">{
                return false, e
        }</span>

        <span class="cov0" title="0">return info.IsDir(), nil</span>
}

// IAmFile 检查当前路径是否是文件
func (my *FileSystem) IAmFile() (bool, error) <span class="cov0" title="0">{
        _, err := my.Exist()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">info, e := os.Stat(my.dir)
        if e != nil </span><span class="cov0" title="0">{
                return false, e
        }</span>

        <span class="cov0" title="0">return !info.IsDir(), nil</span>
}

// MkDir 创建文件夹
func (my *FileSystem) MkDir() error <span class="cov0" title="0">{
        if !my.IsExist </span><span class="cov0" title="0">{
                if e := os.MkdirAll(my.dir, os.ModePerm); e != nil </span><span class="cov0" title="0">{
                        return e
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetDir 获取当前路径
func (my *FileSystem) GetDir() string <span class="cov8" title="1">{ return my.dir }</span>

// CheckPathType 判断一个路径是文件还是文件夹
func (my *FileSystem) CheckPathType() error <span class="cov8" title="1">{
        info, e := os.Stat(my.dir)
        if e != nil </span><span class="cov0" title="0">{
                return e
        }</span>

        <span class="cov8" title="1">if info.IsDir() </span><span class="cov8" title="1">{
                my.IsDir = true
                my.IsFile = !my.IsDir
        }</span> else<span class="cov8" title="1"> {
                my.IsFile = true
                my.IsDir = !my.IsFile
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Delete 删除文件或文件夹
func (my *FileSystem) Delete() error <span class="cov0" title="0">{
        if my.IsExist </span><span class="cov0" title="0">{
                if my.IsDir </span><span class="cov0" title="0">{
                        return my.DelDir()
                }</span>
                <span class="cov0" title="0">if my.IsFile </span><span class="cov0" title="0">{
                        return my.DelFile()
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// DelDir 删除文件夹
func (my *FileSystem) DelDir() error <span class="cov0" title="0">{
        err := os.RemoveAll(my.dir)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DelFile 删除文件
func (my *FileSystem) DelFile() error <span class="cov0" title="0">{
        e := os.Remove(my.dir)
        if e != nil </span><span class="cov0" title="0">{
                return e
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Read 读取文件
func (my *FileSystem) Read() ([]byte, error) <span class="cov0" title="0">{ return os.ReadFile(my.dir) }</span>

// RenameFile 修改文件名并获取新的文件对象
func (my *FileSystem) RenameFile(newFilename string, deleteRepetition bool) (*FileSystem, error) <span class="cov0" title="0">{
        dir, _ := filepath.Split(my.GetDir())
        dst := FileSystemApp.NewByAbsolute(path.Join(dir, newFilename))

        if deleteRepetition </span><span class="cov0" title="0">{
                if dst.IsExist </span><span class="cov0" title="0">{
                        if err := dst.DelFile(); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
        }

        <span class="cov0" title="0">if err := os.Rename(my.GetDir(), dst.GetDir()); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return dst, nil</span>
}

// CopyFile 拷贝单文件
func (my *FileSystem) CopyFile(dstDir, dstFilename string, abs bool) (string, error) <span class="cov0" title="0">{
        var (
                err         error
                srcFile     *os.File
                srcFilename string
                dst         *FileSystem
        )

        // 如果是相对路径
        if !abs </span><span class="cov0" title="0">{
                dst = FileSystemApp.NewByRelative(dstDir)
        }</span> else<span class="cov0" title="0"> {
                dst = FileSystemApp.NewByAbsolute(dstDir)
        }</span>
        // 创建目标文件夹
        <span class="cov0" title="0">if !dst.IsDir </span><span class="cov0" title="0">{
                if err = dst.MkDir(); err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
        }

        // 判断源是否是文件
        <span class="cov0" title="0">if !my.IsFile </span><span class="cov0" title="0">{
                return "", fmt.Errorf("源文件不存在：%s", my.GetDir())
        }</span>

        // 打开源文件
        <span class="cov0" title="0">srcFile, err = os.Open(my.GetDir())
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer srcFile.Close()

        if dstFilename == "" </span><span class="cov0" title="0">{
                srcFilename = filepath.Base(my.GetDir())
                dst.Join(srcFilename)
        }</span> else<span class="cov0" title="0"> {
                dst.Join(dstFilename)
        }</span>

        // 创建目标文件
        <span class="cov0" title="0">dstFile, err := os.Create(dst.GetDir())
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer dstFile.Close()

        // 拷贝内容
        _, err = io.Copy(dstFile, srcFile)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 确保所有内容都已写入磁盘
        <span class="cov0" title="0">err = dstFile.Sync()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return dst.GetDir(), nil</span>
}

// CopyFiles 拷贝多个文件
func copyFiles(srcFiles []*FileSystemCopyFilesTarget, dstDir string, abs bool) error <span class="cov0" title="0">{
        var (
                err error
                dst *FileSystem
        )

        if abs </span><span class="cov0" title="0">{
                dst = FileSystemApp.NewByAbsolute(dstDir)
        }</span> else<span class="cov0" title="0"> {
                dst = FileSystemApp.NewByRelative(dstDir)
        }</span>

        <span class="cov0" title="0">if !dst.IsDir </span><span class="cov0" title="0">{
                if err = dst.MkDir(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">for _, srcFile := range srcFiles </span><span class="cov0" title="0">{
                // 获取源文件名
                srcFilename := filepath.Base(srcFile.Src.GetDir())

                // 拷贝文件
                if srcFile.DstFilename != "" </span><span class="cov0" title="0">{
                        _, err = srcFile.Src.CopyFile(dst.GetDir(), srcFile.DstFilename, true)
                }</span> else<span class="cov0" title="0"> {
                        _, err = srcFile.Src.CopyFile(dst.GetDir(), srcFilename, true)
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// CopyDir 拷贝目录
func (my *FileSystem) CopyDir(dstDir string, abs bool) error <span class="cov0" title="0">{
        // 判断是否是目录
        if !my.IsDir </span><span class="cov0" title="0">{
                return errors.New("源目录不存在")
        }</span>

        // 遍历源目录
        <span class="cov0" title="0">if err := filepath.Walk(my.GetDir(), func(srcPath string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                var (
                        src         *FileSystem
                        dst         *FileSystem
                        srcFilename string
                )

                if abs </span><span class="cov0" title="0">{
                        dst = FileSystemApp.NewByAbsolute(dstDir)
                }</span> else<span class="cov0" title="0"> {
                        dst = FileSystemApp.NewByRelative(dstDir)
                }</span>

                <span class="cov0" title="0">if !dst.IsDir </span><span class="cov0" title="0">{
                        if err = dst.MkDir(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">srcFilename = filepath.Base(srcPath)
                src = FileSystemApp.NewByAbsolute(srcPath)

                if src.IsFile </span><span class="cov0" title="0">{
                        if _, err = src.CopyFile(dst.GetDir(), srcFilename, true); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov0" title="0">return nil</span>
        }); err != nil <span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// WriteBytes 写入文件：bytes
func (my *FileSystem) WriteBytes(content []byte) (int64, error) <span class="cov0" title="0">{
        var written int
        // 打开文件
        file, err := os.OpenFile(my.GetDir(), os.O_RDWR|os.O_CREATE, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">defer func(file *os.File) </span><span class="cov0" title="0">{ _ = file.Close() }</span>(file)

        // 写入内容
        <span class="cov0" title="0">written, err = file.Write(content)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return int64(written), nil</span>
}

// WriteString 写入文件：string
func (my *FileSystem) WriteString(content string) (int64, error) <span class="cov0" title="0">{
        return my.WriteBytes([]byte(content))
}</span>

// WriteIoReader 写入文件：io.Reader
func (my *FileSystem) WriteIoReader(content io.Reader) (written int64, err error) <span class="cov0" title="0">{
        dst, err := os.Create(my.dir)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">defer func(dst *os.File) </span><span class="cov0" title="0">{ _ = dst.Close() }</span>(dst)

        <span class="cov0" title="0">return io.Copy(dst, content)</span>
}

// WriteBytesAppend 追加写入文件：bytes
func (my *FileSystem) WriteBytesAppend(content []byte) (int64, error) <span class="cov0" title="0">{
        var written int
        // Open the file in append mode.
        file, e := os.OpenFile(my.GetDir(), os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
        if e != nil </span><span class="cov0" title="0">{
                return 0, e
        }</span>
        <span class="cov0" title="0">defer func(file *os.File) </span><span class="cov0" title="0">{ _ = file.Close() }</span>(file)

        // 追加写入内容
        <span class="cov0" title="0">written, e = file.Write(content)
        if e != nil </span><span class="cov0" title="0">{
                return 0, e
        }</span>

        <span class="cov0" title="0">return int64(written), nil</span>
}

// WriteStringAppend 追加写入文件：string
func (my *FileSystem) WriteStringAppend(content string) (int64, error) <span class="cov0" title="0">{
        return my.WriteBytesAppend([]byte(content))
}</span>

// WriteIoReaderAppend 追加写入文件：io.Reader
func (my *FileSystem) WriteIoReaderAppend(content io.Reader) (int64, error) <span class="cov0" title="0">{
        var written int
        dst, err := os.OpenFile(my.dir, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">defer func(dst *os.File) </span><span class="cov0" title="0">{ _ = dst.Close() }</span>(dst)

        <span class="cov0" title="0">c, err := io.ReadAll(content)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">written, err = dst.Write(c)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return int64(written), nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package filesystemV2

import (
        "os"
        "path"
        "path/filepath"
        "sync"

        "github.com/aid297/aid/array"
)

type (
        Dir struct {
                err      error                  // 错误信息
                name     string                 // 文件名
                basePath string                 // 基础路径
                fullPath string                 // 完整路径
                size     int64                  // 文件大小
                info     os.FileInfo            // 文件信息
                mode     os.FileMode            // 文件权限
                exist    bool                   // 文件是否存在
                mu       sync.RWMutex           // 读写锁
                files    *array.AnyArray[*File] // 目录下的文件
                dirs     *array.AnyArray[*Dir]  // 目录下的文件夹
        }
        DirCollection struct {
                Dirs  []*Dir
                Files []*File
        }
)

var DirApp Dir

// WhoAmI 获取当前类型：（目录）
func (*Dir) WhoAmI() FilesystemV2Type <span class="cov0" title="0">{ return FilesystemV2Dir }</span>

// NewByAbs 实例化：通过绝对路径
func (*Dir) NewByAbs(paths ...string) *Dir <span class="cov8" title="1">{
        ins := &amp;Dir{fullPath: filepath.Join(paths...), files: array.Make[*File](0), dirs: array.Make[*Dir](0)}
        ins.refresh()

        return ins
}</span>

// NewByRel 实例化：通过相对路径
func (*Dir) NewByRel(paths ...string) *Dir <span class="cov8" title="1">{
        ins := &amp;Dir{fullPath: getRootPath(filepath.Join(paths...)), files: array.Make[*File](0), dirs: array.Make[*Dir](0)}
        ins.refresh()

        return ins
}</span>

// Lock 加锁：写锁
func (my *Dir) Lock() *Dir <span class="cov0" title="0">{
        my.mu.Lock()
        return my
}</span>

// Unlock 解锁：写锁
func (my *Dir) Unlock() *Dir <span class="cov0" title="0">{
        my.mu.Unlock()
        return my
}</span>

// RLock 加锁：读锁
func (my *Dir) RLock() *Dir <span class="cov0" title="0">{
        my.mu.RLock()
        return my
}</span>

// RUnlock 解锁：读锁
func (my *Dir) RUnlock() *Dir <span class="cov0" title="0">{
        my.mu.RUnlock()
        return my
}</span>

// getName 获取文件名
func (my *Dir) getName() string <span class="cov0" title="0">{ return my.name }</span>

// GetName 获取文件名
func (my *Dir) GetName() string <span class="cov0" title="0">{
        my.mu.RLock()
        defer my.mu.RUnlock()

        return my.getName()
}</span>

// getBasePath 获取基础路径
func (my *Dir) getBasePath() string <span class="cov0" title="0">{ return my.basePath }</span>

// GetBasePath 获取基础路径
func (my *Dir) GetBasePath() string <span class="cov0" title="0">{
        my.mu.RLock()
        defer my.mu.RUnlock()

        return my.getBasePath()
}</span>

// getFullPath 获取完整路径
func (my *Dir) getFullPath() string <span class="cov8" title="1">{ return my.fullPath }</span>

// GetFullPath 获取完整路径
func (my *Dir) GetFullPath() string <span class="cov8" title="1">{
        my.mu.RLock()
        defer my.mu.RUnlock()

        return my.getFullPath()
}</span>

// getSize 获取文件夹大小
func (my *Dir) getSize() int64 <span class="cov0" title="0">{ return my.size }</span>

// GetSize 获取文件夹大小
func (my *Dir) GetSize() int64 <span class="cov0" title="0">{
        my.mu.RLock()
        defer my.mu.RUnlock()

        return my.getSize()
}</span>

// getInfo 获取文件夹信息
func (my *Dir) getInfo() os.FileInfo <span class="cov0" title="0">{ return my.info }</span>

// GetInfo 获取文件夹信息
func (my *Dir) GetInfo() os.FileInfo <span class="cov0" title="0">{
        my.mu.RLock()
        defer my.mu.RUnlock()

        return my.getInfo()
}</span>

// getMode 获取文件夹权限
func (my *Dir) getMode() os.FileMode <span class="cov0" title="0">{ return my.mode }</span>

// GetMode 获取文件夹权限
func (my *Dir) GetMode() os.FileMode <span class="cov0" title="0">{
        my.mu.RLock()
        defer my.mu.RUnlock()

        return my.getMode()
}</span>

// getExist 获取目录是否存在
func (my *Dir) getExist() bool <span class="cov8" title="1">{ return my.exist }</span>

// GetExist 获取目录是否存在
func (my *Dir) GetExist() bool <span class="cov8" title="1">{
        my.mu.RLock()
        defer my.mu.RUnlock()

        return my.getExist()
}</span>

// Error 获取错误
func (my *Dir) Error() error <span class="cov0" title="0">{ return my.err }</span>

// copy 复制当前对象
func (my *Dir) copy() *Dir <span class="cov8" title="1">{ return DirApp.NewByAbs(my.fullPath) }</span>

// Copy 复制当前对象
func (my *Dir) Copy() *Dir <span class="cov8" title="1">{
        my.mu.Lock()
        defer my.mu.Unlock()

        return my.copy()
}</span>

// refresh 刷新目录信息
func (my *Dir) refresh() <span class="cov8" title="1">{
        if my.fullPath != "" </span><span class="cov8" title="1">{
                if my.info, my.err = os.Stat(my.fullPath); my.err != nil </span><span class="cov8" title="1">{
                        if os.IsNotExist(my.err) </span><span class="cov8" title="1">{
                                my.name = ""
                                my.size = 0
                                my.mode = 0
                                my.basePath = path.Dir(my.fullPath)
                                my.exist = false
                                my.err = nil
                                return
                        }</span> else<span class="cov0" title="0"> {
                                my.err = DirInitErr.Wrap(my.err)
                                return
                        }</span>
                }

                <span class="cov8" title="1">my.name = my.info.Name()
                my.size = my.info.Size()
                my.mode = my.info.Mode()
                my.basePath = path.Dir(my.fullPath)
                my.exist = true
                my.err = nil</span>
        } else<span class="cov0" title="0"> {
                my.err = DirFullPathEmptyErr.New("")
        }</span>
}

// create 新建目录
func (my *Dir) create(mode os.FileMode) <span class="cov0" title="0">{
        if my.fullPath == "" </span><span class="cov0" title="0">{
                my.err = DirFullPathEmptyErr.New("")
                return
        }</span>

        <span class="cov0" title="0">err := os.MkdirAll(my.fullPath, mode)
        if err != nil </span><span class="cov0" title="0">{
                my.err = err
                return
        }</span>

        <span class="cov0" title="0">my.err = nil</span>
}

// Create 新建目录
func (my *Dir) Create(mode os.FileMode) *Dir <span class="cov0" title="0">{
        my.mu.Lock()
        defer my.mu.Unlock()
        defer my.refresh()

        my.create(mode)

        return my
}</span>

// CreateDefaultMode 新建目录：默认权限
func (my *Dir) CreateDefaultMode() *Dir <span class="cov0" title="0">{
        my.mu.Lock()
        defer my.mu.Unlock()
        defer my.refresh()

        my.create(os.ModePerm)

        return my
}</span>

// 修改文件名
func (my *Dir) rename(newName string) <span class="cov0" title="0">{
        if my.fullPath == "" </span><span class="cov0" title="0">{
                my.err = DirFullPathEmptyErr.New("")
                return
        }</span>

        <span class="cov0" title="0">newPath := filepath.Join(filepath.Dir(my.fullPath), newName)
        err := os.Rename(my.fullPath, newPath)
        if err != nil </span><span class="cov0" title="0">{
                my.err = err
                return
        }</span>

        <span class="cov0" title="0">my.fullPath = newPath
        my.err = nil</span>
}

// Rename 文件夹重命名
func (my *Dir) Rename(newName string) *Dir <span class="cov0" title="0">{
        my.mu.Lock()
        defer my.mu.Unlock()
        defer my.refresh()

        my.rename(newName)

        return my
}</span>

func (my *Dir) removeAll() <span class="cov0" title="0">{ my.err = os.RemoveAll(my.fullPath) }</span>

func (my *Dir) RemoveAll() *Dir <span class="cov0" title="0">{
        my.mu.Lock()
        defer my.mu.Unlock()
        defer my.refresh()

        my.removeAll()

        return my
}</span>

// remove 删除目录
func (my *Dir) remove() <span class="cov0" title="0">{ my.err = os.Remove(my.fullPath) }</span>

// Remove 删除目录
func (my *Dir) Remove() *Dir <span class="cov0" title="0">{
        my.mu.Lock()
        defer my.mu.Unlock()
        defer my.refresh()

        my.remove()

        return my
}</span>

// checkPermission 检查目录权限
func (my *Dir) checkPermission(mode os.FileMode) bool <span class="cov0" title="0">{ return my.mode == mode }</span>

// CheckPermission 检查目录权限
func (my *Dir) CheckPermission(mode os.FileMode) bool <span class="cov0" title="0">{
        my.mu.RLock()
        defer my.mu.RUnlock()

        return my.checkPermission(mode)
}</span>

// join 添加路径
func (my *Dir) join(path string) <span class="cov8" title="1">{ my.fullPath = filepath.Join(my.fullPath, path) }</span>

// Join 添加路径
func (my *Dir) Join(path string) *Dir <span class="cov8" title="1">{
        my.mu.Lock()
        defer my.mu.Unlock()
        defer my.refresh()

        my.join(path)

        return my
}</span>

// joins 添加多个路径
func (my *Dir) joins(paths ...string) <span class="cov0" title="0">{
        my.fullPath = filepath.Join(my.fullPath, filepath.Join(paths...))
}</span>

// Joins 添加多个路径
func (my *Dir) Joins(paths ...string) *Dir <span class="cov0" title="0">{
        my.mu.Lock()
        defer my.mu.Unlock()
        defer my.refresh()

        my.joins(paths...)

        return my
}</span>

// ls 获取当前目录内容
func (my *Dir) ls() <span class="cov8" title="1">{
        var entries []os.DirEntry

        entries, my.err = os.ReadDir(my.fullPath)
        if my.err != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">for _, entry := range entries </span><span class="cov8" title="1">{
                if entry.IsDir() </span><span class="cov8" title="1">{
                        d := DirApp.NewByAbs(my.fullPath).Join(entry.Name())
                        my.dirs.Append(d.Ls())
                }</span> else<span class="cov8" title="1"> {
                        my.files.Append(FileApp.NewByAbs(filepath.Join(my.fullPath, entry.Name())))
                }</span>
        }
}

// Ls 获取当前目录内容
func (my *Dir) Ls() *Dir <span class="cov8" title="1">{
        my.mu.RLock()
        defer my.mu.RUnlock()

        my.ls()

        return my
}</span>

// getDirs 获取当前目录下所有文件夹
func (my *Dir) getDirs() *array.AnyArray[*Dir] <span class="cov8" title="1">{
        if my.dirs.IsEmpty() </span><span class="cov8" title="1">{
                my.ls()
        }</span>

        <span class="cov8" title="1">return my.dirs</span>
}

// GetDirs 获取当前目录下所有文件夹
func (my *Dir) GetDirs() *array.AnyArray[*Dir] <span class="cov8" title="1">{
        my.mu.RLock()
        defer my.mu.RUnlock()

        return my.getDirs()
}</span>

// getFiles 获取当前目录下所有文件
func (my *Dir) getFiles() *array.AnyArray[*File] <span class="cov8" title="1">{
        if my.files.IsEmpty() </span><span class="cov8" title="1">{
                my.ls()
        }</span>

        <span class="cov8" title="1">return my.files</span>
}

// GetFiles 获取当前目录下所有文件
func (my *Dir) GetFiles() *array.AnyArray[*File] <span class="cov8" title="1">{
        my.mu.RLock()
        defer my.mu.RUnlock()

        return my.getFiles()
}</span>

// copyAllFilesTo 复制所有文件
func (my *Dir) copyAllFilesTo(dstDir string) <span class="cov8" title="1">{
        if !my.getExist() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">dst := DirApp.NewByAbs(dstDir)
        if !dst.getExist() </span><span class="cov0" title="0">{
                dst.create(os.ModePerm)
        }</span>

        <span class="cov8" title="1">my.getFiles().Each(func(idx int, item *File) </span><span class="cov8" title="1">{ item.CopyTo(dst.Copy().Join(item.getName()).GetFullPath()) }</span>)
}

// CopyAllFilesTo 复制所有文件
func (my *Dir) CopyAllFilesTo(dstDir string) *Dir <span class="cov8" title="1">{
        my.mu.Lock()
        defer my.mu.Unlock()
        defer my.refresh()

        my.copyAllFilesTo(dstDir)

        return my
}</span>

// copyAllDirsTo 复制目录下所有文件夹及文件
func (my *Dir) copyAllDirsTo(dstDir string) <span class="cov8" title="1">{
        if !my.getExist() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov0" title="0">dst := DirApp.NewByAbs(dstDir)
        if !dst.getExist() </span><span class="cov0" title="0">{
                dst.create(os.ModePerm)
        }</span>

        <span class="cov0" title="0">if my.getFiles().IsNotEmpty() </span><span class="cov0" title="0">{
                my.copyAllFilesTo(dst.Join(my.getName()).Create(my.getMode()).GetFullPath())
        }</span>

        <span class="cov0" title="0">if my.getDirs().IsNotEmpty() </span><span class="cov0" title="0">{
                my.dirs.Each(func(idx int, item *Dir) </span><span class="cov0" title="0">{
                        dstFullPath := dst.Copy().Join(item.getName()).Create(item.getMode()).GetFullPath()
                        if item.files.IsNotEmpty() </span><span class="cov0" title="0">{
                                item.copyAllFilesTo(dstFullPath)
                        }</span>
                })
        }
}

// CopyAllDirsTo 复制目录下所有文件夹及文件
func (my *Dir) CopyAllDirsTo(dstDir string) *Dir <span class="cov8" title="1">{
        my.mu.Lock()
        defer my.mu.Unlock()
        defer my.refresh()

        my.copyAllDirsTo(dstDir)

        return my
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package filesystemV2

import (
        "fmt"
        "reflect"

        "github.com/aid297/aid/array"
        "github.com/aid297/aid/myError"
        "github.com/aid297/aid/operation"
)

type (
        FileInitError          struct{ myError.MyError }
        FileNotExistsError     struct{ myError.MyError }
        FileFullPathEmptyError struct{ myError.MyError }
        CreateFileError        struct{ myError.MyError }
        RenameFileError        struct{ myError.MyError }
        RemoveFileError        struct{ myError.MyError }
        PermissionFileError    struct{ myError.MyError }
        CopyFileError          struct{ myError.MyError }
        CopyFileSrcError       struct{ myError.MyError }
        CopyFileDstError       struct{ myError.MyError }
        WriteFileError         struct{ myError.MyError }
        ReadFileError          struct{ myError.MyError }

        DirInitError          struct{ myError.MyError }
        DirNotExistsError     struct{ myError.MyError }
        DirFullPathEmptyError struct{ myError.MyError }
        CreateDirError        struct{ myError.MyError }
        RenameDirError        struct{ myError.MyError }
        RemoveDirError        struct{ myError.MyError }
        PermissionDirError    struct{ myError.MyError }
        CopyDirError          struct{ myError.MyError }
        CopyDirSrcError       struct{ myError.MyError }
        CopyDirDstError       struct{ myError.MyError }
        WriteDirError         struct{ myError.MyError }
        ReadDirError          struct{ myError.MyError }
)

var (
        FileInitErr          FileInitError
        FileNotExistsErr     FileNotExistsError
        FileFullPathEmptyErr FileFullPathEmptyError
        CreateFileErr        CreateFileError
        RenameFileErr        RenameFileError
        RemoveFileErr        RemoveFileError
        PermissionFileErr    PermissionFileError
        CopyFileErr          CopyFileError
        CopyFileSrcErr       CopyFileSrcError
        CopyFileDstErr       CopyFileDstError
        WriteFileErr         WriteFileError
        ReadFileErr          ReadFileError

        DirInitErr          DirInitError
        DirNotExistsErr     DirNotExistsError
        DirFullPathEmptyErr DirFullPathEmptyError
        CreateDirErr        CreateDirError
        RenameDirErr        RenameDirError
        RemoveDirErr        RemoveDirError
        PermissionDirErr    PermissionDirError
        CopyDirErr          CopyDirError
        CopyDirSrcErr       CopyDirSrcError
        CopyDirDstErr       CopyDirDstError
        WriteDirErr         WriteDirError
        ReadDirErr          ReadDirError
)

func (*FileInitError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;FileInitError{MyError: myError.MyError{Msg: array.NewDestruction("文件初始化错误", msg).JoinWithoutEmpty("：")}}
}</span>

func (*FileInitError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;FileInitError{MyError: myError.MyError{Msg: fmt.Errorf("文件初始化错误"+operation.Ternary(err != nil, "：%w", "%w"), err).Error()}}
}</span>

func (*FileInitError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;FileInitError{MyError: myError.MyError{Msg: "文件初始化错误"}}
}</span>

func (my *FileInitError) Error() string <span class="cov0" title="0">{ return my.Msg }</span>

func (*FileInitError) Is(target error) bool <span class="cov0" title="0">{ return reflect.DeepEqual(target, &amp;FileNotExistsErr) }</span>

func (*FileNotExistsError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;FileNotExistsError{MyError: myError.MyError{Msg: array.NewDestruction("文件不存在", msg).JoinWithoutEmpty("：")}}
}</span>

func (*FileNotExistsError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;FileNotExistsError{MyError: myError.MyError{Msg: fmt.Errorf("文件不存在"+operation.Ternary(err != nil, "：%w", "%w"), err).Error()}}
}</span>

func (*FileNotExistsError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;FileNotExistsError{MyError: myError.MyError{Msg: "文件不存在"}}
}</span>

func (my *FileNotExistsError) Error() string <span class="cov0" title="0">{ return my.Msg }</span>

func (*FileNotExistsError) Is(target error) bool <span class="cov0" title="0">{ return reflect.DeepEqual(target, &amp;FileNotExistsErr) }</span>

func (*FileFullPathEmptyError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;FileFullPathEmptyError{MyError: myError.MyError{Msg: "文件路径不能为空"}}
}</span>

func (*FileFullPathEmptyError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;FileFullPathEmptyError{MyError: myError.MyError{Msg: "文件路径不能为空"}}
}</span>

func (*FileFullPathEmptyError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;FileFullPathEmptyError{MyError: myError.MyError{Msg: "文件路径不能为空"}}
}</span>

func (my *FileFullPathEmptyError) Error() string <span class="cov0" title="0">{ return my.Msg }</span>

func (*FileFullPathEmptyError) Is(target error) bool <span class="cov0" title="0">{
        return reflect.DeepEqual(target, &amp;FileFullPathEmptyErr)
}</span>

func (*CreateFileError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;FileFullPathEmptyError{MyError: myError.MyError{Msg: array.NewDestruction("创建文件失败", msg).JoinWithoutEmpty("：")}}
}</span>

func (*CreateFileError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;CreateFileError{MyError: myError.MyError{Msg: fmt.Errorf("创建文件失败"+operation.Ternary(err != nil, "：%w", "%w"), err).Error()}}
}</span>

func (*CreateFileError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;CreateFileError{MyError: myError.MyError{Msg: "创建文件失败"}}
}</span>

func (my *CreateFileError) Error() string <span class="cov0" title="0">{ return my.Msg }</span>

func (*CreateFileError) Is(target error) bool <span class="cov0" title="0">{
        return reflect.DeepEqual(target, &amp;CreateFileErr)
}</span>

func (*RenameFileError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;RenameFileError{MyError: myError.MyError{Msg: array.NewDestruction("修改文件名失败", msg).JoinWithoutEmpty("：")}}
}</span>

func (*RenameFileError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;RenameFileError{MyError: myError.MyError{Msg: fmt.Errorf("修改文件名失败"+operation.Ternary(err != nil, "：%w", "%w"), err).Error()}}
}</span>

func (*RenameFileError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;RenameFileError{MyError: myError.MyError{Msg: "修改文件名失败"}}
}</span>

func (my *RenameFileError) Error() string <span class="cov0" title="0">{ return my.Msg }</span>

func (*RenameFileError) Is(target error) bool <span class="cov0" title="0">{
        return reflect.DeepEqual(target, &amp;RenameFileErr)
}</span>

func (*RemoveFileError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;RemoveFileError{MyError: myError.MyError{Msg: array.NewDestruction("删除文件失败", msg).JoinWithoutEmpty("：")}}
}</span>

func (*RemoveFileError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;RemoveFileError{MyError: myError.MyError{Msg: fmt.Errorf("删除文件失败"+operation.Ternary(err != nil, "：%w", "%w"), err).Error()}}
}</span>

func (*RemoveFileError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;RemoveFileError{MyError: myError.MyError{Msg: "删除文件失败"}}
}</span>

func (my *RemoveFileError) Error() string <span class="cov0" title="0">{ return my.Msg }</span>

func (*RemoveFileError) Is(target error) bool <span class="cov0" title="0">{
        return reflect.DeepEqual(target, &amp;RemoveFileErr)
}</span>

func (*PermissionFileError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;PermissionFileError{MyError: myError.MyError{Msg: array.New([]string{"文件权限错误", msg}).JoinWithoutEmpty("：")}}
}</span>

func (*PermissionFileError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;PermissionFileError{MyError: myError.MyError{Msg: fmt.Errorf("文件权限错误"+operation.Ternary(err != nil, "：%w", "%w"), err).Error()}}
}</span>

func (*PermissionFileError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;PermissionFileError{MyError: myError.MyError{Msg: "文件权限错误"}}
}</span>

func (my *PermissionFileError) Error() string <span class="cov0" title="0">{ return my.Msg }</span>

func (*PermissionFileError) Is(target error) bool <span class="cov0" title="0">{
        return reflect.DeepEqual(target, &amp;PermissionFileErr)
}</span>

func (*CopyFileSrcError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;CopyFileSrcError{MyError: myError.MyError{Msg: array.NewDestruction("复制文件时打开源文件错误", msg).JoinWithoutEmpty("：")}}
}</span>

func (*CopyFileSrcError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;CopyFileSrcError{MyError: myError.MyError{Msg: fmt.Errorf("复制文件时打开源文件错误"+operation.Ternary(err != nil, "：%w", "%w"), err).Error()}}
}</span>

func (*CopyFileSrcError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;CopyFileSrcError{MyError: myError.MyError{Msg: "复制文件时打开源文件错误"}}
}</span>

func (my *CopyFileSrcError) Error() string <span class="cov0" title="0">{ return my.Msg }</span>

func (*CopyFileSrcError) Is(target error) bool <span class="cov0" title="0">{
        return reflect.DeepEqual(target, &amp;CopyFileSrcErr)
}</span>

func (*CopyFileDstError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;CopyFileDstError{MyError: myError.MyError{Msg: array.NewDestruction("复制文件时打开目标文件错误", msg).JoinWithoutEmpty("：")}}
}</span>

func (*CopyFileDstError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;CopyFileDstError{MyError: myError.MyError{Msg: fmt.Errorf("复制文件时打开目标文件错误"+operation.Ternary(err != nil, "：%w", "%w"), err).Error()}}
}</span>

func (*CopyFileDstError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;CopyFileDstError{MyError: myError.MyError{Msg: "复制文件时打开目标文件错误"}}
}</span>

func (my *CopyFileDstError) Error() string <span class="cov0" title="0">{ return my.Msg }</span>

func (*CopyFileDstError) Is(target error) bool <span class="cov0" title="0">{
        return reflect.DeepEqual(target, &amp;CopyFileDstErr)
}</span>

func (*CopyFileError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;CopyFileError{MyError: myError.MyError{Msg: array.NewDestruction("复制文件错误", msg).JoinWithoutEmpty("：")}}
}</span>

func (*CopyFileError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;CopyFileError{MyError: myError.MyError{Msg: fmt.Errorf("复制文件错误"+operation.Ternary(err != nil, "：%w", "%w"), err).Error()}}
}</span>

func (*CopyFileError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;CopyFileError{MyError: myError.MyError{Msg: "复制文件错误"}}
}</span>

func (my *CopyFileError) Error() string <span class="cov0" title="0">{ return my.Msg }</span>

func (*CopyFileError) Is(target error) bool <span class="cov0" title="0">{
        return reflect.DeepEqual(target, &amp;CopyFileErr)
}</span>

func (*WriteFileError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;WriteFileError{MyError: myError.MyError{Msg: array.NewDestruction("写入文件错误", msg).JoinWithoutEmpty("：")}}
}</span>

func (*WriteFileError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;WriteFileError{MyError: myError.MyError{Msg: fmt.Errorf("写入文件错误"+operation.Ternary(err != nil, "：%w", "%w"), err).Error()}}
}</span>

func (*WriteFileError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;WriteFileError{MyError: myError.MyError{Msg: "写入文件错误"}}
}</span>

func (my *WriteFileError) Error() string <span class="cov0" title="0">{ return my.Msg }</span>

func (*WriteFileError) Is(target error) bool <span class="cov0" title="0">{
        return reflect.DeepEqual(target, &amp;WriteFileErr)
}</span>

func (*ReadFileError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;ReadFileError{MyError: myError.MyError{Msg: array.NewDestruction("读取文件错误", msg).JoinWithoutEmpty("：")}}
}</span>

func (*ReadFileError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;ReadFileError{MyError: myError.MyError{Msg: fmt.Errorf("读取文件错误"+operation.Ternary(err != nil, "：%w", "%w"), err).Error()}}
}</span>

func (*ReadFileError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;ReadFileError{MyError: myError.MyError{Msg: "读取文件错误"}}
}</span>

func (my *ReadFileError) Error() string <span class="cov0" title="0">{ return my.Msg }</span>

func (*ReadFileError) Is(target error) bool <span class="cov0" title="0">{
        return reflect.DeepEqual(target, &amp;ReadFileErr)
}</span>

func (*DirInitError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;DirInitError{MyError: myError.MyError{Msg: array.NewDestruction("目录初始化错误", msg).JoinWithoutEmpty("：")}}
}</span>

func (*DirInitError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;DirInitError{MyError: myError.MyError{Msg: fmt.Errorf("目录初始化错误"+operation.Ternary(err != nil, "：%w", "%w"), err).Error()}}
}</span>

func (*DirInitError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;DirInitError{MyError: myError.MyError{Msg: "目录初始化错误"}}
}</span>

func (my *DirInitError) Error() string <span class="cov0" title="0">{ return my.Msg }</span>

func (*DirInitError) Is(target error) bool <span class="cov0" title="0">{ return reflect.DeepEqual(target, &amp;DirNotExistsErr) }</span>

func (*DirNotExistsError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;DirNotExistsError{MyError: myError.MyError{Msg: array.NewDestruction("目录不存在", msg).JoinWithoutEmpty("：")}}
}</span>

func (*DirNotExistsError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;DirNotExistsError{MyError: myError.MyError{Msg: fmt.Errorf("目录不存在"+operation.Ternary(err != nil, "：%w", "%w"), err).Error()}}
}</span>

func (*DirNotExistsError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;DirNotExistsError{MyError: myError.MyError{Msg: "目录不存在"}}
}</span>

func (my *DirNotExistsError) Error() string <span class="cov0" title="0">{ return my.Msg }</span>

func (*DirNotExistsError) Is(target error) bool <span class="cov0" title="0">{ return reflect.DeepEqual(target, &amp;DirNotExistsErr) }</span>

func (*DirFullPathEmptyError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;DirFullPathEmptyError{MyError: myError.MyError{Msg: "目录路径不能为空"}}
}</span>

func (*DirFullPathEmptyError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;DirFullPathEmptyError{MyError: myError.MyError{Msg: "目录路径不能为空"}}
}</span>

func (*DirFullPathEmptyError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;DirFullPathEmptyError{MyError: myError.MyError{Msg: "目录路径不能为空"}}
}</span>

func (my *DirFullPathEmptyError) Error() string <span class="cov0" title="0">{ return my.Msg }</span>

func (*DirFullPathEmptyError) Is(target error) bool <span class="cov0" title="0">{
        return reflect.DeepEqual(target, &amp;DirFullPathEmptyErr)
}</span>

func (*CreateDirError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;DirFullPathEmptyError{MyError: myError.MyError{Msg: array.NewDestruction("创建目录失败", msg).JoinWithoutEmpty("：")}}
}</span>

func (*CreateDirError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;CreateDirError{MyError: myError.MyError{Msg: fmt.Errorf("创建目录失败"+operation.Ternary(err != nil, "：%w", "%w"), err).Error()}}
}</span>

func (*CreateDirError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;CreateDirError{MyError: myError.MyError{Msg: "创建目录失败"}}
}</span>

func (my *CreateDirError) Error() string <span class="cov0" title="0">{ return my.Msg }</span>

func (*CreateDirError) Is(target error) bool <span class="cov0" title="0">{ return reflect.DeepEqual(target, &amp;CreateDirErr) }</span>

func (*RenameDirError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;RenameDirError{MyError: myError.MyError{Msg: array.NewDestruction("修改目录名失败", msg).JoinWithoutEmpty("：")}}
}</span>

func (*RenameDirError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;RenameDirError{MyError: myError.MyError{Msg: fmt.Errorf("修改目录名失败"+operation.Ternary(err != nil, "：%w", "%w"), err).Error()}}
}</span>

func (*RenameDirError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;RenameDirError{MyError: myError.MyError{Msg: "修改目录名失败"}}
}</span>

func (my *RenameDirError) Error() string <span class="cov0" title="0">{ return my.Msg }</span>

func (*RenameDirError) Is(target error) bool <span class="cov0" title="0">{ return reflect.DeepEqual(target, &amp;RenameDirErr) }</span>

func (*RemoveDirError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;RemoveDirError{MyError: myError.MyError{Msg: array.NewDestruction("删除目录失败", msg).JoinWithoutEmpty("：")}}
}</span>

func (*RemoveDirError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;RemoveDirError{MyError: myError.MyError{Msg: fmt.Errorf("删除目录失败"+operation.Ternary(err != nil, "：%w", "%w"), err).Error()}}
}</span>

func (*RemoveDirError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;RemoveDirError{MyError: myError.MyError{Msg: "删除目录失败"}}
}</span>

func (my *RemoveDirError) Error() string <span class="cov0" title="0">{ return my.Msg }</span>

func (*RemoveDirError) Is(target error) bool <span class="cov0" title="0">{ return reflect.DeepEqual(target, &amp;RemoveDirErr) }</span>

func (*PermissionDirError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;PermissionDirError{MyError: myError.MyError{Msg: array.NewDestruction("目录权限错误", msg).JoinWithoutEmpty("：")}}
}</span>

func (*PermissionDirError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;PermissionDirError{MyError: myError.MyError{Msg: fmt.Errorf("目录权限错误"+operation.Ternary(err != nil, "：%w", "%w"), err).Error()}}
}</span>

func (*PermissionDirError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;PermissionDirError{MyError: myError.MyError{Msg: "目录权限错误"}}
}</span>

func (my *PermissionDirError) Error() string <span class="cov0" title="0">{ return my.Msg }</span>

func (*PermissionDirError) Is(target error) bool <span class="cov0" title="0">{ return reflect.DeepEqual(target, &amp;PermissionDirErr) }</span>

func (*CopyDirSrcError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;CopyDirSrcError{MyError: myError.MyError{Msg: array.NewDestruction("复制目录时打开源目录错误", msg).JoinWithoutEmpty("：")}}
}</span>

func (*CopyDirSrcError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;CopyDirSrcError{MyError: myError.MyError{Msg: fmt.Errorf("复制目录时打开源目录错误"+operation.Ternary(err != nil, "：%w", "%w"), err).Error()}}
}</span>

func (*CopyDirSrcError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;CopyDirSrcError{MyError: myError.MyError{Msg: "复制目录时打开源目录错误"}}
}</span>

func (my *CopyDirSrcError) Error() string <span class="cov0" title="0">{ return my.Msg }</span>

func (*CopyDirSrcError) Is(target error) bool <span class="cov0" title="0">{ return reflect.DeepEqual(target, &amp;CopyDirSrcErr) }</span>

func (*CopyDirDstError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;CopyDirDstError{MyError: myError.MyError{Msg: array.NewDestruction("复制目录时打开目标目录错误", msg).JoinWithoutEmpty("：")}}
}</span>

func (*CopyDirDstError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;CopyDirDstError{MyError: myError.MyError{Msg: fmt.Errorf("复制目录时打开目标目录错误"+operation.Ternary(err != nil, "：%w", "%w"), err).Error()}}
}</span>

func (*CopyDirDstError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;CopyDirDstError{MyError: myError.MyError{Msg: "复制目录时打开目标目录错误"}}
}</span>

func (my *CopyDirDstError) Error() string <span class="cov0" title="0">{ return my.Msg }</span>

func (*CopyDirDstError) Is(target error) bool <span class="cov0" title="0">{ return reflect.DeepEqual(target, &amp;CopyDirDstErr) }</span>

func (*CopyDirError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;CopyDirError{MyError: myError.MyError{Msg: array.NewDestruction("复制目录错误", msg).JoinWithoutEmpty("：")}}
}</span>

func (*CopyDirError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;CopyDirError{MyError: myError.MyError{Msg: fmt.Errorf("复制目录错误"+operation.Ternary(err != nil, "：%w", "%w"), err).Error()}}
}</span>

func (*CopyDirError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;CopyDirError{MyError: myError.MyError{Msg: "复制目录错误"}}
}</span>

func (my *CopyDirError) Error() string <span class="cov0" title="0">{ return my.Msg }</span>

func (*CopyDirError) Is(target error) bool <span class="cov0" title="0">{ return reflect.DeepEqual(target, &amp;CopyDirErr) }</span>

func (*WriteDirError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;WriteDirError{MyError: myError.MyError{Msg: array.NewDestruction("写入目录错误", msg).JoinWithoutEmpty("：")}}
}</span>

func (*WriteDirError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;WriteDirError{MyError: myError.MyError{Msg: fmt.Errorf("写入目录错误"+operation.Ternary(err != nil, "：%w", "%w"), err).Error()}}
}</span>

func (*WriteDirError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;WriteDirError{MyError: myError.MyError{Msg: "写入目录错误"}}
}</span>

func (my *WriteDirError) Error() string <span class="cov0" title="0">{ return my.Msg }</span>

func (*WriteDirError) Is(target error) bool <span class="cov0" title="0">{ return reflect.DeepEqual(target, &amp;WriteDirErr) }</span>

func (*ReadDirError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;ReadDirError{MyError: myError.MyError{Msg: array.NewDestruction("读取目录错误", msg).JoinWithoutEmpty("：")}}
}</span>

func (*ReadDirError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;ReadDirError{MyError: myError.MyError{Msg: fmt.Errorf("读取目录错误"+operation.Ternary(err != nil, "：%w", "%w"), err).Error()}}
}</span>

func (*ReadDirError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;ReadDirError{MyError: myError.MyError{Msg: "读取目录错误"}}
}</span>

func (my *ReadDirError) Error() string <span class="cov0" title="0">{ return my.Msg }</span>

func (*ReadDirError) Is(target error) bool <span class="cov0" title="0">{ return reflect.DeepEqual(target, &amp;ReadDirErr) }</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package filesystemV2

import (
        "io"
        "os"
        "path"
        "path/filepath"
        "sync"
)

type File struct {
        err       error        // 错误信息
        name      string       // 文件名
        basePath  string       // 基础路径
        fullPath  string       // 完整路径
        extension string       // 文件扩展名
        size      int64        // 文件大小
        fileInfo  os.FileInfo  // 文件信息
        mode      os.FileMode  // 文件权限
        exist     bool         // 文件是否存在
        mu        sync.RWMutex // 读写锁
        mime      string       // 文件Mime类型
}

var FileApp File

const (
        DefaultCreateMode = os.O_CREATE | os.O_RDWR
        DefaultReadMode   = os.O_RDWR
)

// WhoAmI 获取当前类型：（文件）
func (*File) WhoAmI() FilesystemV2Type <span class="cov0" title="0">{ return FilesystemV2File }</span>

// NewByAbs 实例化：通过绝对路径
func (*File) NewByAbs(paths ...string) *File <span class="cov8" title="1">{
        ins := &amp;File{fullPath: filepath.Join(paths...)}
        ins.refresh()

        return ins
}</span>

// NewByRel 实例化：通过相对路径
func (*File) NewByRel(paths ...string) *File <span class="cov8" title="1">{
        ins := &amp;File{fullPath: getRootPath(filepath.Join(paths...))}
        ins.refresh()

        return ins
}</span>

// Lock 加锁：写锁
func (my *File) Lock() *File <span class="cov0" title="0">{
        my.mu.Lock()
        return my
}</span>

// Unlock 解锁：写锁
func (my *File) Unlock() *File <span class="cov0" title="0">{
        my.mu.Unlock()
        return my
}</span>

// RLock 加锁：读锁
func (my *File) RLock() *File <span class="cov0" title="0">{
        my.mu.RLock()
        return my
}</span>

// RUnlock 解锁：读锁
func (my *File) RUnlock() *File <span class="cov0" title="0">{
        my.mu.RUnlock()
        return my
}</span>

// getName 获取文件名
func (my *File) getName() string <span class="cov8" title="1">{ return my.name }</span>

// GetName 获取文件名
func (my *File) GetName() string <span class="cov8" title="1">{
        my.mu.RLock()
        defer my.mu.RUnlock()

        return my.getName()
}</span>

// getBasePath 获取基础路径
func (my *File) getBasePath() string <span class="cov8" title="1">{ return my.basePath }</span>

// GetBasePath 获取基础路径
func (my *File) GetBasePath() string <span class="cov8" title="1">{
        my.mu.RLock()
        defer my.mu.RUnlock()

        return my.getBasePath()
}</span>

// getFullPath 获取完整路径
func (my *File) getFullPath() string <span class="cov8" title="1">{ return my.fullPath }</span>

// GetFullPath 获取完整路径
func (my *File) GetFullPath() string <span class="cov8" title="1">{
        my.mu.RLock()
        defer my.mu.RUnlock()

        return my.getFullPath()
}</span>

// getExtension 获取文件扩展名
func (my *File) getExtension() string <span class="cov8" title="1">{ return my.extension }</span>

// GetExtension 获取文件扩展名
func (my *File) GetExtension() string <span class="cov0" title="0">{
        my.mu.RLock()
        defer my.mu.RUnlock()

        return my.getExtension()
}</span>

// getSize 获取文件大小
func (my *File) getSize() int64 <span class="cov0" title="0">{ return my.size }</span>

// GetSize 获取文件大小
func (my *File) GetSize() int64 <span class="cov0" title="0">{
        my.mu.RLock()
        defer my.mu.RUnlock()

        return my.getSize()
}</span>

// getInfo 获取文件信息
func (my *File) getInfo() os.FileInfo <span class="cov8" title="1">{ return my.fileInfo }</span>

// GetInfo 获取文件信息
func (my *File) GetInfo() os.FileInfo <span class="cov8" title="1">{
        my.mu.RLock()
        defer my.mu.RUnlock()

        return my.getInfo()
}</span>

// getMode 获取文件权限
func (my *File) getMode() os.FileMode <span class="cov8" title="1">{ return my.mode }</span>

// GetMode 获取文件权限
func (my *File) GetMode() os.FileMode <span class="cov0" title="0">{
        my.mu.RLock()
        defer my.mu.RUnlock()

        return my.getMode()
}</span>

// getExist 获取文件是否存在
func (my *File) getExist() bool <span class="cov8" title="1">{ return my.exist }</span>

// GetExist 获取文件是否存在
func (my *File) GetExist() bool <span class="cov8" title="1">{
        my.mu.RLock()
        defer my.mu.RUnlock()

        return my.getExist()
}</span>

// getMime 获取文件Mime类型
func (my *File) getMime() string <span class="cov0" title="0">{ return my.mime }</span>

// GetMime 获取文件Mime类型
func (my *File) GetMime() string <span class="cov0" title="0">{
        my.mu.RLock()
        defer my.mu.RUnlock()

        return my.getMime()
}</span>

func (my *File) join(path string) <span class="cov0" title="0">{ my.fullPath = filepath.Join(my.getFullPath(), path) }</span>

// Join 多路径拼接
func (my *File) Join(path string) *File <span class="cov0" title="0">{
        my.mu.Lock()
        defer my.mu.Unlock()
        defer my.refresh()

        my.join(path)

        return my
}</span>

func (my *File) joins(paths ...string) <span class="cov0" title="0">{
        allPaths := []string{my.getFullPath()}
        allPaths = append(allPaths, paths...)
        my.fullPath = filepath.Join(allPaths...)
}</span>

// Joins 多路径拼接
func (my *File) Joins(paths ...string) *File <span class="cov0" title="0">{
        my.mu.Lock()
        defer my.mu.Unlock()
        defer my.refresh()

        my.joins(paths...)

        return my
}</span>

// Error 获取错误
func (my *File) Error() error <span class="cov8" title="1">{ return my.err }</span>

// copy 复制当前对象
func (my *File) copy() *File <span class="cov0" title="0">{ return FileApp.NewByAbs(my.fullPath) }</span>

// Copy 复制当前对象
func (my *File) Copy() *File <span class="cov0" title="0">{
        my.mu.Lock()
        defer my.mu.Unlock()

        return my.copy()
}</span>

// refresh 刷新文件信息
func (my *File) refresh() <span class="cov8" title="1">{
        if my.fullPath != "" </span><span class="cov8" title="1">{
                if my.fileInfo, my.err = os.Stat(my.fullPath); my.err != nil </span><span class="cov8" title="1">{
                        if os.IsNotExist(my.err) </span><span class="cov8" title="1">{
                                my.name = ""
                                my.size = 0
                                my.mode = 0
                                my.basePath = filepath.Dir(my.fullPath)
                                my.extension = filepath.Ext(my.fullPath)
                                my.exist = false
                                my.err = nil
                                return
                        }</span> else<span class="cov0" title="0"> {
                                my.err = FileInitErr.Wrap(my.err)
                                return
                        }</span>
                }

                <span class="cov8" title="1">my.name = my.fileInfo.Name()
                my.size = my.fileInfo.Size()
                my.mode = my.fileInfo.Mode()
                my.basePath = path.Dir(my.fullPath)
                my.extension = path.Ext(my.fullPath)
                my.exist = true
                my.err = nil</span>
        } else<span class="cov0" title="0"> {
                my.err = FileFullPathEmptyErr.New("")
        }</span>
}

// create 创建文件
func (my *File) create(mode os.FileMode, operations ...int) <span class="cov8" title="1">{
        var operation = DefaultCreateMode | os.O_TRUNC

        if len(operations) &gt; 0 </span><span class="cov0" title="0">{
                operation = operations[0]
        }</span>

        <span class="cov8" title="1">if !my.exist </span><span class="cov8" title="1">{
                var newFile *os.File
                newFile, my.err = os.OpenFile(my.getFullPath(), operation, mode)
                if my.err != nil </span><span class="cov0" title="0">{
                        my.err = CreateFileErr.Wrap(my.err)
                }</span>
                <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ _ = newFile.Close() }</span>()
        }
}

// Create 创建文件
func (my *File) Create(mode os.FileMode, operations ...int) *File <span class="cov8" title="1">{
        my.mu.Lock()
        defer my.mu.Unlock()
        defer my.refresh()

        my.create(mode, operations...)

        return my
}</span>

func (my *File) CreateDefaultMode(operations ...int) *File <span class="cov8" title="1">{
        my.mu.Lock()
        defer my.mu.Unlock()
        defer my.refresh()

        my.create(os.ModePerm, operations...)

        return my
}</span>

// rename 修改文件名
func (my *File) rename(newName string) string <span class="cov8" title="1">{
        newPath := path.Join(path.Dir(my.fullPath), newName)
        my.err = os.Rename(my.fullPath, newPath)
        if my.err != nil </span><span class="cov0" title="0">{
                my.err = RenameFileErr.Wrap(my.err)
                return my.fullPath
        }</span>

        <span class="cov8" title="1">return newPath</span>
}

// Rename 修改文件名
func (my *File) Rename(newName string) *File <span class="cov8" title="1">{
        my.mu.Lock()
        defer my.mu.Unlock()
        defer my.refresh()

        my.fullPath = my.rename(newName)
        return my
}</span>

// remove 删除文件
func (my *File) remove() <span class="cov8" title="1">{ my.err = os.Remove(my.fullPath) }</span>

// Remove 删除文件
func (my *File) Remove() *File <span class="cov8" title="1">{
        my.mu.Lock()
        defer my.mu.Unlock()
        defer my.refresh()

        my.remove()

        return my
}</span>

// checkPermission 检查文件权限
func (my *File) checkPermission(operations ...int) <span class="cov0" title="0">{
        var (
                file       *os.File
                permission = os.O_RDONLY
        )

        if len(operations) &gt; 0 </span><span class="cov0" title="0">{
                permission = operations[0]
        }</span>

        <span class="cov0" title="0">file, my.err = os.OpenFile(my.fullPath, permission, 0666)
        _ = file.Close()</span>
}

// CheckPermission 检查文件权限
func (my *File) CheckPermission(permissions ...int) *File <span class="cov0" title="0">{
        my.mu.RLock()
        defer my.mu.RUnlock()

        my.checkPermission(permissions...)

        return my
}</span>

// write 写入文件
func (my *File) write(content []byte, mode os.FileMode, operations ...int) int <span class="cov8" title="1">{
        var (
                operation    = DefaultCreateMode
                file         *os.File
                bytesWritten int
        )

        if len(operations) &gt; 0 </span><span class="cov8" title="1">{
                operation = operations[0]
        }</span>

        <span class="cov8" title="1">file, my.err = os.OpenFile(my.getFullPath(), operation, mode)
        defer func() </span><span class="cov8" title="1">{ _ = file.Close() }</span>()
        <span class="cov8" title="1">if my.err != nil </span><span class="cov0" title="0">{
                my.err = WriteFileErr.Wrap(my.err)
                return 0
        }</span>
        <span class="cov8" title="1">bytesWritten, my.err = file.Write(content)
        if my.err != nil </span><span class="cov0" title="0">{
                my.err = WriteFileErr.Wrap(my.err)
                return 0
        }</span>

        <span class="cov8" title="1">return bytesWritten</span>
}

// Write 写入文件
func (my *File) Write(content []byte, mode os.FileMode, operations ...int) *File <span class="cov8" title="1">{
        my.mu.Lock()
        defer my.mu.Unlock()
        defer my.refresh()

        _ = my.write(content, mode, operations...)

        return my
}</span>

// copyTo 复制文件
func (my *File) copyTo(dstFilename string) int64 <span class="cov8" title="1">{
        var (
                src, dst     *os.File
                bytesWritten int64
        )
        src, my.err = os.Open(my.fullPath)
        defer func() </span><span class="cov8" title="1">{ _ = src.Close() }</span>()
        <span class="cov8" title="1">if my.err != nil </span><span class="cov0" title="0">{
                my.err = CopyFileSrcErr.Wrap(my.err)
                return bytesWritten
        }</span>

        <span class="cov8" title="1">dstFile := FileApp.NewByAbs(dstFilename)
        dstDir := DirApp.NewByAbs(dstFile.GetBasePath())
        if !dstDir.GetExist() </span><span class="cov0" title="0">{
                dstDir.CreateDefaultMode()
        }</span>
        <span class="cov8" title="1">dstFile.Create(my.getMode())
        if dstFile.Error() != nil </span><span class="cov0" title="0">{
                my.err = CopyFileDstErr.Wrap(dstFile.Error())
                return bytesWritten
        }</span>

        <span class="cov8" title="1">dst, my.err = os.Create(dstFile.getFullPath())
        defer func() </span><span class="cov8" title="1">{ _ = dst.Close() }</span>()
        <span class="cov8" title="1">if my.err != nil </span><span class="cov0" title="0">{
                my.err = CopyFileDstErr.Wrap(my.err)
                return bytesWritten
        }</span>

        <span class="cov8" title="1">bytesWritten, my.err = io.Copy(dst, src)
        if my.err != nil </span><span class="cov0" title="0">{
                my.err = CopyFileErr.Wrap(my.err)
                return bytesWritten
        }</span>

        <span class="cov8" title="1">return bytesWritten</span>
}

// CopyTo 复制文件
func (my *File) CopyTo(dstFilename string) *File <span class="cov8" title="1">{
        my.mu.Lock()
        defer my.mu.Unlock()
        defer my.refresh()

        my.copyTo(dstFilename)

        return my
}</span>

// read 读取文件
func (my *File) read() []byte <span class="cov8" title="1">{
        var (
                file    *os.File
                content []byte
        )

        file, my.err = os.OpenFile(my.getFullPath(), os.O_RDWR, 0666)
        if my.err != nil </span><span class="cov0" title="0">{
                my.err = ReadFileErr.Wrap(my.err)
                return nil
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ _ = file.Close() }</span>()
        <span class="cov8" title="1">content, my.err = io.ReadAll(file)
        if my.err != nil </span><span class="cov0" title="0">{
                my.err = ReadFileErr.Wrap(my.err)
                return nil
        }</span>

        <span class="cov8" title="1">return content</span>
}

// Read 读取文件
func (my *File) Read() []byte <span class="cov8" title="1">{
        my.mu.RLock()
        defer my.mu.RUnlock()

        return my.read()
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package filesystemV2

import (
        "path/filepath"

        "github.com/aid297/aid/array"
)

func getRootPath(dir string) string <span class="cov8" title="1">{
        rootPath, _ := filepath.Abs(".")

        return filepath.Clean(filepath.Join(rootPath, dir))
}</span>

// CopyFiles 批量复制文件
func CopyFiles(srcFiles, dstFiles *array.AnyArray[*File]) <span class="cov0" title="0">{
        srcFiles.Each(func(idx int, item *File) </span><span class="cov0" title="0">{ item.CopyTo(dstFiles.Get(idx).GetFullPath()) }</span>)
}

// CopyFilesByDstPath 批量复制文件：通过dst绝对路径（无法指定拷贝后的文件名）
func CopyFilesByDstPath(srcFiles *array.AnyArray[*File], dstPath string) <span class="cov0" title="0">{
        dstFiles := array.Make[*File](srcFiles.Len())
        srcFiles.Each(func(idx int, item *File) </span><span class="cov0" title="0">{ dstFiles.Set(idx, FileApp.NewByAbs(filepath.Join(dstPath, item.GetName()))) }</span>)

        <span class="cov0" title="0">CopyFiles(srcFiles, dstFiles)</span>
}

// CopyFilesBy2Path 批量复制文件：通过src绝对路径到dst绝对路径（无法指定拷贝后的文件名）
func CopyFilesBy2Path(srcPath, dstPath string) <span class="cov0" title="0">{
        CopyFilesByDstPath(DirApp.NewByAbs(srcPath).GetFiles(), dstPath)
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package filesystemV3

import (
        "path/filepath"

        "github.com/aid297/aid/operation/operationV2"
)

// ******************** 管理器属性 ******************** //
type (
        DirAttributer interface{ Register(dir *Dir) }

        AttrDirPath  struct{ dirs []string }
        AttrDirIsRel struct{ isRel bool }
)

func (AttrDirPath) Set(vals ...string) AttrDirPath <span class="cov8" title="1">{ return AttrDirPath{vals} }</span>
func (my AttrDirPath) Join(dirs ...string) AttrDirPath <span class="cov0" title="0">{
        my.dirs = append(my.dirs, dirs...)
        return my
}</span>
func (my AttrDirPath) Register(dir *Dir) <span class="cov8" title="1">{
        dir.FullPath = operationV2.NewTernary(
                operationV2.TrueFn(func() string </span><span class="cov8" title="1">{ return getRootPath(filepath.Join(my.dirs...)) }</span>),
                operationV2.FalseFn(func() string <span class="cov8" title="1">{ return filepath.Join(my.dirs...) }</span>),
        ).GetByValue(dir.IsRel)
}

func (AttrDirIsRel) Set(isRel bool) AttrDirIsRel <span class="cov0" title="0">{ return AttrDirIsRel{isRel: isRel} }</span>
func (AttrDirIsRel) SetAbs() AttrDirIsRel        <span class="cov8" title="1">{ return AttrDirIsRel{isRel: false} }</span>
func (AttrDirIsRel) SetRel() AttrDirIsRel        <span class="cov8" title="1">{ return AttrDirIsRel{isRel: true} }</span>
func (my AttrDirIsRel) Register(dir *Dir)        <span class="cov8" title="1">{ dir.IsRel = my.isRel }</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package filesystemV3

import (
        "fmt"
        "os"
        "path"
        "path/filepath"
        "sync"

        "github.com/aid297/aid/operation/operationV2"
)

type Dir struct {
        IsRel    bool         // 是否使用相对路径
        Error    error        // 错误信息
        Name     string       // 文件名
        BasePath string       // 基础路径
        FullPath string       // 完整路径
        Size     int64        // 文件大小
        Info     os.FileInfo  // 文件信息
        Mode     os.FileMode  // 文件权限
        Exist    bool         // 文件是否存在
        mu       sync.RWMutex // 读写锁
        Files    []*File      // 目录下的文件列表
        Dirs     []*Dir       // 子目录列表
}

// NewDir 实例化
func NewDir(attrs ...DirAttributer) *Dir <span class="cov8" title="1">{
        return (&amp;Dir{mu: sync.RWMutex{}, Files: make([]*File, 0), Dirs: make([]*Dir, 0)}).setAttrs(attrs...).refresh()
}</span>

// NewDirAbs 实例化：绝对路径
func NewDirAbs(attrs ...DirAttributer) *Dir <span class="cov8" title="1">{
        return NewDir(append(attrs, APP.DirAttr.IsRel.SetAbs())...)
}</span>

// NewDirRel 实例化：相对路径
func NewDirRel(attrs ...DirAttributer) *Dir <span class="cov8" title="1">{
        return NewDir(append([]DirAttributer{APP.DirAttr.Path.Set("."), APP.DirAttr.IsRel.SetRel()}, attrs...)...)
}</span>

// New 实例化
func (*Dir) New(attrs ...DirAttributer) *Dir <span class="cov0" title="0">{
        return (&amp;Dir{mu: sync.RWMutex{}, Files: make([]*File, 0), Dirs: make([]*Dir, 0)}).setAttrs(attrs...).refresh()
}</span>

// Abs 实例化：绝对路径
func (*Dir) Abs(attrs ...DirAttributer) *Dir <span class="cov0" title="0">{
        return APP.Dir.New(append([]DirAttributer{APP.DirAttr.Path.Set("."), APP.DirAttr.IsRel.SetRel()}, attrs...)...)
}</span>

// Rel 实例化：相对路径
func (*Dir) Rel(attrs ...DirAttributer) *Dir <span class="cov0" title="0">{
        return APP.Dir.New(append([]DirAttributer{APP.DirAttr.Path.Set("."), APP.DirAttr.IsRel.SetRel()}, attrs...)...)
}</span>

// SetAttrs 设置属性
func (my *Dir) SetAttrs(attrs ...DirAttributer) *Dir <span class="cov0" title="0">{
        my.mu.Lock()
        defer my.mu.Unlock()
        return my.setAttrs(attrs...)
}</span>

// setAttrs 设置属性
func (my *Dir) setAttrs(attrs ...DirAttributer) *Dir <span class="cov8" title="1">{
        for idx := range attrs </span><span class="cov8" title="1">{
                attrs[idx].Register(my)
        }</span>
        <span class="cov8" title="1">return my</span>
}

// Lock 加锁 → 写
func (my *Dir) Lock() *Dir <span class="cov0" title="0">{
        my.mu.Lock()
        return my
}</span>

// Unlock 解锁 → 写
func (my *Dir) Unlock() *Dir <span class="cov0" title="0">{
        my.mu.Unlock()
        return my
}</span>

// RLock 加锁 → 读
func (my *Dir) RLock() *Dir <span class="cov0" title="0">{
        my.mu.RLock()
        return my
}</span>

// RUnlock 解锁 → 读
func (my *Dir) RUnlock() *Dir <span class="cov0" title="0">{
        my.mu.RUnlock()
        return my
}</span>

// refresh 刷新目录信息
func (my *Dir) refresh() *Dir <span class="cov8" title="1">{
        var err error
        if my.FullPath != "" </span><span class="cov8" title="1">{
                if my.Info, err = os.Stat(my.FullPath); err != nil </span><span class="cov8" title="1">{
                        if os.IsNotExist(err) </span><span class="cov8" title="1">{
                                my.Name = ""
                                my.Size = 0
                                my.Mode = 0
                                my.BasePath = path.Dir(my.FullPath)
                                my.Exist = false
                                my.Error = nil
                                return my
                        }</span> else<span class="cov0" title="0"> {
                                my.Error = fmt.Errorf("%w:%w", ErrInit, err)
                                return my
                        }</span>
                }

                <span class="cov8" title="1">my.Name = my.Info.Name()
                my.Size = my.Info.Size()
                my.Mode = my.Info.Mode()
                my.BasePath = path.Dir(my.FullPath)
                my.Exist = true
                my.Error = nil</span>
        } else<span class="cov0" title="0"> {
                my.Error = ErrMissFullPath
                return my
        }</span>

        <span class="cov8" title="1">return my</span>
}

// Join 追加目录
func (my *Dir) Join(dirs ...string) *Dir <span class="cov8" title="1">{
        return my.setAttrs(APP.DirAttr.IsRel.SetAbs(), APP.DirAttr.Path.Set(append([]string{my.FullPath}, dirs...)...)).refresh()
}</span>

// Create 创建多级目录
func (my *Dir) Create(attrs ...DirOperationAttributer) *Dir <span class="cov8" title="1">{
        var (
                err       error
                operation = new(DirOperation).SetAttrs(attrs...)
        )

        if my.FullPath == "" </span><span class="cov0" title="0">{
                my.Error = ErrMissFullPath
                return my
        }</span>

        <span class="cov8" title="1">if err = os.MkdirAll(my.FullPath, operationV2.NewTernary(operationV2.TrueFn(func() os.FileMode </span><span class="cov8" title="1">{ return operation.DirMode }</span>), operationV2.FalseValue(os.FileMode(0777))).GetByValue(operation.DirMode != 0)); err != nil <span class="cov0" title="0">{
                my.Error = fmt.Errorf("%w:%w", ErrCreateDir, err)
                return my
        }</span>

        <span class="cov8" title="1">return my.refresh()</span>
}

// Rename 重命名目录
func (my *Dir) Rename(newName string) *Dir <span class="cov8" title="1">{
        var err error

        if my.FullPath == "" </span><span class="cov0" title="0">{
                my.Error = ErrMissFullPath
                return my
        }</span>

        <span class="cov8" title="1">newPath := filepath.Join(filepath.Dir(my.FullPath), newName)
        if err = os.Rename(my.FullPath, newPath); err != nil </span><span class="cov0" title="0">{
                my.Error = fmt.Errorf("%w:%w", ErrRename, err)
                return my
        }</span>

        <span class="cov8" title="1">return NewDirAbs(APP.DirAttr.Path.Set(newPath))</span>
}

// Remove 删除目录
func (my *Dir) Remove() *Dir <span class="cov8" title="1">{
        var err error

        if my.FullPath == "" </span><span class="cov0" title="0">{
                my.Error = ErrMissFullPath
                return my
        }</span>

        <span class="cov8" title="1">if err = os.Remove(my.FullPath); err != nil </span><span class="cov0" title="0">{
                my.Error = fmt.Errorf("%w:%w", ErrRemove, err)
                return my
        }</span>

        <span class="cov8" title="1">return my.refresh()</span>
}

// RemoveAll 递归删除目录
func (my *Dir) RemoveAll() *Dir <span class="cov8" title="1">{
        var err error

        if my.FullPath == "" </span><span class="cov0" title="0">{
                my.Error = ErrMissFullPath
                return my
        }</span>

        <span class="cov8" title="1">if err = os.RemoveAll(my.FullPath); err != nil </span><span class="cov0" title="0">{
                my.Error = fmt.Errorf("%w:%w", ErrRemove, err)
                return my
        }</span>

        <span class="cov8" title="1">return my.refresh()</span>
}

// LS 列出当前目录下的所有文件和子目录
func (my *Dir) LS() *Dir <span class="cov8" title="1">{
        var (
                err     error
                entries []os.DirEntry
        )

        if my.FullPath == "" </span><span class="cov0" title="0">{
                my.Error = ErrMissFullPath
                return my
        }</span>

        <span class="cov8" title="1">if entries, err = os.ReadDir(my.FullPath); err != nil </span><span class="cov0" title="0">{
                my.Error = fmt.Errorf("%w:%w", ErrReadDir, err)
                return my
        }</span>

        <span class="cov8" title="1">for _, entry := range entries </span><span class="cov8" title="1">{
                if entry.IsDir() </span><span class="cov8" title="1">{
                        d := NewDirAbs(APP.DirAttr.Path.Set(my.FullPath)).Join(entry.Name())
                        my.Dirs = append(my.Dirs, d.LS())
                }</span> else<span class="cov0" title="0"> {
                        my.Files = append(my.Files, NewFileAbs(APP.FileAttr.Path.Set(my.FullPath, entry.Name())))
                }</span>
        }

        <span class="cov8" title="1">return my</span>
}

// CopyFilesTo 复制当前目录下的所有文件到目标路径
func (my *Dir) CopyFilesTo(isRel bool, dstPaths ...string) *Dir <span class="cov0" title="0">{
        var (
                err error
                dst *Dir
        )

        if my.FullPath == "" </span><span class="cov0" title="0">{
                my.Error = ErrMissFullPath
                return my
        }</span>

        <span class="cov0" title="0">if !my.Exist </span><span class="cov0" title="0">{
                my.Error = ErrDirNotExist
                return my
        }</span>

        <span class="cov0" title="0">if my.LS().Error != nil </span><span class="cov0" title="0">{
                return my
        }</span>

        <span class="cov0" title="0">if dst = NewDir(APP.DirAttr.IsRel.SetRel(), APP.DirAttr.Path.Set(dstPaths...)).Create(DirMode(my.Mode)); dst.Error != nil </span><span class="cov0" title="0">{
                my.Error = dst.Error
                return my
        }</span>

        <span class="cov0" title="0">for idx := range my.Files </span><span class="cov0" title="0">{
                if err = my.Files[idx].CopyTo(isRel, dstPaths...).Error; err != nil </span><span class="cov0" title="0">{
                        my.Error = err
                        return my
                }</span>
        }

        <span class="cov0" title="0">return my</span>
}

// CopyDirsTo 复制当前目录下的所有子目录到目标路径
func (my *Dir) CopyDirsTo(isRel bool, dstPaths ...string) *Dir <span class="cov8" title="1">{
        var dst *Dir

        if my.FullPath == "" </span><span class="cov0" title="0">{
                my.Error = ErrMissFullPath
                return my
        }</span>

        <span class="cov8" title="1">if !my.Exist </span><span class="cov0" title="0">{
                my.Error = ErrDirNotExist
                return my
        }</span>

        <span class="cov8" title="1">if my.LS().Error != nil </span><span class="cov0" title="0">{
                return my
        }</span>

        <span class="cov8" title="1">if dst = NewDir(APP.DirAttr.IsRel.SetRel(), APP.DirAttr.Path.Set(dstPaths...)); dst.Error != nil </span><span class="cov0" title="0">{
                my.Error = dst.Error
                return my
        }</span>

        <span class="cov8" title="1">if len(my.Dirs) &gt; 0 </span><span class="cov8" title="1">{
                my.Error = copyDirTo(my.FullPath, dst.FullPath)
        }</span>

        <span class="cov8" title="1">return my</span>
}

// CopyAllTo 复制当前目录下的所有文件和子目录到目标路径
func (my *Dir) CopyAllTo(isRel bool, dstPaths ...string) *Dir <span class="cov8" title="1">{
        var dst *Dir

        if my.FullPath == "" </span><span class="cov0" title="0">{
                my.Error = ErrMissFullPath
                return my
        }</span>

        <span class="cov8" title="1">if !my.Exist </span><span class="cov0" title="0">{
                my.Error = ErrDirNotExist
                return my
        }</span>

        <span class="cov8" title="1">if my.LS().Error != nil </span><span class="cov0" title="0">{
                return my
        }</span>

        <span class="cov8" title="1">if dst = NewDir(APP.DirAttr.IsRel.SetRel(), APP.DirAttr.Path.Set(dstPaths...)); !dst.Exist </span><span class="cov0" title="0">{
                dst.Create(DirMode(my.Mode))
        }</span>

        // if len(my.Files) &gt; 0 {
        //         my = my.CopyFilesTo(isRel, dstPaths...)
        // }

        <span class="cov8" title="1">if len(my.Dirs) &gt; 0 </span><span class="cov8" title="1">{
                my = my.CopyDirsTo(isRel, dstPaths...)

        }</span>

        <span class="cov8" title="1">return my</span>
}

// Copy 复制当前对象
func (my *Dir) Copy() *Dir <span class="cov0" title="0">{ return NewDirAbs(APP.DirAttr.Path.Set(my.FullPath)) }</span>

// Up 向上一级目录
func (my *Dir) Up() *Dir <span class="cov8" title="1">{
        return my.setAttrs(APP.DirAttr.IsRel.SetAbs(), APP.DirAttr.Path.Set(my.BasePath)).refresh()
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package filesystemV3

import (
        "path/filepath"

        "github.com/aid297/aid/operation/operationV2"
)

// ******************** 管理器属性 ******************** //
type (
        FileAttributer interface{ Register(dir *File) }

        AttrFilePath  struct{ dirs []string }
        AttrFileIsRel struct{ isRel bool }
)

func (AttrFilePath) Set(vals ...string) AttrFilePath <span class="cov8" title="1">{ return AttrFilePath{vals} }</span>
func (my AttrFilePath) Join(dirs ...string) AttrFilePath <span class="cov0" title="0">{
        my.dirs = append(my.dirs, dirs...)
        return my
}</span>
func (my AttrFilePath) Register(file *File) <span class="cov8" title="1">{
        file.FullPath = operationV2.NewTernary(
                operationV2.TrueFn(func() string </span><span class="cov8" title="1">{ return getRootPath(filepath.Join(my.dirs...)) }</span>),
                operationV2.FalseFn(func() string <span class="cov8" title="1">{ return filepath.Join(my.dirs...) }</span>),
        ).GetByValue(file.IsRel)
}

func (my AttrFileIsRel) Set(isRel bool) AttrFileIsRel <span class="cov8" title="1">{ return AttrFileIsRel{isRel: isRel} }</span>
func (AttrFileIsRel) SetAbs() AttrFileIsRel           <span class="cov8" title="1">{ return AttrFileIsRel{isRel: false} }</span>
func (AttrFileIsRel) SetRel() AttrFileIsRel           <span class="cov8" title="1">{ return AttrFileIsRel{isRel: true} }</span>
func (my AttrFileIsRel) Register(dir *File)           <span class="cov8" title="1">{ dir.IsRel = my.isRel }</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package filesystemV3

import (
        "fmt"
        "io"
        "os"
        "path"
        "path/filepath"
        "sync"

        "github.com/aid297/aid/operation/operationV2"
)

type File struct {
        IsRel     bool         // 是否使用相对路径
        Error     error        // 错误信息
        Name      string       // 文件名
        BasePath  string       // 基础路径
        FullPath  string       // 完整路径
        Size      int64        // 文件大小
        Info      os.FileInfo  // 文件信息
        Mode      os.FileMode  // 文件权限
        Exist     bool         // 文件是否存在
        mu        sync.RWMutex // 读写锁
        Extension string       // 文件扩展名
        Fileinfo  os.FileInfo  // 文件信息
        Mime      string       // 文件Mime类型
}

var (
        DefaultCreateMode = os.O_APPEND | os.O_CREATE | os.O_WRONLY
        DefaultReadMode   = os.O_RDWR
)

// NewFile 实例化
func NewFile(attrs ...FileAttributer) *File <span class="cov8" title="1">{
        return (&amp;File{mu: sync.RWMutex{}}).setAttrs(attrs...).refresh()
}</span>

// NewFileAbs 实例化：绝对路径
func NewFileAbs(attrs ...FileAttributer) *File <span class="cov0" title="0">{
        return NewFile(append(attrs, APP.FileAttr.IsRel.SetAbs())...)
}</span>

// NewFileRel 实例化：相对路径
func NewFileRel(attrs ...FileAttributer) *File <span class="cov8" title="1">{
        return NewFile(append([]FileAttributer{APP.FileAttr.IsRel.SetRel()}, attrs...)...)
}</span>

// New 实例化
func (*File) New(attrs ...FileAttributer) *File <span class="cov0" title="0">{
        return (&amp;File{mu: sync.RWMutex{}}).setAttrs(attrs...).refresh()
}</span>

// Abs 实例化：绝对路径
func (*File) Abs(attrs ...FileAttributer) *File <span class="cov0" title="0">{
        return APP.File.New(append(attrs, APP.FileAttr.IsRel.SetAbs())...)
}</span>

// Rel 实例化：相对路径
func (*File) Rel(attrs ...FileAttributer) *File <span class="cov0" title="0">{
        return APP.File.New(append([]FileAttributer{APP.FileAttr.IsRel.SetRel()}, attrs...)...)
}</span>

// SetAttrs 设置属性
func (my *File) SetAttrs(attrs ...FileAttributer) *File <span class="cov0" title="0">{
        my.mu.Lock()
        defer my.mu.Unlock()
        return my.setAttrs(attrs...)
}</span>

// setAttrs 设置属性
func (my *File) setAttrs(attrs ...FileAttributer) *File <span class="cov8" title="1">{
        for idx := range attrs </span><span class="cov8" title="1">{
                attrs[idx].Register(my)
        }</span>
        <span class="cov8" title="1">return my</span>
}

// refresh 刷新文件信息
func (my *File) refresh() *File <span class="cov8" title="1">{
        var err error

        if my.FullPath != "" </span><span class="cov8" title="1">{
                if my.Fileinfo, err = os.Stat(my.FullPath); err != nil </span><span class="cov8" title="1">{
                        if os.IsNotExist(err) </span><span class="cov8" title="1">{
                                my.Name = ""
                                my.Size = 0
                                my.Mode = 0
                                my.BasePath = filepath.Dir(my.FullPath)
                                my.Extension = filepath.Ext(my.FullPath)
                                my.Exist = false
                                my.Error = nil
                                return my
                        }</span> else<span class="cov0" title="0"> {
                                my.Error = fmt.Errorf("%w:%w", ErrInit, err)
                                return my
                        }</span>
                }

                <span class="cov8" title="1">my.Name = my.Fileinfo.Name()
                my.Size = my.Fileinfo.Size()
                my.Mode = my.Fileinfo.Mode()
                my.BasePath = path.Dir(my.FullPath)
                my.Exist = true
                my.Error = nil</span>
        } else<span class="cov0" title="0"> {
                my.Error = ErrMissFullPath
                return my
        }</span>

        <span class="cov8" title="1">return my</span>
}

// Lock 加锁 → 写
func (my *File) Lock() *File <span class="cov0" title="0">{
        my.mu.Lock()
        return my
}</span>

// Unlock 解锁 → 写
func (my *File) Unlock() *File <span class="cov0" title="0">{
        my.mu.Unlock()
        return my
}</span>

// RLock 加锁 → 读
func (my *File) RLock() *File <span class="cov0" title="0">{
        my.mu.RLock()
        return my
}</span>

// RUnlock 解锁 → 读
func (my *File) RUnlock() *File <span class="cov0" title="0">{
        my.mu.RUnlock()
        return my
}</span>

// Join 连接路径
func (my *File) Join(dirs ...string) *File <span class="cov0" title="0">{
        return my.setAttrs(APP.FileAttr.IsRel.SetAbs(), APP.FileAttr.Path.Set(append([]string{my.FullPath}, dirs...)...)).refresh()
}</span>

// Create 创建文件
func (my *File) Create(attrs ...FileOperationAttributer) *File <span class="cov0" title="0">{
        if dir := NewDirAbs(APP.DirAttr.Path.Set(my.BasePath)); !dir.Exist </span><span class="cov0" title="0">{
                if err := dir.Create().Error; err != nil </span><span class="cov0" title="0">{
                        my.Error = fmt.Errorf("%w:%w", ErrCreateDir, err)
                }</span>
        }

        <span class="cov0" title="0">my.Write(nil, attrs...)

        return nil</span>
}

// 向文件内写入内容
func (my *File) Write(content []byte, attrs ...FileOperationAttributer) *File <span class="cov8" title="1">{
        var (
                err           error
                fileOperation = new(FileOperation).SetAttrs(attrs...)
                file          *os.File
        )

        if dir := NewDirAbs(APP.DirAttr.Path.Set(my.BasePath)); !dir.Exist </span><span class="cov0" title="0">{
                if err := dir.Create().Error; err != nil </span><span class="cov0" title="0">{
                        my.Error = fmt.Errorf("%w:%w", ErrCreateDir, err)
                }</span>
        }

        <span class="cov8" title="1">if file, err = os.OpenFile(
                my.FullPath,
                operationV2.NewTernary(operationV2.TrueValue(fileOperation.FileFlag), operationV2.FalseValue(DefaultCreateMode)).GetByValue(fileOperation.FileFlag != 0),
                operationV2.NewTernary(operationV2.TrueValue(fileOperation.FileMode), operationV2.FalseValue(os.FileMode(0777))).GetByValue(fileOperation.FileMode != 0),
        ); err != nil </span><span class="cov0" title="0">{
                my.Error = fmt.Errorf("%w:%w", ErrWriteFile, err)
                return my
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ _ = file.Close() }</span>()

        <span class="cov8" title="1">if _, err = file.Write(content); err != nil </span><span class="cov0" title="0">{
                my.Error = fmt.Errorf("%w:%w", ErrWriteFile, err)
                return my
        }</span>

        <span class="cov8" title="1">return my.refresh()</span>
}

// Rename 重命名文件
func (my *File) Rename(newName string) *File <span class="cov8" title="1">{
        var (
                err     error
                newFile = NewFile(APP.FileAttr.IsRel.SetAbs(), APP.FileAttr.Path.Set(my.BasePath, newName))
        )

        if err = os.Rename(my.FullPath, newFile.FullPath); err != nil </span><span class="cov0" title="0">{
                my.Error = fmt.Errorf("%w：%w", ErrRename, err)
                return my
        }</span>

        <span class="cov8" title="1">return newFile.refresh()</span>
}

// Remove 删除文件
func (my *File) Remove() *File <span class="cov8" title="1">{
        var err error

        if my.FullPath == "" </span><span class="cov0" title="0">{
                my.Error = ErrMissFullPath
                return my
        }</span>

        <span class="cov8" title="1">if err = os.Remove(my.FullPath); err != nil </span><span class="cov0" title="0">{
                my.Error = fmt.Errorf("%w:%w", ErrRemove, err)
                return my
        }</span>

        <span class="cov8" title="1">return my.refresh()</span>
}

// Read 读取文件内容
func (my *File) Read(attrs ...FileOperationAttributer) ([]byte, error) <span class="cov8" title="1">{
        var (
                fileOperation = new(FileOperation).SetAttrs(attrs...)
                file          *os.File
                content       []byte
                err           error
        )

        if file, err = os.OpenFile(
                my.FullPath,
                operationV2.NewTernary(operationV2.TrueFn(func() int </span><span class="cov0" title="0">{ return fileOperation.FileFlag }</span>), operationV2.FalseFn(func() int <span class="cov8" title="1">{ return DefaultReadMode }</span>)).GetByValue(fileOperation.FileFlag != 0),
                operationV2.NewTernary(operationV2.TrueFn(func() os.FileMode <span class="cov0" title="0">{ return fileOperation.FileMode }</span>), operationV2.FalseFn(func() os.FileMode <span class="cov8" title="1">{ return os.FileMode(0777) }</span>)).GetByValue(fileOperation.FileMode != 0),
        ); err != nil <span class="cov0" title="0">{
                return []byte{}, fmt.Errorf("%w:%w", ErrReadFile, err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ _ = file.Close() }</span>()
        <span class="cov8" title="1">if content, err = io.ReadAll(file); err != nil </span><span class="cov0" title="0">{
                return []byte{}, fmt.Errorf("%w:%w", ErrReadFile, err)
        }</span>

        <span class="cov8" title="1">return content, nil</span>
}

// CopyTo 复制文件到指定路径
func (my *File) CopyTo(isRel bool, dstPaths ...string) *File <span class="cov8" title="1">{
        if my.FullPath == "" </span><span class="cov0" title="0">{
                my.Error = ErrMissFullPath
                return my
        }</span>

        <span class="cov8" title="1">if !my.Exist </span><span class="cov0" title="0">{
                my.Error = ErrFileNotExist
                return my
        }</span>

        <span class="cov8" title="1">a := NewDir(APP.DirAttr.IsRel.SetRel(), APP.DirAttr.Path.Set(dstPaths...)).Up()
        print(a.FullPath)

        b := NewDirAbs(APP.DirAttr.Path.Set(my.BasePath))
        print(b.FullPath)

        if my.Error = NewDir(APP.DirAttr.IsRel.SetRel(), APP.DirAttr.Path.Set(dstPaths...)).Up().Create(DirMode(NewDirAbs(APP.DirAttr.Path.Set(my.BasePath)).Info.Mode())).Error; my.Error != nil </span><span class="cov0" title="0">{
                return my
        }</span>

        <span class="cov8" title="1">dst := NewFile(APP.FileAttr.IsRel.Set(isRel), APP.FileAttr.Path.Set(dstPaths...)).FullPath
        my.Error = copyFileTo(my.FullPath, dst)

        return my</span>
}

// Copy 复制文件实例
func (my *File) Copy() *File <span class="cov0" title="0">{ return NewFileAbs(APP.FileAttr.Path.Set(my.FullPath)) }</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package filesystemV3

import "os"

// ******************** 目录操作属性 ******************** //
type DirOperation struct {
        DirFlag int
        DirMode os.FileMode
}

func (my *DirOperation) SetAttrs(attrs ...DirOperationAttributer) *DirOperation <span class="cov8" title="1">{
        for idx := range attrs </span><span class="cov8" title="1">{
                attrs[idx].Register(my)
        }</span>

        <span class="cov8" title="1">return my</span>
}

type (
        DirOperationAttributer interface{ Register(o *DirOperation) }

        AttrDirFlag struct{ flag int }
        AttrDirMode struct{ mode os.FileMode }
)

func DirFlag(flag int) DirOperationAttributer   <span class="cov0" title="0">{ return AttrDirFlag{flag: flag} }</span>
func (my AttrDirFlag) Register(o *DirOperation) <span class="cov0" title="0">{ o.DirFlag = my.flag }</span>

func DirMode(mode os.FileMode) DirOperationAttributer <span class="cov8" title="1">{ return AttrDirMode{mode: mode} }</span>
func (my AttrDirMode) Register(o *DirOperation)       <span class="cov8" title="1">{ o.DirMode = my.mode }</span>

// ******************** 文件操作属性 ******************** //
type FileOperation struct {
        FileFlag int
        FileMode os.FileMode
}

func (my *FileOperation) SetAttrs(attrs ...FileOperationAttributer) *FileOperation <span class="cov8" title="1">{
        for idx := range attrs </span><span class="cov0" title="0">{
                attrs[idx].Register(my)
        }</span>

        <span class="cov8" title="1">return my</span>
}

type (
        FileOperationAttributer interface{ Register(o *FileOperation) }

        AttrFileFlag struct{ flag int }
        AttrFileMode struct{ mode os.FileMode }
)

func FileFlag(flag int) AttrFileFlag              <span class="cov0" title="0">{ return AttrFileFlag{flag: flag} }</span>
func (my AttrFileFlag) Register(o *FileOperation) <span class="cov0" title="0">{ o.FileFlag = my.flag }</span>

func FileMode(mode os.FileMode) AttrFileMode      <span class="cov0" title="0">{ return AttrFileMode{mode: mode} }</span>
func (my AttrFileMode) Register(o *FileOperation) <span class="cov0" title="0">{ o.FileMode = my.mode }</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package filesystemV3

import (
        "fmt"
        "io"
        "os"
        "path/filepath"
)

func getRootPath(dir string) string <span class="cov8" title="1">{
        rootPath, _ := filepath.Abs(".")

        return filepath.Clean(filepath.Join(rootPath, dir))
}</span>

func copyFileTo(src, dst string) error <span class="cov8" title="1">{
        // 打开源文件
        srcFile, err := os.Open(src)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("无法打开源文件 %s: %w", src, err)
        }</span>
        <span class="cov8" title="1">defer srcFile.Close()

        // 获取源文件信息（用于保留权限）
        srcInfo, err := os.Stat(src)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("无法获取源文件信息 %s: %w", src, err)
        }</span>

        // 创建目标文件，保留原始权限
        <span class="cov8" title="1">dstFile, err := os.OpenFile(dst, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, srcInfo.Mode())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("无法创建目标文件 %s: %w", dst, err)
        }</span>
        <span class="cov8" title="1">defer dstFile.Close()

        // 复制文件内容
        _, err = io.Copy(dstFile, srcFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("复制文件内容失败 %s -&gt; %s: %w", src, dst, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func copyDirTo(src, dst string) error <span class="cov8" title="1">{
        // 获取源目录信息
        srcInfo, err := os.Stat(src)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("无法获取源目录信息: %w", err)
        }</span>

        // 确认源路径是目录
        <span class="cov8" title="1">if !srcInfo.IsDir() </span><span class="cov0" title="0">{
                return fmt.Errorf("源路径 %s 不是一个目录", src)
        }</span>

        // 创建目标目录（保留原始权限）
        <span class="cov8" title="1">if err := os.MkdirAll(dst, srcInfo.Mode()); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("无法创建目标目录 %s: %w", dst, err)
        }</span>

        // 读取源目录内容
        <span class="cov8" title="1">entries, err := os.ReadDir(src)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("无法读取源目录 %s: %w", src, err)
        }</span>

        // 遍历并处理每个条目
        <span class="cov8" title="1">for _, entry := range entries </span><span class="cov8" title="1">{
                srcPath := filepath.Join(src, entry.Name())
                dstPath := filepath.Join(dst, entry.Name())

                if entry.IsDir() </span><span class="cov8" title="1">{
                        // 递归处理子目录
                        if err := copyDirTo(srcPath, dstPath); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        // 复制文件
                        if err := copyFileTo(srcPath, dstPath); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("复制文件 %s 失败: %w", srcPath, err)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package honestMan

import (
        "fmt"
        "reflect"

        "github.com/aid297/aid/array"
        "github.com/aid297/aid/myError"
        "github.com/aid297/aid/operation"
)

type (
        ReadError  struct{ myError.MyError }
        WriteError struct{ myError.MyError }
)

var (
        ReadErr  ReadError
        WriteErr WriteError
)

func (*ReadError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;ReadError{myError.MyError{Msg: array.NewDestruction("读取配置错误", msg).JoinWithoutEmpty("：")}}
}</span>

func (*ReadError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;ReadError{myError.MyError{Msg: fmt.Errorf("读取配置错误"+operation.Ternary(err != nil, "：%w", "%w"), err).Error()}}
}</span>

func (*ReadError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;ReadError{myError.MyError{Msg: "读取配置错误"}}
}</span>

func (my *ReadError) Error() string <span class="cov0" title="0">{ return my.Msg }</span>

func (my *ReadError) Is(target error) bool <span class="cov0" title="0">{ return reflect.DeepEqual(target, &amp;ReadErr) }</span>

func (*WriteError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;WriteError{myError.MyError{Msg: array.NewDestruction("写入配置错误", msg).JoinWithoutEmpty("：")}}
}</span>

func (*WriteError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;WriteError{myError.MyError{Msg: fmt.Errorf("写入配置错误"+operation.Ternary(err != nil, "：%w", "%w"), err).Error()}}
}</span>

func (*WriteError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;WriteError{myError.MyError{Msg: "写入配置错误"}}
}</span>

func (my *WriteError) Error() string <span class="cov0" title="0">{ return my.Msg }</span>

func (my *WriteError) Is(target error) bool <span class="cov0" title="0">{ return reflect.DeepEqual(target, &amp;WriteErr) }</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package honestMan

import (
        "encoding/json"
        "errors"
        "fmt"
        "os"
        "path"
        "reflect"

        "gopkg.in/yaml.v2"

        "github.com/aid297/aid/filesystem"
)

type HonestMan struct {
        dir string
        err error
}

var HonestManApp HonestMan

func (*HonestMan) New(dirs ...string) *HonestMan <span class="cov0" title="0">{
        return &amp;HonestMan{dir: path.Join(dirs...)}
}</span>

func (*HonestMan) NewByAbsolute(dirs ...string) *HonestMan <span class="cov0" title="0">{
        return &amp;HonestMan{dir: filesystem.FileSystemApp.NewByAbsolute(dirs[0]).Joins(dirs[1:]...).GetDir()}
}</span>

func (*HonestMan) NewByRelative(dirs ...string) *HonestMan <span class="cov0" title="0">{
        return &amp;HonestMan{dir: filesystem.FileSystemApp.NewByRelative(".").Joins(dirs...).GetDir()}
}</span>

// Error 获取错误
func (my *HonestMan) Error() error <span class="cov0" title="0">{ return my.err }</span>

// 读取文件
func (my *HonestMan) readFile() []byte <span class="cov0" title="0">{
        var (
                fileContent []byte
                err         error
        )
        fileContent, err = os.ReadFile(my.dir)
        if err != nil </span><span class="cov0" title="0">{
                my.err = ReadErr.Wrap(fmt.Errorf("读取配置文件失败(%s)：%s", my.dir, err.Error()))
                return nil
        }</span>

        <span class="cov0" title="0">return fileContent</span>
}

// 检查参数是否是一个指针
func (my *HonestMan) isPtr(target any) <span class="cov0" title="0">{
        // 使用反射检查target是否为指针类型
        val := reflect.ValueOf(target)
        if val.Kind() != reflect.Ptr </span><span class="cov0" title="0">{
                panic(errors.New("参数必须是一个指针"))</span>
        }
}

// LoadYaml 读取Yaml配置文件
func (my *HonestMan) LoadYaml(target any) (err error) <span class="cov0" title="0">{
        my.isPtr(target)
        content := my.readFile()
        if my.err != nil </span><span class="cov0" title="0">{
                return my.err
        }</span>

        <span class="cov0" title="0">return yaml.Unmarshal(content, target)</span>
}

// LoadJson 读取Json配置文件
func (my *HonestMan) LoadJson(target any) (err error) <span class="cov0" title="0">{
        my.isPtr(target)
        content := my.readFile()
        if my.err != nil </span><span class="cov0" title="0">{
                return my.err
        }</span>

        <span class="cov0" title="0">return json.Unmarshal(content, target)</span>
}

// SaveYaml 写入Yaml文件
func (my *HonestMan) SaveYaml(target any) (err error) <span class="cov0" title="0">{
        // my.isPtr(target)
        out, err := yaml.Marshal(target)
        if err != nil </span><span class="cov0" title="0">{
                return WriteErr.Wrap(err)
        }</span>

        <span class="cov0" title="0">return os.WriteFile(my.dir, out, os.ModePerm)</span>
}

// SaveJson 写入Json文件
func (my *HonestMan) SaveJson(target any) (err error) <span class="cov0" title="0">{
        // my.isPtr(target)
        out, err := json.Marshal(target)
        if err != nil </span><span class="cov0" title="0">{
                return WriteErr.Wrap(err)
        }</span>

        <span class="cov0" title="0">return os.WriteFile(my.dir, out, os.ModePerm)</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package httpClient

import (
        "fmt"
        "reflect"

        "github.com/aid297/aid/array"
        "github.com/aid297/aid/myError"
        "github.com/aid297/aid/operation"
)

type (
        ReadResponseError    struct{ myError.MyError }
        UrlEmptyError        struct{ myError.MyError }
        GenerateCertError    struct{ myError.MyError }
        GenerateRequestError struct{ myError.MyError }
        UnmarshalXmlError    struct{ myError.MyError }
        UnmarshalJsonError   struct{ myError.MyError }
        SetSteamBodyError    struct{ myError.MyError }
        SetFormBodyError     struct{ myError.MyError }
        SetXmlBodyError      struct{ myError.MyError }
        SetJsonBodyError     struct{ myError.MyError }
        WriteResponseError   struct{ myError.MyError }
)

var (
        ReadResponseErr    ReadResponseError
        UrlEmptyErr        UrlEmptyError
        GenerateCertErr    GenerateCertError
        GenerateRequestErr GenerateRequestError
        UnmarshalXmlErr    UnmarshalXmlError
        UnmarshalJsonErr   UnmarshalJsonError
        SetSteamBodyErr    SetSteamBodyError
        SetFormBodyErr     SetFormBodyError
        SetXmlBodyErr      SetXmlBodyError
        SetJsonBodyErr     SetJsonBodyError
        WriteResponseErr   WriteResponseError
)

func (*ReadResponseError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;ReadResponseError{MyError: myError.MyError{Msg: array.New([]string{"读取响应体失败", msg}).JoinWithoutEmpty("：")}}
}</span>

func (*ReadResponseError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;ReadResponseError{MyError: myError.MyError{Msg: fmt.Errorf("读取响应体失败"+operation.Ternary(err != nil, "：%w", "%w"), err).Error()}}
}</span>

func (*ReadResponseError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;ReadResponseError{MyError: myError.MyError{Msg: "读取响应体失败"}}
}</span>

func (my *ReadResponseError) Error() string <span class="cov0" title="0">{ return my.MyError.Msg }</span>

func (my *ReadResponseError) Is(target error) bool <span class="cov0" title="0">{
        return reflect.DeepEqual(target, &amp;ReadResponseErr)
}</span>

func (*UrlEmptyError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;UrlEmptyError{MyError: myError.MyError{Msg: array.New([]string{"url不能为空", msg}).JoinWithoutEmpty("：")}}
}</span>

func (*UrlEmptyError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;UrlEmptyError{MyError: myError.MyError{Msg: fmt.Errorf("url不能为空"+operation.Ternary(err != nil, "：%w", "%w"), err).Error()}}
}</span>

func (*UrlEmptyError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;UrlEmptyError{MyError: myError.MyError{Msg: "url不能为空"}}
}</span>

func (my *UrlEmptyError) Error() string <span class="cov0" title="0">{ return my.MyError.Msg }</span>

func (my *UrlEmptyError) Is(target error) bool <span class="cov0" title="0">{
        return reflect.DeepEqual(target, &amp;UrlEmptyErr)
}</span>

func (*GenerateCertError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;GenerateCertError{MyError: myError.MyError{Msg: array.New([]string{"生成证书失败", msg}).JoinWithoutEmpty("：")}}
}</span>

func (*GenerateCertError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;GenerateCertError{MyError: myError.MyError{Msg: fmt.Errorf("生成证书失败"+operation.Ternary(err != nil, "：%w", "%w"), err).Error()}}
}</span>

func (*GenerateCertError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;GenerateCertError{MyError: myError.MyError{Msg: "生成证书失败"}}
}</span>

func (my *GenerateCertError) Error() string <span class="cov0" title="0">{ return my.MyError.Msg }</span>

func (my *GenerateCertError) Is(target error) bool <span class="cov0" title="0">{
        return reflect.DeepEqual(target, &amp;GenerateCertErr)
}</span>

func (*GenerateRequestError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;GenerateRequestError{MyError: myError.MyError{Msg: array.New([]string{"生成请求对象失败", msg}).JoinWithoutEmpty("：")}}
}</span>

func (*GenerateRequestError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;GenerateRequestError{MyError: myError.MyError{Msg: fmt.Errorf("生成请求对象失败"+operation.Ternary(err != nil, "：%w", "%w"), err).Error()}}
}</span>

func (*GenerateRequestError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;GenerateRequestError{MyError: myError.MyError{Msg: "生成请求对象失败"}}
}</span>

func (my *GenerateRequestError) Error() string <span class="cov0" title="0">{ return my.MyError.Msg }</span>

func (my *GenerateRequestError) Is(target error) bool <span class="cov0" title="0">{
        return reflect.DeepEqual(target, &amp;GenerateRequestErr)
}</span>

func (*UnmarshalXmlError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;UnmarshalXmlError{MyError: myError.MyError{Msg: array.New([]string{"获取xml格式响应体错误", msg}).JoinWithoutEmpty("：")}}
}</span>

func (*UnmarshalXmlError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;UnmarshalXmlError{MyError: myError.MyError{Msg: fmt.Errorf("获取xml格式响应体错误"+operation.Ternary(err != nil, "：%w", "%w"), err).Error()}}
}</span>

func (*UnmarshalXmlError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;UnmarshalXmlError{MyError: myError.MyError{Msg: "获取xml格式响应体错误"}}
}</span>

func (my *UnmarshalXmlError) Error() string <span class="cov0" title="0">{ return my.MyError.Msg }</span>

func (my *UnmarshalXmlError) Is(target error) bool <span class="cov0" title="0">{
        return reflect.DeepEqual(target, &amp;UnmarshalXmlErr)
}</span>

func (*UnmarshalJsonError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;UnmarshalJsonError{MyError: myError.MyError{Msg: array.New([]string{"获取json格式响应体错误", msg}).JoinWithoutEmpty("：")}}
}</span>

func (*UnmarshalJsonError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;UnmarshalJsonError{MyError: myError.MyError{Msg: fmt.Errorf("获取json格式响应体错误"+operation.Ternary(err != nil, "：%w", "%w"), err).Error()}}
}</span>

func (*UnmarshalJsonError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;UnmarshalJsonError{MyError: myError.MyError{Msg: "获取json格式响应体错误"}}
}</span>

func (my *UnmarshalJsonError) Error() string <span class="cov0" title="0">{ return my.MyError.Msg }</span>

func (my *UnmarshalJsonError) Is(target error) bool <span class="cov0" title="0">{
        return reflect.DeepEqual(target, &amp;UnmarshalJsonErr)
}</span>

func (*SetSteamBodyError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;SetSteamBodyError{MyError: myError.MyError{Msg: array.New([]string{"设置二进制请求体失败", msg}).JoinWithoutEmpty("：")}}
}</span>

func (*SetSteamBodyError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;SetSteamBodyError{MyError: myError.MyError{Msg: fmt.Errorf("设置二进制请求体失败"+operation.Ternary(err != nil, "：%w", "%w"), err).Error()}}
}</span>

func (*SetSteamBodyError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;SetSteamBodyError{MyError: myError.MyError{Msg: "设置二进制请求体失败"}}
}</span>

func (my *SetSteamBodyError) Error() string <span class="cov0" title="0">{ return my.MyError.Msg }</span>

func (my *SetSteamBodyError) Is(target error) bool <span class="cov0" title="0">{
        return reflect.DeepEqual(target, &amp;SetSteamBodyErr)
}</span>

func (*SetFormBodyError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;SetFormBodyError{MyError: myError.MyError{Msg: array.New([]string{"设置表单数据请求体失败", msg}).JoinWithoutEmpty("：")}}
}</span>

func (*SetFormBodyError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;SetFormBodyError{MyError: myError.MyError{Msg: fmt.Errorf("设置表单数据请求体失败"+operation.Ternary(err != nil, "：%w", "%w"), err).Error()}}
}</span>

func (*SetFormBodyError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;SetFormBodyError{MyError: myError.MyError{Msg: "设置表单数据请求体失败"}}
}</span>

func (my *SetFormBodyError) Error() string <span class="cov0" title="0">{ return my.MyError.Msg }</span>

func (my *SetFormBodyError) Is(target error) bool <span class="cov0" title="0">{ return reflect.DeepEqual(target, &amp;SetFormBodyErr) }</span>

func (*SetXmlBodyError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;SetXmlBodyError{MyError: myError.MyError{Msg: array.New([]string{"设置xml请求体失败", msg}).JoinWithoutEmpty("：")}}
}</span>

func (*SetXmlBodyError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;SetXmlBodyError{MyError: myError.MyError{Msg: fmt.Errorf("设置xml请求体失败"+operation.Ternary(err != nil, "：%w", "%w"), err).Error()}}
}</span>

func (*SetXmlBodyError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;SetXmlBodyError{MyError: myError.MyError{Msg: "设置xml请求体失败"}}
}</span>

func (my *SetXmlBodyError) Error() string <span class="cov0" title="0">{ return my.MyError.Msg }</span>

func (my *SetXmlBodyError) Is(target error) bool <span class="cov0" title="0">{ return reflect.DeepEqual(target, &amp;SetXmlBodyErr) }</span>

func (*SetJsonBodyError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;SetJsonBodyError{MyError: myError.MyError{Msg: array.New([]string{"设置json请求体失败", msg}).JoinWithoutEmpty("：")}}
}</span>

func (*SetJsonBodyError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;SetJsonBodyError{MyError: myError.MyError{Msg: fmt.Errorf("设置json请求体失败"+operation.Ternary(err != nil, "：%w", "%w"), err).Error()}}
}</span>

func (*SetJsonBodyError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;SetJsonBodyError{MyError: myError.MyError{Msg: "设置json请求体失败"}}
}</span>

func (my *SetJsonBodyError) Error() string <span class="cov0" title="0">{ return my.MyError.Msg }</span>

func (my *SetJsonBodyError) Is(target error) bool <span class="cov0" title="0">{ return reflect.DeepEqual(target, &amp;SetJsonBodyErr) }</span>

func (*WriteResponseError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;WriteResponseError{MyError: myError.MyError{Msg: array.New([]string{"写入响应失败", msg}).JoinWithoutEmpty("：")}}
}</span>

func (*WriteResponseError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;WriteResponseError{MyError: myError.MyError{Msg: fmt.Errorf("写入响应失败"+operation.Ternary(err != nil, "：%w", "%w"), err).Error()}}
}</span>

func (*WriteResponseError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;WriteResponseError{MyError: myError.MyError{Msg: "写入响应失败"}}
}</span>

func (my *WriteResponseError) Error() string <span class="cov0" title="0">{ return my.MyError.Msg }</span>

func (my *WriteResponseError) Is(target error) bool <span class="cov0" title="0">{
        return reflect.DeepEqual(target, &amp;WriteResponseErr)
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package httpClientV2

import (
        "bytes"
        "encoding/base64"
        "encoding/json"
        "encoding/xml"
        "errors"
        "fmt"
        "io"
        "maps"
        "mime/multipart"
        "net/http"
        "net/url"
        "os"
        "time"

        "github.com/spf13/cast"

        "github.com/aid297/aid/dict/anyDictV2"
        "github.com/aid297/aid/operation/operationV2"
        "github.com/aid297/aid/str"
)

type (
        HTTPClientAttributer interface {
                Register(req *HTTPClient)
                Error() error
                ImplHTTPClientAttributer()
        }

        AttrURL                struct{ url string }
        AttrQueries            struct{ queries map[string]any }
        AttrMethod             struct{ method string }
        AttrAppendHeaderValues struct{ headers map[string][]any }
        AttrAppendHeaderValue  struct{ headers map[string]any }
        AttrSetHeaderValues    struct{ headers map[string][]any }
        AttrSetHeaderValue     struct{ headers map[string]any }
        AttrBody               struct {
                err         error
                body        []byte
                contentType ContentType
        }
        AttrTimeout          struct{ timeout time.Duration }
        AttrTransport        struct{ transport *http.Transport }
        AttrTransportDefault struct{ transport *http.Transport }
        AttrCert             struct{ cert []byte }
        AttrAutoCopyResBody  struct{ autoCopy bool }
)

func URL(urls ...any) HTTPClientAttributer <span class="cov8" title="1">{
        ins := &amp;AttrURL{url: ""}
        switch </span>{

        }
        <span class="cov8" title="1">if len(urls) == 0 </span>{<span class="cov0" title="0">
        }</span> else<span class="cov8" title="1"> if len(urls) == 1 </span><span class="cov0" title="0">{
                ins.url = cast.ToString(urls[0])
        }</span> else<span class="cov8" title="1"> {
                ins.url = str.APP.Buffer.JoinString(cast.ToStringSlice(urls)...)
        }</span>

        <span class="cov8" title="1">return ins</span>
}

func (my *AttrURL) Register(req *HTTPClient) <span class="cov8" title="1">{ req.url = my.url }</span>

func (my *AttrURL) Error() error <span class="cov0" title="0">{ return nil }</span>

func (*AttrURL) ImplHTTPClientAttributer() {<span class="cov0" title="0">}</span>

func Queries(queries map[string]any) *AttrQueries <span class="cov8" title="1">{
        if queries == nil </span><span class="cov0" title="0">{
                queries = map[string]any{}
        }</span>

        <span class="cov8" title="1">return &amp;AttrQueries{queries: queries}</span>
}

func (my *AttrQueries) Append(queries map[string]any) *AttrQueries <span class="cov0" title="0">{
        if len(queries) &gt; 0 </span><span class="cov0" title="0">{
                maps.Copy(my.queries, queries)
        }</span>

        <span class="cov0" title="0">return my</span>
}

func (my *AttrQueries) AppendOne(key string, value any) *AttrQueries <span class="cov0" title="0">{
        my.queries[key] = value
        return my
}</span>

func (my *AttrQueries) RemoveEmpty() *AttrQueries <span class="cov0" title="0">{
        my.queries = anyDictV2.New(anyDictV2.Map(my.queries)).RemoveEmpty().ToMap()
        return my
}</span>

func (my *AttrQueries) Register(req *HTTPClient) <span class="cov8" title="1">{ req.queries = my.queries }</span>

func (my *AttrQueries) Error() error <span class="cov0" title="0">{ return nil }</span>

func (*AttrQueries) ImplHTTPClientAttributer() {<span class="cov0" title="0">}</span>

func Method(method string) *AttrMethod <span class="cov8" title="1">{
        return &amp;AttrMethod{method: method}
}</span>

func (my *AttrMethod) Register(req *HTTPClient) <span class="cov8" title="1">{ req.method = my.method }</span>

func (my *AttrMethod) Error() error <span class="cov0" title="0">{ return nil }</span>

func (*AttrMethod) ImplHTTPClientAttributer() {<span class="cov0" title="0">}</span>

func AppendHeaderValue(headers map[string]any) *AttrAppendHeaderValue <span class="cov0" title="0">{
        if headers == nil </span><span class="cov0" title="0">{
                headers = map[string]any{}
        }</span>

        <span class="cov0" title="0">return &amp;AttrAppendHeaderValue{headers: headers}</span>
}

func (my *AttrAppendHeaderValue) Append(headers map[string]any) *AttrAppendHeaderValue <span class="cov0" title="0">{
        if len(headers) &gt; 0 </span><span class="cov0" title="0">{
                maps.Copy(my.headers, headers)
        }</span>

        <span class="cov0" title="0">return my</span>
}

func (my *AttrAppendHeaderValue) AppendOne(key string, value any) *AttrAppendHeaderValue <span class="cov0" title="0">{
        my.headers[key] = value
        return my
}</span>

func (my *AttrAppendHeaderValue) ContentType(contentType ContentType) *AttrAppendHeaderValue <span class="cov0" title="0">{
        my.headers["Content-Type"] = ContentTypes[contentType]
        return my
}</span>

func (my *AttrAppendHeaderValue) Accept(accept Accept) *AttrAppendHeaderValue <span class="cov0" title="0">{
        my.headers["Accept"] = Accepts[accept]
        return my
}</span>

func (my *AttrAppendHeaderValue) Authorization(username, password, title string) *AttrAppendHeaderValue <span class="cov0" title="0">{
        my.headers["Authorization"] = str.APP.Buffer.NewString(title, " ", base64.StdEncoding.EncodeToString(fmt.Appendf(nil, "%s:%s", username, password))).String()
        return my
}</span>

func (my *AttrAppendHeaderValue) Register(req *HTTPClient) <span class="cov0" title="0">{
        if req.headers == nil </span><span class="cov0" title="0">{
                req.headers = map[string][]any{}
        }</span> else<span class="cov0" title="0"> {
                for key, values := range my.headers </span><span class="cov0" title="0">{
                        if _, exists := req.headers[key]; !exists </span><span class="cov0" title="0">{
                                req.headers[key] = []any{values}
                        }</span> else<span class="cov0" title="0"> {
                                req.headers[key] = append(req.headers[key], []any{values}...)
                        }</span>
                }
        }
}

func (my *AttrAppendHeaderValue) Error() error <span class="cov0" title="0">{ return nil }</span>

func (*AttrAppendHeaderValue) ImplHTTPClientAttributer() {<span class="cov0" title="0">}</span>

func AppendHeaderValues(headers map[string][]any) *AttrAppendHeaderValues <span class="cov8" title="1">{
        return operationV2.NewTernary(operationV2.TrueValue(&amp;AttrAppendHeaderValues{headers}), operationV2.FalseValue(&amp;AttrAppendHeaderValues{headers: map[string][]any{}})).GetByValue(len(headers) &gt; 0)
}</span>

func (my *AttrAppendHeaderValues) Append(headers map[string][]any) *AttrAppendHeaderValues <span class="cov0" title="0">{
        if len(headers) &gt; 0 </span><span class="cov0" title="0">{
                maps.Copy(my.headers, headers)
        }</span>

        <span class="cov0" title="0">return my</span>
}

func (my *AttrAppendHeaderValues) AppendOne(key string, values ...any) *AttrAppendHeaderValues <span class="cov0" title="0">{
        my.headers[key] = values
        return my
}</span>

func (my *AttrAppendHeaderValues) ContentType(contentType ContentType) *AttrAppendHeaderValues <span class="cov0" title="0">{
        my.headers["Content-Type"] = []any{ContentTypes[contentType]}
        return my
}</span>

func (my *AttrAppendHeaderValues) Accept(accept Accept) *AttrAppendHeaderValues <span class="cov0" title="0">{
        my.headers["Accept"] = []any{Accepts[accept]}
        return my
}</span>

func (my *AttrAppendHeaderValues) Authorization(username, password, title string) *AttrAppendHeaderValues <span class="cov0" title="0">{
        my.headers["Authorization"] = []any{str.APP.Buffer.NewString(title, " ", base64.StdEncoding.EncodeToString(fmt.Appendf(nil, "%s:%s", username, password))).String()}
        return my
}</span>

func (my *AttrAppendHeaderValues) Register(req *HTTPClient) <span class="cov8" title="1">{
        if req.headers == nil </span><span class="cov8" title="1">{
                req.headers = my.headers
        }</span> else<span class="cov0" title="0"> {
                for key, values := range my.headers </span><span class="cov0" title="0">{
                        if _, exists := req.headers[key]; !exists </span><span class="cov0" title="0">{
                                req.headers[key] = values
                        }</span> else<span class="cov0" title="0"> {
                                req.headers[key] = append(req.headers[key], values...)
                        }</span>
                }
        }
}

func (my *AttrAppendHeaderValues) Error() error <span class="cov0" title="0">{ return nil }</span>

func (*AttrAppendHeaderValues) ImplHTTPClientAttributer() {<span class="cov0" title="0">}</span>

func SetHeaderValue(headers map[string]any) *AttrSetHeaderValue <span class="cov8" title="1">{
        return operationV2.NewTernary(operationV2.TrueValue(&amp;AttrSetHeaderValue{headers}), operationV2.FalseValue(&amp;AttrSetHeaderValue{headers: map[string]any{}})).GetByValue(len(headers) &gt; 0)
}</span>

func (my *AttrSetHeaderValue) ContentType(contentType ContentType) *AttrSetHeaderValue <span class="cov8" title="1">{
        my.headers["Content-Type"] = ContentTypes[contentType]
        return my
}</span>

func (my *AttrSetHeaderValue) Accept(accept Accept) *AttrSetHeaderValue <span class="cov8" title="1">{
        my.headers["Accept"] = Accepts[accept]
        return my
}</span>

func (my *AttrSetHeaderValue) Authorization(username, password, title string) *AttrSetHeaderValue <span class="cov8" title="1">{
        my.headers["Authorization"] = str.APP.Buffer.NewString(title, " ", base64.StdEncoding.EncodeToString(fmt.Appendf(nil, "%s:%s", username, password))).String()
        return my
}</span>

func (my *AttrSetHeaderValue) Register(req *HTTPClient) <span class="cov8" title="1">{
        if req.headers == nil </span><span class="cov0" title="0">{
                req.headers = map[string][]any{}
        }</span> else<span class="cov8" title="1"> {
                for idx := range my.headers </span><span class="cov8" title="1">{
                        req.headers[idx] = []any{my.headers[idx]}
                }</span>
        }
}

func (my *AttrSetHeaderValue) Error() error <span class="cov0" title="0">{ return nil }</span>

func (*AttrSetHeaderValue) ImplHTTPClientAttributer() {<span class="cov0" title="0">}</span>

func SetHeaderValues(headers map[string][]any) *AttrSetHeaderValues <span class="cov0" title="0">{
        return operationV2.NewTernary(operationV2.TrueValue(&amp;AttrSetHeaderValues{headers: headers}), operationV2.FalseValue(&amp;AttrSetHeaderValues{headers: map[string][]any{}})).GetByValue(len(headers) &gt; 0)
}</span>

func (my *AttrSetHeaderValues) ContentType(contentType ContentType) *AttrSetHeaderValues <span class="cov0" title="0">{
        my.headers["Content-Type"] = []any{ContentTypes[contentType]}
        return my
}</span>

func (my *AttrSetHeaderValues) Accept(accept Accept) *AttrSetHeaderValues <span class="cov0" title="0">{
        my.headers["Accept"] = []any{Accepts[accept]}
        return my
}</span>

func (my *AttrSetHeaderValues) Authorization(username, password, title string) *AttrSetHeaderValues <span class="cov0" title="0">{
        my.headers["Authorization"] = []any{str.APP.Buffer.NewString(title, " ", base64.StdEncoding.EncodeToString(fmt.Appendf(nil, "%s:%s", username, password))).String()}
        return my
}</span>

func (my *AttrSetHeaderValues) Register(req *HTTPClient) <span class="cov0" title="0">{
        if req.headers == nil </span><span class="cov0" title="0">{
                req.headers = my.headers
        }</span> else<span class="cov0" title="0"> {
                maps.Copy(req.headers, my.headers)
        }</span>
}

func (my *AttrSetHeaderValues) Error() error <span class="cov0" title="0">{ return nil }</span>

func (*AttrSetHeaderValues) ImplHTTPClientAttributer() {<span class="cov0" title="0">}</span>

func JSON(body any) *AttrBody <span class="cov8" title="1">{
        ins := &amp;AttrBody{}
        ins.body, ins.err = json.Marshal(body)
        ins.contentType = ContentTypeJSON

        return ins
}</span>

func XML(body any) HTTPClientAttributer <span class="cov0" title="0">{
        ins := &amp;AttrBody{}
        ins.body, ins.err = xml.Marshal(body)
        ins.contentType = ContentTypeXML

        return ins
}</span>

func Form(body map[string]any) *AttrBody <span class="cov0" title="0">{
        ins := &amp;AttrBody{}
        params := url.Values{}
        for k, v := range body </span><span class="cov0" title="0">{
                params.Add(k, cast.ToString(v))
        }</span>
        <span class="cov0" title="0">ins.body = []byte(params.Encode())
        ins.contentType = ContentTypeXWwwFormURLencoded

        return ins</span>
}

func FormData(fields, files map[string]string) *AttrBody <span class="cov0" title="0">{
        var (
                e      error
                buffer bytes.Buffer
                ins    = &amp;AttrBody{}
        )

        writer := multipart.NewWriter(&amp;buffer)
        if len(fields) &gt; 0 </span><span class="cov0" title="0">{
                for k, v := range fields </span><span class="cov0" title="0">{
                        if e = writer.WriteField(k, v); e != nil </span><span class="cov0" title="0">{
                                ins.err = e
                                return ins
                        }</span>
                }
        }

        <span class="cov0" title="0">if len(files) &gt; 0 </span><span class="cov0" title="0">{
                for k, v := range files </span><span class="cov0" title="0">{
                        fileWriter, _ := writer.CreateFormFile("file", k)
                        file, e := os.Open(v)
                        if e != nil </span><span class="cov0" title="0">{
                                ins.err = e
                                return ins
                        }</span>
                        <span class="cov0" title="0">_, e = io.Copy(fileWriter, file)
                        if e != nil </span><span class="cov0" title="0">{
                                ins.err = e
                                return ins
                        }</span>

                        <span class="cov0" title="0">_ = file.Close()</span>
                }
        }

        <span class="cov0" title="0">ins.body = []byte(writer.FormDataContentType())
        ins.contentType = ContentTypeFormData

        return ins</span>
}

func Plain(body string) *AttrBody <span class="cov0" title="0">{
        ins := &amp;AttrBody{}
        ins.body = []byte(body)
        ins.contentType = ContentTypePlain

        return ins
}</span>

func HTML(body string) *AttrBody <span class="cov0" title="0">{
        ins := &amp;AttrBody{}
        ins.body = []byte(body)
        ins.contentType = ContentTypeXML

        return ins
}</span>

func CSS(body string) *AttrBody <span class="cov0" title="0">{
        ins := &amp;AttrBody{}
        ins.body = []byte(body)
        ins.contentType = ContentTypeCSS

        return ins
}</span>

func Javascript(body string) *AttrBody <span class="cov0" title="0">{
        ins := &amp;AttrBody{}
        ins.body = []byte(body)
        ins.contentType = ContentTypeJavascript

        return ins
}</span>

func Bytes(body []byte) *AttrBody <span class="cov0" title="0">{
        ins := &amp;AttrBody{body: body}

        return ins
}</span>

func Reader(body io.ReadCloser) *AttrBody <span class="cov0" title="0">{
        var (
                ins    = &amp;AttrBody{}
                buffer = bytes.NewBuffer([]byte{})
        )
        if body == nil </span><span class="cov0" title="0">{
                ins.err = errors.New("设置steam流失败：不能为空")
                return ins
        }</span>

        <span class="cov0" title="0">if _, ins.err = io.Copy(buffer, body); ins.err != nil </span><span class="cov0" title="0">{
                return ins
        }</span>
        <span class="cov0" title="0">ins.body = buffer.Bytes()

        return ins</span>
}

func File(filename string) *AttrBody <span class="cov0" title="0">{
        var (
                ins    = &amp;AttrBody{}
                file   *os.File
                buffer = bytes.NewBuffer([]byte{})
        )

        if file, ins.err = os.Open(filename); ins.err != nil </span><span class="cov0" title="0">{
                return ins
        }</span>
        <span class="cov0" title="0">defer func(file *os.File) </span><span class="cov0" title="0">{
                if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Failed to close file: %v", err)
                }</span>
        }(file)

        // 获取文件大小
        <span class="cov0" title="0">stat, _ := file.Stat()
        size := stat.Size()

        // 创建RequestBodyReader用于读取文件内容
        if size &gt; 1*1024*1024 </span><span class="cov0" title="0">{
                if _, ins.err = io.Copy(buffer, file); ins.err != nil </span><span class="cov0" title="0">{
                        return ins
                }</span>
                <span class="cov0" title="0">ins.body = buffer.Bytes()</span>
        } else<span class="cov0" title="0"> {
                if ins.body, ins.err = io.ReadAll(file); ins.err != nil </span><span class="cov0" title="0">{
                        return ins
                }</span>
        }

        <span class="cov0" title="0">return ins</span>
}

func (my *AttrBody) Register(req *HTTPClient) <span class="cov8" title="1">{
        req.requestBody = my.body
        if my.contentType != "" </span><span class="cov8" title="1">{
                req.headers["Content-Type"] = []any{ContentTypes[my.contentType]}
        }</span>
        <span class="cov8" title="1">req.err = my.err</span>
}

func (my *AttrBody) Error() error <span class="cov0" title="0">{ return my.err }</span>

func (*AttrBody) ImplHTTPClientAttributer() {<span class="cov0" title="0">}</span>

func Timeout(timeout time.Duration) *AttrTimeout <span class="cov8" title="1">{
        if timeout &lt;= 0 </span><span class="cov0" title="0">{
                timeout = 0
        }</span>

        <span class="cov8" title="1">return &amp;AttrTimeout{timeout: timeout}</span>
}

func (my *AttrTimeout) Register(req *HTTPClient) <span class="cov8" title="1">{ req.timeout = my.timeout }</span>

func (*AttrTimeout) Error() error <span class="cov0" title="0">{ return nil }</span>

func (*AttrTimeout) ImplHTTPClientAttributer() {<span class="cov0" title="0">}</span>

func Transport(transport *http.Transport) *AttrTransport <span class="cov8" title="1">{
        return &amp;AttrTransport{transport: transport}
}</span>

func (my *AttrTransport) Register(req *HTTPClient) <span class="cov8" title="1">{ req.transport = my.transport }</span>

func (my *AttrTransport) Error() error <span class="cov0" title="0">{ return nil }</span>

func (*AttrTransport) ImplHTTPClientAttributer() {<span class="cov0" title="0">}</span>

func TransportDefault() *AttrTransportDefault <span class="cov0" title="0">{
        return &amp;AttrTransportDefault{transport: &amp;http.Transport{
                MaxIdleConns:        100,
                MaxIdleConnsPerHost: 10,
                IdleConnTimeout:     90 * time.Second,
                TLSHandshakeTimeout: 10 * time.Second,
        }}
}</span>

func (my *AttrTransportDefault) Register(req *HTTPClient) <span class="cov0" title="0">{ req.transport = my.transport }</span>

func (my *AttrTransportDefault) Error() error <span class="cov0" title="0">{ return nil }</span>

func (*AttrTransportDefault) ImplHTTPClientAttributer() {<span class="cov0" title="0">}</span>

func Cert(cert []byte) *AttrCert <span class="cov8" title="1">{ return &amp;AttrCert{cert: cert} }</span>

func (my *AttrCert) Register(req *HTTPClient) <span class="cov8" title="1">{ req.cert = my.cert }</span>

func (my *AttrCert) Error() error <span class="cov0" title="0">{ return nil }</span>

func (*AttrCert) ImplHTTPClientAttributer() {<span class="cov0" title="0">}</span>

func AutoCopy(autoCopy bool) *AttrAutoCopyResBody <span class="cov8" title="1">{ return &amp;AttrAutoCopyResBody{autoCopy: autoCopy} }</span>

func (my *AttrAutoCopyResBody) Register(req *HTTPClient) <span class="cov8" title="1">{ req.autoCopy = my.autoCopy }</span>

func (*AttrAutoCopyResBody) Error() error <span class="cov0" title="0">{ return nil }</span>

func (*AttrAutoCopyResBody) ImplHTTPClientAttributer() {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package httpClientV2

import (
        "bytes"
        "crypto/tls"
        "crypto/x509"
        "encoding/json"
        "encoding/xml"
        "errors"
        "io"
        "net/http"
        "net/url"
        "sync"
        "time"

        jsonIter "github.com/json-iterator/go"
        "github.com/spf13/cast"

        "github.com/aid297/aid/operation/operationV2"
        "github.com/aid297/aid/str"
)

type (
        HTTPClient struct {
                err                       error
                url                       string
                queries                   map[string]any
                method                    string
                headers                   map[string][]any
                requestBody, responseBody []byte
                timeout                   time.Duration
                transport                 *http.Transport
                cert                      []byte
                rawRequest                *http.Request
                rawResponse               *http.Response
                client                    *http.Client
                autoCopy                  bool
                lock                      sync.RWMutex
        }

        HTTPClientBuilder struct {
                attrs []HTTPClientAttributer
        }
)

func (*HTTPClient) init(method string, attrs ...HTTPClientAttributer) *HTTPClient <span class="cov8" title="1">{
        return new(HTTPClient).SetAttrs(Method(method), AppendHeaderValues(map[string][]any{})).SetAttrs(attrs...)
}</span>

func (*HTTPClientBuilder) New(attrs ...HTTPClientAttributer) *HTTPClientBuilder <span class="cov0" title="0">{
        return &amp;HTTPClientBuilder{attrs: attrs}
}</span>

func (my *HTTPClientBuilder) GetClient() *HTTPClient <span class="cov0" title="0">{
        return new(HTTPClient).init(http.MethodGet, my.attrs...)
}</span>

func (*HTTPClient) New(attrs ...HTTPClientAttributer) *HTTPClient <span class="cov8" title="1">{
        return new(HTTPClient).init(http.MethodGet, attrs...)
}</span>

func (*HTTPClient) GET(attrs ...HTTPClientAttributer) *HTTPClient <span class="cov0" title="0">{
        return new(HTTPClient).init(http.MethodGet, attrs...)
}</span>

func (*HTTPClient) POST(attrs ...HTTPClientAttributer) *HTTPClient <span class="cov0" title="0">{
        return new(HTTPClient).init(http.MethodPost, attrs...)
}</span>

func (*HTTPClient) PUT(attrs ...HTTPClientAttributer) *HTTPClient <span class="cov0" title="0">{
        return new(HTTPClient).init(http.MethodPut, attrs...)
}</span>

func (*HTTPClient) PATCH(attrs ...HTTPClientAttributer) *HTTPClient <span class="cov0" title="0">{
        return new(HTTPClient).init(http.MethodPatch, attrs...)
}</span>

func (*HTTPClient) DELETE(attrs ...HTTPClientAttributer) *HTTPClient <span class="cov0" title="0">{
        return new(HTTPClient).init(http.MethodDelete, attrs...)
}</span>

func (*HTTPClient) HEAD(attrs ...HTTPClientAttributer) *HTTPClient <span class="cov0" title="0">{
        return new(HTTPClient).init(http.MethodHead, attrs...)
}</span>

func (*HTTPClient) OPTIONS(attrs ...HTTPClientAttributer) *HTTPClient <span class="cov0" title="0">{
        return new(HTTPClient).init(http.MethodOptions, attrs...)
}</span>

func (*HTTPClient) TRACE(attrs ...HTTPClientAttributer) *HTTPClient <span class="cov0" title="0">{
        return new(HTTPClient).init(http.MethodTrace, attrs...)
}</span>

func (my *HTTPClient) set(attrs ...HTTPClientAttributer) <span class="cov8" title="1">{
        if len(attrs) &gt; 0 </span><span class="cov8" title="1">{
                for _, option := range attrs </span><span class="cov8" title="1">{
                        option.Register(my)
                        if my.err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}

func (my *HTTPClient) SetAttrs(attrs ...HTTPClientAttributer) *HTTPClient <span class="cov8" title="1">{
        my.lock.Lock()
        defer my.lock.Unlock()

        my.set(attrs...)

        return my
}</span>

func (my *HTTPClient) GetURL() string <span class="cov8" title="1">{
        my.lock.RLock()
        defer my.lock.RUnlock()

        return my.getURL()
}</span>

func (my *HTTPClient) getURL() string <span class="cov8" title="1">{
        queries := url.Values{}
        if len(my.queries) &gt; 0 </span><span class="cov8" title="1">{
                for k, v := range my.queries </span><span class="cov8" title="1">{
                        queries.Add(k, cast.ToString(v))
                }</span>
        }

        <span class="cov8" title="1">if len(queries) &gt; 0 </span><span class="cov8" title="1">{
                return str.APP.Buffer.NewString(my.url).S("?").S(queries.Encode()).String()
        }</span>

        <span class="cov0" title="0">return my.url</span>
}

func (my *HTTPClient) GetQueries() map[string]any <span class="cov8" title="1">{
        my.lock.RLock()
        defer my.lock.RUnlock()

        return my.getQueries()
}</span>

func (my *HTTPClient) getQueries() map[string]any <span class="cov8" title="1">{ return my.queries }</span>

func (my *HTTPClient) GetMethod() string <span class="cov8" title="1">{
        my.lock.RLock()
        defer my.lock.RUnlock()

        return my.getMethod()
}</span>

func (my *HTTPClient) getMethod() string <span class="cov8" title="1">{ return my.method }</span>

func (my *HTTPClient) GetHeaders() map[string][]any <span class="cov8" title="1">{
        my.lock.RLock()
        defer my.lock.RUnlock()

        return my.getHeaders()
}</span>

func (my *HTTPClient) getHeaders() map[string][]any <span class="cov8" title="1">{ return my.headers }</span>

func (my *HTTPClient) GetBody() []byte <span class="cov8" title="1">{
        my.lock.RLock()
        defer my.lock.RUnlock()

        return my.getBody()
}</span>

func (my *HTTPClient) getBody() []byte <span class="cov8" title="1">{ return my.requestBody }</span>

func (my *HTTPClient) GetTimeout() time.Duration <span class="cov8" title="1">{
        my.lock.RLock()
        defer my.lock.RUnlock()

        return my.getTimeout()
}</span>

func (my *HTTPClient) getTimeout() time.Duration <span class="cov8" title="1">{ return my.timeout }</span>

func (my *HTTPClient) GetTransport() *http.Transport <span class="cov8" title="1">{
        my.lock.RLock()
        defer my.lock.RUnlock()

        return my.getTransport()
}</span>

func (my *HTTPClient) getTransport() *http.Transport <span class="cov8" title="1">{ return my.transport }</span>

func (my *HTTPClient) GetCert() []byte <span class="cov0" title="0">{
        my.lock.RLock()
        defer my.lock.RUnlock()

        return my.getCert()
}</span>

func (my *HTTPClient) getCert() []byte <span class="cov0" title="0">{ return my.cert }</span>

func (my *HTTPClient) GetRawRequest() *http.Request <span class="cov0" title="0">{
        my.lock.RLock()
        defer my.lock.RUnlock()

        return my.getRawRequest()
}</span>

func (my *HTTPClient) getRawRequest() *http.Request <span class="cov0" title="0">{ return my.rawRequest }</span>

func (my *HTTPClient) GetRawResponse() *http.Response <span class="cov0" title="0">{
        my.lock.RLock()
        defer my.lock.RUnlock()

        return my.getRawResponse()
}</span>

func (my *HTTPClient) getRawResponse() *http.Response <span class="cov0" title="0">{ return my.rawResponse }</span>

func (my *HTTPClient) GetClient() *http.Client <span class="cov0" title="0">{
        my.lock.RLock()
        defer my.lock.RUnlock()

        return my.getClient()
}</span>

func (my *HTTPClient) getClient() *http.Client <span class="cov0" title="0">{ return my.client }</span>

func (my *HTTPClient) send() *HTTPClient <span class="cov8" title="1">{
        if my.err != nil </span><span class="cov0" title="0">{
                return my
        }</span>

        <span class="cov8" title="1">if my.rawRequest, my.err = http.NewRequest(my.method, my.getURL(), bytes.NewReader(my.requestBody)); my.err != nil </span><span class="cov0" title="0">{
                return my
        }</span>

        <span class="cov8" title="1">for key, values := range my.headers </span><span class="cov8" title="1">{
                v := make([]string, 0, len(values))
                for idx := range values </span><span class="cov8" title="1">{
                        v = append(v, cast.ToString(values[idx]))
                }</span>
                <span class="cov8" title="1">my.rawRequest.Header[key] = append(my.rawRequest.Header[key], v...)</span>
        }

        <span class="cov8" title="1">if len(my.cert) &gt; 0 </span><span class="cov0" title="0">{
                certPool := x509.NewCertPool()
                if !certPool.AppendCertsFromPEM(my.cert) </span><span class="cov0" title="0">{
                        my.err = errors.New("生成TLS证书失败")
                        return my
                }</span>

                <span class="cov0" title="0">my.transport.TLSClientConfig = &amp;tls.Config{RootCAs: certPool}</span>
        }

        <span class="cov8" title="1">my.client = &amp;http.Client{}

        // 发送新的请求
        if my.transport != nil </span><span class="cov8" title="1">{
                my.client.Transport = my.transport
        }</span>

        // 设置超时
        <span class="cov8" title="1">if my.timeout &gt; 0 </span><span class="cov8" title="1">{
                my.client.Timeout = my.timeout
        }</span>

        <span class="cov8" title="1">if my.rawResponse, my.err = my.client.Do(my.rawRequest); my.err != nil </span><span class="cov0" title="0">{
                return my
        }</span>

        <span class="cov8" title="1">if my.autoCopy </span><span class="cov0" title="0">{
                my.parseBody()
                my.rawResponse.Body = io.NopCloser(bytes.NewBuffer(my.responseBody)) // 还原响应体
        }</span>

        <span class="cov8" title="1">return my</span>
}

func (my *HTTPClient) SendWithRetry(count uint, interval time.Duration, condition func(statusCode int, err error) bool) *HTTPClient <span class="cov0" title="0">{
        my.lock.Lock()
        defer my.lock.Unlock()

        if my.send().Error() != nil </span><span class="cov0" title="0">{
                return my
        }</span>

        <span class="cov0" title="0">if count &gt; 0 &amp;&amp; interval &gt; 0 </span><span class="cov0" title="0">{
                var (
                        maxAttempts uint = count + 1 // 首次尝试 + 重试次数
                        shouldRetry      = false
                )

                for attempt := uint(0); attempt &lt; maxAttempts; attempt++ </span><span class="cov0" title="0">{
                        time.Sleep(interval)

                        if condition == nil </span><span class="cov0" title="0">{
                                condition = func(statusCode int, err error) bool </span><span class="cov0" title="0">{ return statusCode &gt; 399 || err != nil }</span>
                        }
                        <span class="cov0" title="0">shouldRetry = condition(my.rawResponse.StatusCode, my.err)

                        if !shouldRetry || attempt == maxAttempts-1 </span><span class="cov0" title="0">{
                                break</span>
                        }

                        <span class="cov0" title="0">if my.rawResponse != nil &amp;&amp; my.rawResponse.Body != nil </span><span class="cov0" title="0">{
                                _ = my.rawResponse.Body.Close()
                                my.rawResponse = nil
                        }</span>
                }
        }

        <span class="cov0" title="0">return my</span>
}

func (my *HTTPClient) Send() *HTTPClient <span class="cov8" title="1">{
        my.lock.Lock()
        defer my.lock.Unlock()

        return my.send()
}</span>

func (my *HTTPClient) parseBody() <span class="cov8" title="1">{
        var (
                buffer  = bytes.NewBuffer([]byte{})
                written int64
        )

        if my.err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">my.responseBody = []byte{}

        if my.rawResponse == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // 读取新地响应的主体
        <span class="cov8" title="1">if my.rawResponse.ContentLength &gt; 1*1024*1024 </span><span class="cov0" title="0">{ // 1MB
                if written, my.err = io.Copy(buffer, my.rawResponse.Body); my.err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">if written &lt; 1 </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">if buffer.Len() == 0 </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">my.responseBody = buffer.Bytes()</span>
        } else<span class="cov8" title="1"> {
                if my.responseBody, my.err = io.ReadAll(my.rawResponse.Body); my.err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
}

func (my *HTTPClient) ToJSON(target any, keys ...any) *HTTPClient <span class="cov0" title="0">{
        my.lock.RLock()
        defer my.lock.RUnlock()
        defer func() </span><span class="cov0" title="0">{ _ = my.rawResponse.Body.Close() }</span>()

        <span class="cov0" title="0">if my.err != nil </span><span class="cov0" title="0">{
                return my
        }</span>

        <span class="cov0" title="0">if my.responseBody == nil </span><span class="cov0" title="0">{
                my.parseBody()
        }</span>

        <span class="cov0" title="0">if len(my.responseBody) == 0 </span><span class="cov0" title="0">{
                return my
        }</span>

        <span class="cov0" title="0">if len(keys) &gt; 0 </span><span class="cov0" title="0">{
                jsonIter.Get(my.responseBody, keys...).ToVal(&amp;target)
        }</span> else<span class="cov0" title="0"> {
                my.err = json.Unmarshal(my.responseBody, &amp;target)
        }</span>
        <span class="cov0" title="0">return my</span>
}

func (my *HTTPClient) ToXML(target any) *HTTPClient <span class="cov0" title="0">{
        my.lock.RLock()
        defer my.lock.RUnlock()
        defer func() </span><span class="cov0" title="0">{ _ = my.rawResponse.Body.Close() }</span>()

        <span class="cov0" title="0">if my.err != nil </span><span class="cov0" title="0">{
                return my
        }</span>

        <span class="cov0" title="0">if my.responseBody == nil </span><span class="cov0" title="0">{
                my.parseBody()
        }</span>

        <span class="cov0" title="0">if len(my.responseBody) == 0 </span><span class="cov0" title="0">{
                return my
        }</span>

        <span class="cov0" title="0">my.err = xml.Unmarshal(my.responseBody, &amp;target)

        return my</span>
}

func (my *HTTPClient) ToBytes() []byte <span class="cov8" title="1">{
        my.lock.RLock()
        defer my.lock.RUnlock()
        defer func() </span><span class="cov8" title="1">{ _ = my.rawResponse.Body.Close() }</span>()

        <span class="cov8" title="1">if my.err != nil </span><span class="cov0" title="0">{
                return []byte{}
        }</span>

        <span class="cov8" title="1">if my.responseBody == nil </span><span class="cov8" title="1">{
                my.parseBody()
        }</span>

        <span class="cov8" title="1">if len(my.responseBody) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return my.responseBody</span>
}

func (my *HTTPClient) ToWriter(writer http.ResponseWriter) *HTTPClient <span class="cov0" title="0">{
        my.lock.RLock()
        defer my.lock.RUnlock()
        defer func() </span><span class="cov0" title="0">{ _ = my.rawResponse.Body.Close() }</span>()

        <span class="cov0" title="0">if my.err != nil </span><span class="cov0" title="0">{
                return my
        }</span>

        <span class="cov0" title="0">_, my.err = io.Copy(writer, my.rawResponse.Body)
        return my</span>
}

func (my *HTTPClient) Error() error <span class="cov8" title="1">{
        var err error
        defer func() </span><span class="cov8" title="1">{ my.err = nil }</span>()

        <span class="cov8" title="1">err = my.err
        return err</span>
}

func (my *HTTPClient) GetStatusCode() int <span class="cov0" title="0">{
        return operationV2.NewTernary(operationV2.TrueFn(func() int </span><span class="cov0" title="0">{ return my.GetRawResponse().StatusCode }</span>)).GetByValue(my.GetRawResponse() != nil)
}

func (my *HTTPClient) GetStatus() string <span class="cov0" title="0">{
        return operationV2.NewTernary(operationV2.TrueFn(func() string </span><span class="cov0" title="0">{ return my.GetRawResponse().Status }</span>)).GetByValue(my.GetRawResponse() != nil)
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package httpClient

import (
        "bytes"
        "crypto/tls"
        "crypto/x509"
        "encoding/base64"
        "encoding/json"
        "encoding/xml"
        "fmt"
        "io"
        "mime/multipart"
        "net/http"
        "net/url"
        "os"
        "sync"
        "time"

        jsonIter "github.com/json-iterator/go"

        "github.com/aid297/aid/operation"
        "github.com/aid297/aid/str"
)

type (
        // HttpClient http客户端
        HttpClient struct {
                Err                error
                requestUrl         string
                requestQueries     map[string]string
                requestMethod      string
                requestBody        []byte
                requestHeaders     map[string][]string
                request            *http.Request
                response           *http.Response
                responseBody       []byte
                responseBodyBuffer *bytes.Buffer
                isReady            bool
                cert               []byte
                transport          *http.Transport
                timeoutSecond      int64
                lock               sync.RWMutex
        }
)

var App HttpClient

func (*HttpClient) New(url string) *HttpClient       <span class="cov0" title="0">{ return NewHttpClient(url) }</span>
func (*HttpClient) NewGet(url string) *HttpClient    <span class="cov0" title="0">{ return NewGet(url) }</span>
func (*HttpClient) NewPost(url string) *HttpClient   <span class="cov0" title="0">{ return NewPost(url) }</span>
func (*HttpClient) NewPut(url string) *HttpClient    <span class="cov0" title="0">{ return NewPut(url) }</span>
func (*HttpClient) NewDelete(url string) *HttpClient <span class="cov0" title="0">{ return NewDelete(url) }</span>

// NewHttpClient 实例化：http客户端
//
//go:fix 推荐使用New方法
func NewHttpClient(urls ...string) *HttpClient <span class="cov0" title="0">{
        return &amp;HttpClient{
                requestUrl:         str.APP.Buffer.NewString(operation.TernaryFuncAll(func() bool </span><span class="cov0" title="0">{ return len(urls) == 0 }</span>, func() string <span class="cov0" title="0">{ return "" }</span>, func() string <span class="cov0" title="0">{ return urls[0] }</span>)).S(urls[1:]...).String(),
                requestQueries:     map[string]string{},
                requestHeaders:     map[string][]string{"Accept": {}, "Content-Type": {}},
                responseBody:       []byte{},
                responseBodyBuffer: bytes.NewBuffer([]byte{}),
                transport:          &amp;http.Transport{
                        // DisableKeepAlives:   true,             // 禁用连接复用
                        // MaxIdleConns:        100,              // 最大空闲连接数
                        // IdleConnTimeout:     90 * time.Second, // 空闲连接超时时间
                        // TLSHandshakeTimeout: 10 * time.Second, // TLS握手超时时间
                },
        }
}

// NewGet 实例化：http客户端get请求
//
//go:fix 推荐使用NewGet方法
func NewGet(urls ...string) *HttpClient <span class="cov0" title="0">{
        return NewHttpClient(urls...).SetMethod(http.MethodGet)
}</span>

// NewPost 实例化：http客户端post请求
//
//go:fix 推荐使用NewPost方法
func NewPost(urls ...string) *HttpClient <span class="cov0" title="0">{
        return NewHttpClient(urls...).SetMethod(http.MethodPost)
}</span>

// NewPut 实例化：http客户端put请求
//
//go:fix 推荐使用NewPut方法
func NewPut(urls ...string) *HttpClient <span class="cov0" title="0">{
        return NewHttpClient(urls...).SetMethod(http.MethodPut)
}</span>

// NewDelete 实例化：http客户端delete请求
//
//go:fix 推荐使用NewDelete方法
func NewDelete(urls ...string) *HttpClient <span class="cov0" title="0">{
        return NewHttpClient(urls...).SetMethod(http.MethodDelete)
}</span>

// SetCert 设置SSL证书
func (my *HttpClient) SetCert(filename string) *HttpClient <span class="cov0" title="0">{
        my.lock.Lock()
        defer my.lock.Unlock()

        var e error

        // 读取证书文件
        if my.cert, e = os.ReadFile(filename); e != nil </span><span class="cov0" title="0">{
                my.Err = e
        }</span>

        <span class="cov0" title="0">return my</span>
}

// SetUrl 设置请求地址
func (my *HttpClient) SetUrl(urls ...string) *HttpClient <span class="cov0" title="0">{
        my.lock.Lock()
        defer my.lock.Unlock()

        my.requestUrl = str.APP.Buffer.NewString(operation.TernaryFuncAll(func() bool </span><span class="cov0" title="0">{ return len(urls) == 0 }</span>, func() string <span class="cov0" title="0">{ return "" }</span>, func() string <span class="cov0" title="0">{ return urls[0] }</span>)).S(urls[1:]...).String()
        <span class="cov0" title="0">return my</span>
}

// SetMethod 设置请求方法
func (my *HttpClient) SetMethod(method string) *HttpClient <span class="cov0" title="0">{
        my.lock.Lock()
        defer my.lock.Unlock()

        my.requestMethod = method
        return my
}</span>

// SetHeaders 设置请求头
func (my *HttpClient) SetHeaders(headers map[string][]string) *HttpClient <span class="cov0" title="0">{
        my.lock.Lock()
        defer my.lock.Unlock()

        my.requestHeaders = headers
        return my
}</span>

// AddHeaders 追加请求头
func (my *HttpClient) AddHeaders(headers map[string][]string) *HttpClient <span class="cov0" title="0">{
        my.lock.Lock()
        defer my.lock.Unlock()

        for k, v := range headers </span><span class="cov0" title="0">{
                my.requestHeaders[k] = append(my.requestHeaders[k], v...)
        }</span>

        <span class="cov0" title="0">return my</span>
}

// SetQueries 设置请求参数
func (my *HttpClient) SetQueries(queries map[string]string) *HttpClient <span class="cov0" title="0">{
        my.lock.Lock()
        defer my.lock.Unlock()

        my.requestQueries = queries
        return my
}</span>

// SetAuthorization 设置认证
func (my *HttpClient) SetAuthorization(username, password, title string) *HttpClient <span class="cov0" title="0">{
        my.lock.Lock()
        defer my.lock.Unlock()

        my.requestHeaders["Authorization"] = []string{str.APP.Buffer.NewString(title).S(" ", base64.StdEncoding.EncodeToString(fmt.Appendf(nil, "%s:%s", username, password))).String()}
        return my
}</span>

// SetBody 设置请求体
func (my *HttpClient) SetBody(body []byte) *HttpClient <span class="cov0" title="0">{
        my.lock.Lock()
        defer my.lock.Unlock()

        my.requestBody = body
        return my
}</span>

// SetJsonBody 设置json请求体
func (my *HttpClient) SetJsonBody(body any) *HttpClient <span class="cov0" title="0">{
        my.lock.Lock()
        defer my.lock.Unlock()

        my.setHeaderContentType(ContentTypeJson)
        my.requestBody, my.Err = json.Marshal(body)
        if my.Err != nil </span><span class="cov0" title="0">{
                my.Err = SetJsonBodyErr.Wrap(my.Err)
        }</span>

        <span class="cov0" title="0">return my</span>
}

// SetXmlBody 设置xml请求体
func (my *HttpClient) SetXmlBody(body any) *HttpClient <span class="cov0" title="0">{
        my.lock.Lock()
        defer my.lock.Unlock()

        my.setHeaderContentType(ContentTypeXml)
        my.requestBody, my.Err = xml.Marshal(body)
        if my.Err != nil </span><span class="cov0" title="0">{
                my.Err = SetXmlBodyErr.Wrap(my.Err)
        }</span>

        <span class="cov0" title="0">return my</span>
}

// SetFormBody 设置表单请求体
func (my *HttpClient) SetFormBody(body map[string]string) *HttpClient <span class="cov0" title="0">{
        my.lock.Lock()
        defer my.lock.Unlock()

        my.setHeaderContentType(ContentTypeForm)
        params := url.Values{}
        for k, v := range body </span><span class="cov0" title="0">{
                params.Add(k, v)
        }</span>
        <span class="cov0" title="0">my.requestBody = []byte(params.Encode())

        return my</span>
}

// SetFormDataBody 设置表单数据请求体
func (my *HttpClient) SetFormDataBody(texts map[string]string, files map[string]string) *HttpClient <span class="cov0" title="0">{
        my.lock.Lock()
        defer my.lock.Unlock()

        var (
                e      error
                buffer bytes.Buffer
        )

        my.setHeaderContentType("form-data")
        writer := multipart.NewWriter(&amp;buffer)
        if len(texts) &gt; 0 </span><span class="cov0" title="0">{
                for k, v := range texts </span><span class="cov0" title="0">{
                        e = writer.WriteField(k, v)
                        if e != nil </span><span class="cov0" title="0">{
                                my.Err = SetFormBodyErr.Wrap(e)
                                return my
                        }</span>
                }
        }

        <span class="cov0" title="0">if len(files) &gt; 0 </span><span class="cov0" title="0">{
                for k, v := range files </span><span class="cov0" title="0">{
                        fileWriter, _ := writer.CreateFormFile("fileField", k)
                        file, e := os.Open(v)
                        if e != nil </span><span class="cov0" title="0">{
                                my.Err = SetFormBodyErr.Wrap(e)
                                return my
                        }</span>
                        <span class="cov0" title="0">_, e = io.Copy(fileWriter, file)
                        if e != nil </span><span class="cov0" title="0">{
                                my.Err = SetFormBodyErr.Wrap(e)
                                return my
                        }</span>

                        <span class="cov0" title="0">_ = file.Close()</span>
                }
        }

        <span class="cov0" title="0">my.requestBody = []byte(writer.FormDataContentType())

        return my</span>
}

// SetPlainBody 设置纯文本请求体
func (my *HttpClient) SetPlainBody(text string) *HttpClient <span class="cov0" title="0">{
        my.lock.Lock()
        defer my.lock.Unlock()

        my.setHeaderContentType(ContentTypePlain)
        my.requestBody = []byte(text)

        return my
}</span>

// SetHtmlBody 设置html请求体
func (my *HttpClient) SetHtmlBody(text string) *HttpClient <span class="cov0" title="0">{
        my.lock.Lock()
        defer my.lock.Unlock()

        my.setHeaderContentType(ContentTypeHtml)
        my.requestBody = []byte(text)

        return my
}</span>

// SetCssBody 设置Css请求体
func (my *HttpClient) SetCssBody(text string) *HttpClient <span class="cov0" title="0">{
        my.lock.Lock()
        defer my.lock.Unlock()

        my.setHeaderContentType(ContentTypeCss)
        my.requestBody = []byte(text)

        return my
}</span>

// SetJavascriptBody 设置Javascript请求体
func (my *HttpClient) SetJavascriptBody(text string) *HttpClient <span class="cov0" title="0">{
        my.lock.Lock()
        defer my.lock.Unlock()

        my.setHeaderContentType(ContentTypeJavascript)
        my.requestBody = []byte(text)

        return my
}</span>

// SetSteamBodyByReader 设置字节码内容：通过readCloser接口
func (my *HttpClient) SetSteamBodyByReader(reader io.ReadCloser) *HttpClient <span class="cov0" title="0">{
        my.lock.Lock()
        defer my.lock.Unlock()

        my.setHeaderContentType(ContentTypeSteam)

        if reader == nil </span><span class="cov0" title="0">{
                my.Err = SetSteamBodyErr.Panic()
                return my
        }</span>

        // 创建RequestBodyReader用于读取文件内容
        <span class="cov0" title="0">if my.responseBodyBuffer.Len() &gt; 1*1024*1024 </span><span class="cov0" title="0">{ // 1MB
                _, my.Err = io.Copy(my.responseBodyBuffer, reader)
                if my.Err != nil </span><span class="cov0" title="0">{
                        my.Err = ReadResponseErr.Wrap(my.Err)
                        return my
                }</span>
                <span class="cov0" title="0">my.requestBody = my.responseBodyBuffer.Bytes()</span>
        } else<span class="cov0" title="0"> {
                my.requestBody, my.Err = io.ReadAll(reader)
                if my.Err != nil </span><span class="cov0" title="0">{
                        my.Err = ReadResponseErr.Wrap(my.Err)
                        return my
                }</span>
        }

        <span class="cov0" title="0">return my</span>
}

// SetSteamBodyByFile 设置字节码内容：通过文件
func (my *HttpClient) SetSteamBodyByFile(filename string) *HttpClient <span class="cov0" title="0">{
        my.lock.Lock()
        defer my.lock.Unlock()

        var (
                err  error
                file *os.File
        )

        my.setHeaderContentType(ContentTypeSteam)

        file, err = os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                my.Err = SetSteamBodyErr.Wrap(err)
                return my
        }</span>
        <span class="cov0" title="0">defer func(file *os.File) </span><span class="cov0" title="0">{
                if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Failed to close file: %v", err)
                }</span>
        }(file)

        // 获取文件大小
        <span class="cov0" title="0">stat, _ := file.Stat()
        size := stat.Size()

        // 创建RequestBodyReader用于读取文件内容
        if size &gt; 1*1024*1024 </span><span class="cov0" title="0">{
                _, my.Err = io.Copy(my.responseBodyBuffer, file)
                if my.Err != nil </span><span class="cov0" title="0">{
                        my.Err = ReadResponseErr.Wrap(my.Err)
                        return my
                }</span>
                <span class="cov0" title="0">my.requestBody = my.responseBodyBuffer.Bytes()</span>
        } else<span class="cov0" title="0"> {
                my.requestBody, err = io.ReadAll(file)
                if err != nil </span><span class="cov0" title="0">{
                        my.Err = ReadResponseErr.Wrap(err)
                        return my
                }</span>
        }

        // my.request.Header.Set("Content-Length", fmt.Sprintf("%d", size))

        <span class="cov0" title="0">return my</span>
}

func (my *HttpClient) SetHeaderContentType(key ContentType) *HttpClient <span class="cov0" title="0">{
        my.lock.Lock()
        defer my.lock.Unlock()

        my.setHeaderContentType(key)
        return my
}</span>

// setHeaderContentType 设置请求头内容类型
func (my *HttpClient) setHeaderContentType(key ContentType) <span class="cov0" title="0">{
        if val, ok := ContentTypes[key]; ok </span><span class="cov0" title="0">{
                my.requestHeaders["Content-Type"] = []string{val}
        }</span>
}

func (my *HttpClient) AppendHeaderContentType(keys ...ContentType) *HttpClient <span class="cov0" title="0">{
        my.lock.Lock()
        defer my.lock.Unlock()

        my.appendHeaderContentType(keys...)

        return my
}</span>

// appendHeaderContentType 追加请求头内容类型
func (my *HttpClient) appendHeaderContentType(keys ...ContentType) <span class="cov0" title="0">{

        values := make([]string, len(keys))
        for k, v := range keys </span><span class="cov0" title="0">{
                if val, ok := ContentTypes[v]; ok </span><span class="cov0" title="0">{
                        values[k] = val
                }</span>
        }

        <span class="cov0" title="0">if len(my.requestHeaders["Content-Type"]) == 0 </span><span class="cov0" title="0">{
                my.requestHeaders["Content-Type"] = values
        }</span> else<span class="cov0" title="0"> {
                my.requestHeaders["Content-Type"] = append(my.requestHeaders["Content-Type"], values...)
        }</span>
}

func (my *HttpClient) SetHeaderAccept(key Accept) *HttpClient <span class="cov0" title="0">{
        my.lock.Lock()
        defer my.lock.Unlock()

        my.setHeaderAccept(key)

        return my
}</span>

// setHeaderAccept 设置请求头接受内容类型
func (my *HttpClient) setHeaderAccept(key Accept) *HttpClient <span class="cov0" title="0">{
        if val, ok := Accepts[key]; ok </span><span class="cov0" title="0">{
                my.requestHeaders["Accept"] = []string{val}
        }</span>

        <span class="cov0" title="0">return my</span>
}

func (my *HttpClient) AppendHeaderAccept(keys ...Accept) *HttpClient <span class="cov0" title="0">{
        my.lock.Lock()
        defer my.lock.Unlock()

        my.appendHeaderAccept(keys...)

        return my
}</span>

// appendHeaderAccept 追加请求头接受内容类型
func (my *HttpClient) appendHeaderAccept(keys ...Accept) <span class="cov0" title="0">{
        values := make([]string, len(keys))
        for k, v := range keys </span><span class="cov0" title="0">{
                if val, ok := Accepts[v]; ok </span><span class="cov0" title="0">{
                        values[k] = val
                }</span>
        }

        <span class="cov0" title="0">if len(my.requestHeaders["Accept"]) == 0 </span><span class="cov0" title="0">{
                my.requestHeaders["Accept"] = values
        }</span> else<span class="cov0" title="0"> {
                my.requestHeaders["Accept"] = append(my.requestHeaders["Accept"], values...)
        }</span>
}

// SetTimeoutSecond 设置超时：秒
func (my *HttpClient) SetTimeoutSecond(timeoutSecond int64) *HttpClient <span class="cov0" title="0">{
        my.lock.Lock()
        defer my.lock.Unlock()

        my.timeoutSecond = timeoutSecond

        return my
}</span>

// SetTimeout 设置超时
func (my *HttpClient) SetTimeout(t time.Duration) *HttpClient <span class="cov0" title="0">{
        my.lock.Lock()
        defer my.lock.Unlock()

        if t &lt; 0 </span><span class="cov0" title="0">{
                my.timeoutSecond = 0
        }</span> else<span class="cov0" title="0"> {
                my.timeoutSecond = int64(t.Seconds())
        }</span>

        <span class="cov0" title="0">return my</span>
}

// GetTransport 获取自定义传输层
func (my *HttpClient) GetTransport() *http.Transport <span class="cov0" title="0">{
        my.lock.RLock()
        defer my.lock.RUnlock()

        return my.transport
}</span>

// SetTransport 设置自定义传输层
func (my *HttpClient) SetTransport(transport *http.Transport) *HttpClient <span class="cov0" title="0">{
        my.lock.RLock()
        defer my.lock.RUnlock()

        my.transport = transport

        return my
}</span>

func (my *HttpClient) GetResponse() *http.Response <span class="cov0" title="0">{
        my.lock.RLock()
        defer my.lock.RUnlock()

        return my.getResponse()
}</span>

// getResponse 获取响应对象
func (my *HttpClient) getResponse() *http.Response <span class="cov0" title="0">{ return my.response }</span>

// ParseByContentType 根据响应头Content-Type自动解析响应体
func (my *HttpClient) ParseByContentType(target any) *HttpClient <span class="cov0" title="0">{
        my.lock.RLock()
        defer my.lock.RUnlock()

        switch ContentType(my.getResponse().Header.Get("Content-Type")) </span>{
        case ContentTypeJson:<span class="cov0" title="0">
                my.getResponseJsonBody(target)</span>
        case ContentTypeXml:<span class="cov0" title="0">
                my.getResponseXmlBody(target)</span>
        }

        <span class="cov0" title="0">return my</span>
}

// GetResponseRawBody 获取原始响应体
func (my *HttpClient) GetResponseRawBody() []byte <span class="cov0" title="0">{
        my.lock.RLock()
        defer my.lock.RUnlock()

        return my.responseBody
}</span>

func (my *HttpClient) GetResponseJsonBody(target any, keys ...any) *HttpClient <span class="cov0" title="0">{
        my.lock.RLock()
        defer my.lock.RUnlock()

        return my.getResponseJsonBody(target, keys...)
}</span>

// getResponseJsonBody 获取json格式响应体
func (my *HttpClient) getResponseJsonBody(target any, keys ...any) *HttpClient <span class="cov0" title="0">{
        if my.responseBody == nil </span><span class="cov0" title="0">{
                return my
        }</span>

        <span class="cov0" title="0">if len(my.responseBody) == 0 </span><span class="cov0" title="0">{
                return my
        }</span>

        <span class="cov0" title="0">if len(keys) &gt; 0 </span><span class="cov0" title="0">{
                jsonIter.Get(my.responseBody, keys...).ToVal(&amp;target)
                return my
        }</span> else<span class="cov0" title="0"> {
                if e := json.Unmarshal(my.responseBody, &amp;target); e != nil </span><span class="cov0" title="0">{
                        my.Err = UnmarshalJsonErr.Wrap(e)
                }</span>
        }

        <span class="cov0" title="0">return my</span>
}

func (my *HttpClient) GetResponseXmlBody(target any) *HttpClient <span class="cov0" title="0">{
        my.lock.RLock()
        defer my.lock.RUnlock()

        return my.getResponseXmlBody(target)
}</span>

// getResponseXmlBody 获取xml格式响应体
func (my *HttpClient) getResponseXmlBody(target any) *HttpClient <span class="cov0" title="0">{
        if len(my.responseBody) == 0 </span><span class="cov0" title="0">{
                return my
        }</span>

        <span class="cov0" title="0">if e := xml.Unmarshal(my.responseBody, &amp;target); e != nil </span><span class="cov0" title="0">{
                my.Err = UnmarshalXmlErr.Wrap(e)
        }</span>

        <span class="cov0" title="0">return my</span>
}

// SaveResponseSteamFile 保存二进制到文件
//
//go:fix 建议使用Download方法
func (my *HttpClient) SaveResponseSteamFile(filename string) *HttpClient <span class="cov0" title="0">{
        my.lock.RLock()
        defer my.lock.RUnlock()

        if len(my.responseBody) == 0 </span><span class="cov0" title="0">{
                return my
        }</span>

        // 创建一个新的文件
        <span class="cov0" title="0">file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                my.Err = err
                return my
        }</span>

        // 将二进制数据写入文件
        <span class="cov0" title="0">_, err = file.Write(my.responseBody)
        if err != nil </span><span class="cov0" title="0">{
                my.Err = err
                return my
        }</span>

        <span class="cov0" title="0">my.Err = file.Close()

        return my</span>
}

// GetRequest 获取请求
func (my *HttpClient) GetRequest() *http.Request <span class="cov0" title="0">{
        my.lock.RLock()
        defer my.lock.RUnlock()

        return my.request
}</span>

func (my *HttpClient) GenerateRequest() *HttpClient <span class="cov0" title="0">{
        my.lock.RLock()
        defer my.lock.RUnlock()

        return my.generateRequest()
}</span>

// generateRequest 生成请求对象
func (my *HttpClient) generateRequest() *HttpClient <span class="cov0" title="0">{
        var e error

        // 设置url参数
        my.setQueries()

        my.request, e = http.NewRequest(my.requestMethod, my.requestUrl, bytes.NewReader(my.requestBody))
        if e != nil </span><span class="cov0" title="0">{
                my.Err = GenerateRequestErr.Wrap(e)
                return my
        }</span>

        // 设置请求头
        <span class="cov0" title="0">my.addHeaders()

        // 检查请求对象
        if my.Err = my.check(); my.Err != nil </span><span class="cov0" title="0">{
                return my
        }</span>

        // 创建一个新的证书池，并将证书添加到池中
        <span class="cov0" title="0">if len(my.cert) &gt; 0 </span><span class="cov0" title="0">{
                certPool := x509.NewCertPool()
                if !certPool.AppendCertsFromPEM(my.cert) </span><span class="cov0" title="0">{
                        my.Err = GenerateCertErr.Panic()
                        return my
                }</span>

                // 创建一个新的Transport
                <span class="cov0" title="0">my.transport.TLSClientConfig = &amp;tls.Config{RootCAs: certPool}</span>
        }

        <span class="cov0" title="0">my.isReady = true

        return my</span>
}

// beforeSend 发送请求前置动作
func (my *HttpClient) beforeSend() *http.Client <span class="cov0" title="0">{
        if !my.isReady </span><span class="cov0" title="0">{
                if my.generateRequest(); my.Err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        <span class="cov0" title="0">client := &amp;http.Client{}

        // 发送新的请求
        client.Transport = my.transport

        // 设置超时
        if my.timeoutSecond &gt; 0 </span><span class="cov0" title="0">{
                client.Timeout = time.Duration(my.timeoutSecond) * time.Second
        }</span>

        <span class="cov0" title="0">return client</span>
}

// Download 使用下载器下载文件
func (my *HttpClient) Download(filename string) *HttpClientDownload <span class="cov0" title="0">{
        my.lock.Lock()
        defer my.lock.Unlock()

        return HttpClientDownloadApp.New(my, filename)
}</span>

// Send 发送请求
func (my *HttpClient) Send() *HttpClient <span class="cov0" title="0">{
        my.lock.Lock()
        defer my.lock.Unlock()

        my.responseBodyBuffer.Reset() // 重置响应体缓存
        my.responseBody = []byte{}    // 重置响应体

        client := my.beforeSend()
        if my.Err != nil </span><span class="cov0" title="0">{
                return my
        }</span>

        <span class="cov0" title="0">my.request.Header.Set("Content-Length", fmt.Sprintf("%d", len(my.requestBody)))

        my.response, my.Err = client.Do(my.request)
        if my.Err != nil </span><span class="cov0" title="0">{
                return my
        }</span>
        <span class="cov0" title="0">defer my.response.Body.Close()

        // 读取新的响应的主体
        if my.response.ContentLength &gt; 1*1024*1024 </span><span class="cov0" title="0">{ // 1MB
                if _, my.Err = io.Copy(my.responseBodyBuffer, my.response.Body); my.Err != nil </span><span class="cov0" title="0">{
                        my.Err = ReadResponseErr.Wrap(my.Err)
                        return my
                }</span>
                <span class="cov0" title="0">my.responseBody = my.responseBodyBuffer.Bytes()</span>
        } else<span class="cov0" title="0"> {
                my.responseBody, my.Err = io.ReadAll(my.response.Body)
                if my.Err != nil </span><span class="cov0" title="0">{
                        my.Err = ReadResponseErr.Wrap(my.Err)
                        return my
                }</span>
        }

        <span class="cov0" title="0">my.response.Body = io.NopCloser(bytes.NewBuffer(my.responseBody)) // 还原响应体

        my.isReady = false

        return my</span>
}

// 检查条件是否满足
func (my *HttpClient) check() error <span class="cov0" title="0">{
        if my.requestUrl == "" </span><span class="cov0" title="0">{
                return UrlEmptyErr.Panic()
        }</span>

        <span class="cov0" title="0">if my.requestMethod == "" </span><span class="cov0" title="0">{
                my.requestMethod = http.MethodGet
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// 设置url参数
func (my *HttpClient) setQueries() <span class="cov0" title="0">{
        if len(my.requestQueries) &gt; 0 </span><span class="cov0" title="0">{
                queries := url.Values{}
                for k, v := range my.requestQueries </span><span class="cov0" title="0">{
                        queries.Add(k, v)
                }</span>

                <span class="cov0" title="0">if len(queries) &gt; 0 </span><span class="cov0" title="0">{
                        my.requestUrl = my.requestUrl + "?" + queries.Encode()
                }</span>
        }
}

// 设置请求头
func (my *HttpClient) addHeaders() <span class="cov0" title="0">{
        for k, v := range my.requestHeaders </span><span class="cov0" title="0">{
                my.request.Header[k] = append(my.request.Header[k], v...)
        }</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package httpClient

import (
        "io"
        "net/http"
        "os"

        processBar "github.com/schollz/progressbar/v3"

        "github.com/aid297/aid/array"
        "github.com/aid297/aid/dict"
        "github.com/aid297/aid/str"
)

type HttpClientDownload struct {
        httpClient     *HttpClient
        filename       string
        processContent string
}

var HttpClientDownloadApp HttpClientDownload

// New 实例化http客户端下载器
func (*HttpClientDownload) New(httpClient *HttpClient, filename string) *HttpClientDownload <span class="cov0" title="0">{
        return &amp;HttpClientDownload{httpClient: httpClient, filename: filename}
}</span>

// SetProcessContent 设置终端进度条标题
func (my *HttpClientDownload) SetProcessContent(processContent string) *HttpClientDownload <span class="cov0" title="0">{
        my.processContent = processContent

        return my
}</span>

// SaveLocal 保存到本地
func (my *HttpClientDownload) SaveLocal() *HttpClient <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{ my.httpClient.isReady = false }</span>()

        <span class="cov0" title="0">client := my.httpClient.beforeSend()
        if my.httpClient.Err != nil </span><span class="cov0" title="0">{
                return my.httpClient
        }</span>

        <span class="cov0" title="0">if my.httpClient.response, my.httpClient.Err = client.Do(my.httpClient.request); my.httpClient.Err != nil </span><span class="cov0" title="0">{
                return my.httpClient
        }</span> else<span class="cov0" title="0"> {
                defer func() </span><span class="cov0" title="0">{ _ = my.httpClient.response.Body.Close() }</span>()

                <span class="cov0" title="0">f, _ := os.OpenFile(my.filename, os.O_RDWR|os.O_CREATE, 0644)
                defer func() </span><span class="cov0" title="0">{ _ = f.Close() }</span>()

                <span class="cov0" title="0">if my.processContent != "" </span><span class="cov0" title="0">{
                        _, _ = io.Copy(io.MultiWriter(f, processBar.DefaultBytes(my.httpClient.response.ContentLength, my.processContent)), my.httpClient.response.Body)
                }</span> else<span class="cov0" title="0"> {
                        _, _ = io.Copy(f, my.httpClient.response.Body)
                }</span>

                <span class="cov0" title="0">return my.httpClient</span>
        }
}

// SendResponse 发送到客户端
func (my *HttpClientDownload) SendResponse(w http.ResponseWriter, headers map[string][]string) *HttpClient <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{ my.httpClient.isReady = false }</span>()

        <span class="cov0" title="0">client := my.httpClient.beforeSend()
        if my.httpClient.Err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if my.httpClient.response, my.httpClient.Err = client.Do(my.httpClient.request); my.httpClient.Err != nil </span><span class="cov0" title="0">{
                return nil
        }</span> else<span class="cov0" title="0"> {
                defer func() </span><span class="cov0" title="0">{ _ = my.httpClient.response.Body.Close() }</span>()

                <span class="cov0" title="0">w.Header().Set("Content-Disposition", str.APP.Buffer.NewString("attachment; filename=").URLPath(my.filename).String())

                if my.httpClient.response.Header.Get("Content-Type") != "" </span><span class="cov0" title="0">{
                        w.Header().Set("Content-Type", my.httpClient.response.Header.Get("Content-Type"))
                }</span> else<span class="cov0" title="0"> {
                        w.Header().Set("Content-Type", my.httpClient.request.Header["Content-Type"][0])
                }</span>

                <span class="cov0" title="0">if headers != nil </span><span class="cov0" title="0">{
                        dict.New(headers).Each(func(key string, values []string) </span><span class="cov0" title="0">{
                                array.New(values).Each(func(idx int, item string) </span><span class="cov0" title="0">{ w.Header().Add(key, item) }</span>)
                        })
                }

                <span class="cov0" title="0">if _, my.httpClient.Err = io.Copy(w, my.httpClient.response.Body); my.httpClient.Err != nil </span><span class="cov0" title="0">{
                        my.httpClient.Err = WriteResponseErr.Wrap(my.httpClient.Err)
                }</span>

                <span class="cov0" title="0">return my.httpClient</span>
        }
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package httpClient

import (
        "sync"
)

type Multiple struct {
        clients []*HttpClient
}

var MultipleApp Multiple

func (*Multiple) New() *Multiple <span class="cov0" title="0">{ return NewMultiple() }</span>

// NewMultiple 实例化：批量请求对象
//
//go:fix 推荐使用New方法
func NewMultiple() *Multiple <span class="cov0" title="0">{ return &amp;MultipleApp }</span>

// Append 添加httpClient对象
func (my *Multiple) Append(hc *HttpClient) *Multiple <span class="cov0" title="0">{
        my.clients = append(my.clients, hc)

        return my
}</span>

// SetClients 设置httpClient对象
func (my *Multiple) SetClients(clients []*HttpClient) *Multiple <span class="cov0" title="0">{
        my.clients = clients

        return my
}</span>

// Send 批量发送
func (my *Multiple) Send() *Multiple <span class="cov0" title="0">{
        if len(my.clients) &gt; 0 </span><span class="cov0" title="0">{
                var wg sync.WaitGroup
                wg.Add(len(my.clients))

                for _, client := range my.clients </span><span class="cov0" title="0">{
                        go func(client *HttpClient) </span><span class="cov0" title="0">{
                                defer wg.Done()

                                client.Send()
                        }</span>(client)
                }

                <span class="cov0" title="0">wg.Wait()</span>
        }

        <span class="cov0" title="0">return my</span>
}

// GetClients 获取链接池
func (my *Multiple) GetClients() []*HttpClient <span class="cov0" title="0">{ return my.clients }</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package httpLimiter

import (
        "time"
)

type (
        // Visit 访问记录
        Visit struct {
                // 最后一次请求时间
                lastVisit time.Time
                // 对应Time窗口内的访问次数
                visitTimes uint16
        }

        // IpLimiter ip限流器
        IpLimiter struct{ visitMap map[string]*Visit }
)

var (
        VisitApp Visit
)

func (*Visit) New() *Visit <span class="cov0" title="0">{
        return &amp;Visit{lastVisit: time.Now(), visitTimes: 1}
}</span>

func (*IpLimiter) New() *IpLimiter <span class="cov0" title="0">{ return NewIpLimiter() }</span>

// NewIpLimiter 实例化：Ip 限流
//
//go:fix 推荐使用New方法
func NewIpLimiter() *IpLimiter <span class="cov0" title="0">{ return &amp;IpLimiter{visitMap: make(map[string]*Visit)} }</span>

// Affirm 检查限流
func (my *IpLimiter) Affirm(ip string, t time.Duration, maxVisitTimes uint16) (*Visit, bool) <span class="cov0" title="0">{
        if maxVisitTimes == 0 || t == 0 </span><span class="cov0" title="0">{
                return nil, true
        }</span>

        <span class="cov0" title="0">v, ok := my.visitMap[ip]
        if !ok </span><span class="cov0" title="0">{
                my.visitMap[ip] = VisitApp.New()
                return nil, true
        }</span>

        <span class="cov0" title="0">if time.Since(v.lastVisit) &gt; t </span><span class="cov0" title="0">{
                v.visitTimes = 1
        }</span> else<span class="cov0" title="0"> {
                v.visitTimes++
                if v.visitTimes &gt; maxVisitTimes </span><span class="cov0" title="0">{
                        return v, false
                }</span>
        }
        <span class="cov0" title="0">v.lastVisit = time.Now()

        return nil, true</span>
}

// GetLastVisitor 获取最后访问时间
func (r *Visit) GetLastVisitor() time.Time <span class="cov0" title="0">{ return r.lastVisit }</span>

// GetVisitTimes 获取窗口期内访问次数
func (r *Visit) GetVisitTimes() uint16 <span class="cov0" title="0">{ return r.visitTimes }</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">package httpLimiter

import (
        "sync"
        "time"
)

type (
        // visitor 访问者对象
        visitor struct {
                ipLimiter     *IpLimiter
                t             time.Duration
                maxVisitTimes uint16
        }

        // RouteLimiter 路由限流器
        RouteLimiter struct{ RouteSetMap *sync.Map }
)

var (
        routerLimiterOnce = sync.Once{}
        routerLimiterIns  *RouteLimiter
        visitorApp        visitor
)

func (*visitor) New(t time.Duration, maxVisitTimes uint16) *visitor <span class="cov0" title="0">{
        return &amp;visitor{ipLimiter: NewIpLimiter(), t: t, maxVisitTimes: maxVisitTimes}
}</span>

func (*RouteLimiter) Once() *RouteLimiter <span class="cov0" title="0">{ return OnceRouteLimiter() }</span>

// OnceRouteLimiter 单例化：路由限流
//
//go:fix 推荐使用Once方法
func OnceRouteLimiter() *RouteLimiter <span class="cov0" title="0">{
        routerLimiterOnce.Do(func() </span><span class="cov0" title="0">{ routerLimiterIns = &amp;RouteLimiter{RouteSetMap: &amp;sync.Map{}} }</span>)

        <span class="cov0" title="0">return routerLimiterIns</span>
}

// Add 添加限流规则
func (my *RouteLimiter) Add(router string, t time.Duration, maxVisitTimes uint16) *RouteLimiter <span class="cov0" title="0">{
        my.RouteSetMap.Store(router, visitorApp.New(t, maxVisitTimes))

        return my
}</span>

// Affirm 检查是否通过限流
func (my *RouteLimiter) Affirm(router, ip string) (*Visit, bool) <span class="cov0" title="0">{
        if val, exist := my.RouteSetMap.Load(router); exist </span><span class="cov0" title="0">{
                v := val.(*visitor)
                return v.ipLimiter.Affirm(ip, v.t, v.maxVisitTimes)
        }</span>

        <span class="cov0" title="0">return nil, true</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package lock

import (
        "fmt"
        "sync"
        "time"

        "github.com/aid297/aid/dict"
)

type (
        MapLocker interface {
                implMapLocker()
                New() MapLocker
                Once() MapLocker
                Set(key string, val any) error
                SetMany(items map[string]any) error
                Destroy(key string)
                DestroyAll()
                Lock(key string, timeout time.Duration) (*itemLock, error)
                Try(key string) error
        }

        // MapLock 字典锁：一个锁的集合
        MapLock struct {
                lock  sync.RWMutex
                locks *dict.AnyDict[string, *itemLock]
        }

        // 锁项：一个集合锁中的每一项，包含：锁状态、锁值、超时时间、定时器
        itemLock struct {
                inUse   bool
                val     any
                timeout time.Duration
                timer   *time.Timer
        }
)

var (
        onceMapLock sync.Once
        mapLockIns  *MapLock
)

func (*MapLock) implMapLocker() {<span class="cov0" title="0">}</span>

func (*MapLock) New() MapLocker <span class="cov0" title="0">{ return &amp;MapLock{locks: dict.Make[string, *itemLock]()} }</span>

func (*MapLock) Once() MapLocker <span class="cov8" title="1">{
        onceMapLock.Do(func() </span><span class="cov8" title="1">{ mapLockIns = &amp;MapLock{locks: dict.Make[string, *itemLock]()} }</span>)

        <span class="cov8" title="1">return mapLockIns</span>
}

func (*MapLock) set(key string, val any) (err error) <span class="cov8" title="1">{
        _, exists := mapLockIns.locks.Get(key)
        if exists </span><span class="cov0" title="0">{
                return fmt.Errorf("锁[%s]已存在", key)
        }</span> else<span class="cov8" title="1"> {
                mapLockIns.locks.Set(key, &amp;itemLock{val: val})
        }</span>

        <span class="cov8" title="1">return</span>
}

// Set 创建锁
func (*MapLock) Set(key string, val any) error <span class="cov0" title="0">{
        mapLockIns.lock.Lock()
        defer mapLockIns.lock.Unlock()

        return mapLockIns.set(key, val)
}</span>

// SetMany 批量创建锁
func (*MapLock) SetMany(items map[string]any) (err error) <span class="cov8" title="1">{
        mapLockIns.lock.Lock()
        defer mapLockIns.lock.Unlock()

        for idx, item := range items </span><span class="cov8" title="1">{
                if err = mapLockIns.set(idx, item); err != nil </span><span class="cov0" title="0">{
                        mapLockIns.DestroyAll()
                        return
                }</span>
        }

        <span class="cov8" title="1">return</span>
}

// Release 显式锁释放方法
func (r *itemLock) Release() <span class="cov8" title="1">{
        if r.timer != nil </span><span class="cov8" title="1">{
                r.timer.Stop()
                r.timer = nil
        }</span>
        <span class="cov8" title="1">r.inUse = false</span>
}

func (*MapLock) destroy(key string) <span class="cov0" title="0">{
        if il, ok := mapLockIns.locks.Get(key); ok </span><span class="cov0" title="0">{
                il.Release()
                mapLockIns.locks.RemoveByKey(key) // 删除键值对，以便垃圾回收
        }</span>
}

// Destroy 删除锁
func (*MapLock) Destroy(key string) <span class="cov0" title="0">{
        mapLockIns.lock.Lock()
        defer mapLockIns.lock.Unlock()

        mapLockIns.destroy(key)
}</span>

// DestroyAll 删除所有锁
func (*MapLock) DestroyAll() <span class="cov0" title="0">{
        mapLockIns.lock.Lock()
        defer mapLockIns.lock.Unlock()

        mapLockIns.locks.Each(func(key string, value *itemLock) </span><span class="cov0" title="0">{
                mapLockIns.destroy(key)
        }</span>)
}

// Lock 加锁
func (*MapLock) Lock(key string, timeout time.Duration) (*itemLock, error) <span class="cov8" title="1">{
        mapLockIns.lock.RLock()
        defer mapLockIns.lock.RUnlock()

        if item, exists := mapLockIns.locks.Get(key); !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("锁[%s]不存在", key)
        }</span> else<span class="cov8" title="1"> {
                if item.inUse </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("锁[%s]被占用", key)
                }</span>

                // 设置锁占用
                <span class="cov8" title="1">item.inUse = true

                // 设置超时时间
                if timeout &gt; 0 </span><span class="cov8" title="1">{
                        item.timeout = timeout
                        item.timer = time.AfterFunc(timeout, func() </span><span class="cov0" title="0">{
                                if il, ok := mapLockIns.locks.Get(key); ok </span><span class="cov0" title="0">{
                                        if il.timer != nil </span><span class="cov0" title="0">{
                                                il.Release()
                                        }</span>
                                }
                        })
                }

                <span class="cov8" title="1">return item, nil</span>
        }
}

// Try 尝试获取锁
func (*MapLock) Try(key string) error <span class="cov8" title="1">{
        mapLockIns.lock.RLock()
        defer mapLockIns.lock.RUnlock()

        if item, exist := mapLockIns.locks.Get(key); !exist </span><span class="cov0" title="0">{
                return fmt.Errorf("锁[%s]不存在", key)
        }</span> else<span class="cov8" title="1"> {
                if item.inUse </span><span class="cov0" title="0">{
                        return fmt.Errorf("锁[%s]被占用", key)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package logger

import (
        "fmt"
        "os"
        "time"

        "github.com/natefinch/lumberjack"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"

        "github.com/aid297/aid/filesystem"
        "github.com/aid297/aid/operation"
        "github.com/aid297/aid/operation/operationV2"
)

// ZapProvider Zap日志服务提供者
type (
        ZapProvider struct{}

        EncoderType = string
)

const (
        EncoderTypeConsole EncoderType = "CONSOLE"
        EncoderTypeJson    EncoderType = "JSON"
)

// getWriteSync 获取 zapcore.WriteSync
func getWriteSync(config *zapConfig, path string) zapcore.WriteSyncer <span class="cov8" title="1">{
        fileWriter := &amp;lumberjack.Logger{
                Filename:   path,                // 日志文件名称
                MaxSize:    config.MaxSize,      // 文件大小限制,单位MB
                MaxBackups: config.MaxBackup,    // 最大保留日志文件数量
                MaxAge:     config.MaxDay,       // 日志文件保留天数
                Compress:   config.NeedCompress, // 是否压缩处理,压缩以后文件为xxxxx.gz
        }

        if config.InConsole </span><span class="cov0" title="0">{
                return zapcore.NewMultiWriteSyncer(zapcore.AddSync(fileWriter), zapcore.AddSync(os.Stdout))
        }</span> else<span class="cov8" title="1"> {
                return zapcore.AddSync(fileWriter)
        }</span>
}

// New 实例化：Zap日志服务提供者
func (*ZapProvider) New(config *zapConfig) (*zap.Logger, error) <span class="cov8" title="1">{ return NewZapProvider(config) }</span>

// NewZapProvider 实例化：Zap日志服务提供者
//
//go:fix 推荐使用：New方法
func NewZapProvider(config *zapConfig) (*zap.Logger, error) <span class="cov8" title="1">{
        var (
                err             error
                fs              *filesystem.FileSystem
                zapLogger       *zap.Logger
                zapCores        = make([]zapcore.Core, 0, 7)
                zapLoggerConfig = zapcore.EncoderConfig{
                        MessageKey:    "message",
                        LevelKey:      "logLevel",
                        TimeKey:       "time",
                        NameKey:       "logger",
                        CallerKey:     "caller",
                        StacktraceKey: "stacktrace",
                        LineEnding:    zapcore.DefaultLineEnding,
                        EncodeLevel:   zapcore.LowercaseLevelEncoder,
                        EncodeTime: func(t time.Time, encoder zapcore.PrimitiveArrayEncoder) </span><span class="cov8" title="1">{
                                encoder.AppendString(t.Format(time.DateTime + ".000"))
                        }</span>,
                        EncodeDuration: zapcore.SecondsDurationEncoder,
                        EncodeCaller:   zapcore.FullCallerEncoder,
                }
                encoderTypes = map[EncoderType]func(cfg zapcore.EncoderConfig) zapcore.Encoder{
                        EncoderTypeJson:    zapcore.NewJSONEncoder,
                        EncoderTypeConsole: zapcore.NewConsoleEncoder,
                }
        )

        <span class="cov8" title="1">fs = operation.TernaryFuncAll(func() bool </span><span class="cov8" title="1">{ return config.PathAbs }</span>, func() *filesystem.FileSystem <span class="cov0" title="0">{ return filesystem.FileSystemApp.NewByAbs(config.Path) }</span>, func() *filesystem.FileSystem <span class="cov8" title="1">{ return filesystem.FileSystemApp.NewByRel(config.Path) }</span>)
        <span class="cov8" title="1">if !fs.IsExist </span><span class="cov0" title="0">{
                if err = fs.MkDir(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("创建日志目录失败：%w", err)
                }</span>
        }

        <span class="cov8" title="1">if config.Level &lt; zapcore.DebugLevel </span><span class="cov0" title="0">{
                config.Level = zapcore.DebugLevel
        }</span>

        <span class="cov8" title="1">if config.Level &gt; zapcore.FatalLevel </span><span class="cov0" title="0">{
                config.Level = zapcore.FatalLevel
        }</span>

        <span class="cov8" title="1">for logLevel := config.Level; logLevel &lt;= zapcore.FatalLevel; logLevel++ </span><span class="cov8" title="1">{
                writer := getWriteSync(config, fs.Copy().Join(logLevel.String()+config.Extension).GetDir())
                zapCores = append(zapCores, zapcore.NewCore(encoderTypes[config.EncoderType](zapLoggerConfig), writer, logLevel))
        }</span>

        // for _, logLevel := range []zapcore.Level{zapcore.DebugLevel, zapcore.InfoLevel, zapcore.WarnLevel, zapcore.ErrorLevel, zapcore.DPanicLevel, zapcore.PanicLevel, zapcore.FatalLevel} {
        //         if config.Level &gt;= logLevel {
        //                 writer := getWriteSync(config, fs.Copy().Join(logLevel.String()+config.Extension).GetDir())
        //                 zapCores = append(zapCores, zapcore.NewCore(encoderTypes[config.EncoderType](zapLoggerConfig), writer, logLevel))
        //         }
        // }

        <span class="cov8" title="1">zapLogger = zap.New(zapcore.NewTee(zapCores...))
        // if config.InConsole {
        //         zapLogger = zapLogger.WithOptions(zap.AddCaller())
        // }
        zapLogger = operationV2.NewTernary(operationV2.TrueFn(func() *zap.Logger </span><span class="cov0" title="0">{ return zapLogger.WithOptions(zap.AddCaller()) }</span>), operationV2.FalseValue(zapLogger)).GetByValue(config.InConsole)

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                _ = operationV2.NewTernary(operationV2.TrueFn(func() error </span><span class="cov0" title="0">{ return nil }</span>), operationV2.FalseFn(func() error <span class="cov8" title="1">{ return zapLogger.Sync() }</span>)).GetByValue(config.InConsole)
                // if config.InConsole {
                //         return
                // }
                // err = zapLogger.Sync()
        }()

        <span class="cov8" title="1">return zapLogger, err</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package logger

import "go.uber.org/zap/zapcore"

type zapConfig struct {
        Path         string
        PathAbs      bool
        MaxSize      int
        MaxBackup    int
        MaxDay       int
        NeedCompress bool
        InConsole    bool
        Extension    string
        Level        zapcore.Level
        EncoderType  EncoderType
}

// New 实例化：日志配置
func (*zapConfig) New(level zapcore.Level) *zapConfig <span class="cov8" title="1">{
        ins := &amp;zapConfig{
                Path:         ".",
                PathAbs:      false,
                EncoderType:  EncoderTypeConsole,
                Level:        level,
                MaxSize:      1,
                MaxBackup:    5,
                MaxDay:       30,
                NeedCompress: false,
                InConsole:    false,
                Extension:    ".log",
        }

        return ins
}</span>

// SetPath 设置路径
func (my *zapConfig) SetPath(path string) *zapConfig <span class="cov8" title="1">{
        my.Path = path

        return my
}</span>

// SetEncoderType 设置编码类型
func (my *zapConfig) SetEncoderType(encoderType EncoderType) *zapConfig <span class="cov8" title="1">{
        my.EncoderType = encoderType

        return my
}</span>

// SetPathAbs 设置路径是否使用绝对路径
func (my *zapConfig) SetPathAbs(pathAbs bool) *zapConfig <span class="cov8" title="1">{
        my.PathAbs = pathAbs

        return my
}</span>

// SetMaxSize 设置单文件最大存储容量
func (my *zapConfig) SetMaxSize(maxSize int) *zapConfig <span class="cov8" title="1">{
        my.MaxSize = maxSize

        return my
}</span>

// SetMaxBackup 设置最大备份数量
func (my *zapConfig) SetMaxBackup(maxBackup int) *zapConfig <span class="cov8" title="1">{
        my.MaxBackup = maxBackup

        return my
}</span>

// SetMaxDay 设置日志文件最大保存天数
func (my *zapConfig) SetMaxDay(maxDay int) *zapConfig <span class="cov8" title="1">{
        my.MaxDay = maxDay

        return my
}</span>

// SetNeedCompress 设置是否需要压缩
func (my *zapConfig) SetNeedCompress(needCompress bool) *zapConfig <span class="cov8" title="1">{
        my.NeedCompress = needCompress

        return my
}</span>

// SetInConsole 设置是否需要在终端显示
func (my *zapConfig) SetInConsole(InConsole bool) *zapConfig <span class="cov8" title="1">{
        my.InConsole = InConsole

        return my
}</span>

// SetExtension 设置扩展名
func (my *zapConfig) SetExtension(extension string) *zapConfig <span class="cov0" title="0">{
        my.Extension = extension

        return my
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">package main

import (
        "log"

        "github.com/aid297/aid/filesystem/filesystemV2"
        "github.com/aid297/aid/gormPool"
)

type (
        TestTable1 struct {
                ID   int    `gorm:"column:id;primaryKey;autoIncrement"`
                Name string `gorm:"column:name;type:varchar(255);not null;default:'';comment:名称"`
        }
)

func main() <span class="cov0" title="0">{
        pool := gormPool.APP.MySQLPool.Once(gormPool.APP.DBSetting.New(filesystemV2.APP.File.NewByRel("./db.yaml").GetFullPath()))
        conn := pool.GetConn()
        conn.AutoMigrate(&amp;TestTable1{})

        names := []string{"1", "2", "3"}
        testTables := []TestTable1{}
        gormPool.APP.Finder.New(conn.Model(&amp;TestTable1{})).WhenIn(len(names) &gt; 0, "name", names).GetDB().Find(&amp;testTables)

        log.Printf("%v", testTables)
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">package operation

// GetIntersection 获取两个数组的交集
func GetIntersection[T comparable](setA, setB []T) (intersection []T) <span class="cov0" title="0">{
        elementMap := make(map[T]bool)

        // 将 setB 的元素存入 map
        for _, b := range setB </span><span class="cov0" title="0">{
                elementMap[b] = true
        }</span>

        // 遍历 setA，检查是否在 setB 中
        <span class="cov0" title="0">for _, a := range setA </span><span class="cov0" title="0">{
                if elementMap[a] </span><span class="cov0" title="0">{
                        intersection = append(intersection, a)
                }</span>
        }

        <span class="cov0" title="0">return</span>
}

// GetUnion 获取两个数组的并集
func GetUnion[T comparable](setA, setB []T) (union []T) <span class="cov0" title="0">{
        elementMap := make(map[T]bool)

        // 将 setA 的元素存入 map
        for _, a := range setA </span><span class="cov0" title="0">{
                if !elementMap[a] </span><span class="cov0" title="0">{
                        union = append(union, a)
                        elementMap[a] = true
                }</span>
        }

        // 将 setB 的元素存入 map
        <span class="cov0" title="0">for _, b := range setB </span><span class="cov0" title="0">{
                if !elementMap[b] </span><span class="cov0" title="0">{
                        union = append(union, b)
                        elementMap[b] = true
                }</span>
        }

        <span class="cov0" title="0">return</span>
}

// GetDifference 获取两个数组的差集
func GetDifference[T comparable](setA, setB []T) (difference []T) <span class="cov0" title="0">{
        elementMap := make(map[T]bool)

        // 将 setB 的元素存入 map
        for _, b := range setB </span><span class="cov0" title="0">{
                elementMap[b] = true
        }</span>

        // 遍历 setA，检查是否不在 setB 中
        <span class="cov0" title="0">for _, a := range setA </span><span class="cov0" title="0">{
                if !elementMap[a] </span><span class="cov0" title="0">{
                        difference = append(difference, a)
                }</span>
        }

        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package operation

import (
        "errors"

        "golang.org/x/exp/constraints"
)

// Min 获取最小值
func Min[T constraints.Ordered](values ...T) (T, error) <span class="cov0" title="0">{
        var zero T

        if len(values) == 0 </span><span class="cov0" title="0">{
                return zero, errors.New("至少需要一个值")
        }</span>

        <span class="cov0" title="0">m := values[0]
        for _, v := range values[1:] </span><span class="cov0" title="0">{
                if v &lt; m </span><span class="cov0" title="0">{
                        m = v
                }</span>
        }
        <span class="cov0" title="0">return m, nil</span>
}

// Max 获取最大值
func Max[T constraints.Ordered](values ...T) (T, error) <span class="cov0" title="0">{
        var zero T

        if len(values) == 0 </span><span class="cov0" title="0">{
                return zero, errors.New("至少需要一个值")
        }</span>

        <span class="cov0" title="0">m := values[0]
        for _, v := range values[1:] </span><span class="cov0" title="0">{
                if v &gt; m </span><span class="cov0" title="0">{
                        m = v
                }</span>
        }
        <span class="cov0" title="0">return m, nil</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package operationV2

type (
        Ternary[T any] struct {
                trueFn  func() T
                falseFn func() T
        }
)

func NewTernary[T any](attrs ...TernaryAttributer[T]) Ternary[T] <span class="cov8" title="1">{ return Ternary[T]{}.Set(attrs...) }</span>

func (t Ternary[T]) Set(attrs ...TernaryAttributer[T]) Ternary[T] <span class="cov8" title="1">{
        if len(attrs) &gt; 0 </span><span class="cov8" title="1">{
                for idx := range attrs </span><span class="cov8" title="1">{
                        attrs[idx].Register(&amp;t)
                }</span>
        }
        <span class="cov8" title="1">return t</span>
}

// DoByValue 执行回调 → 通过值
func (t Ternary[T]) DoByValue(condition bool) <span class="cov0" title="0">{
        if condition </span><span class="cov0" title="0">{
                if t.trueFn != nil </span><span class="cov0" title="0">{
                        t.trueFn()
                }</span>
        } else<span class="cov0" title="0"> {
                if t.falseFn != nil </span><span class="cov0" title="0">{
                        t.falseFn()
                }</span>
        }
}

// DoByFunc 执行回调 → 通过函数
func (t Ternary[T]) DoByFunc(condition func() bool) <span class="cov0" title="0">{
        if condition() </span><span class="cov0" title="0">{
                if t.trueFn != nil </span><span class="cov0" title="0">{
                        t.trueFn()
                }</span>
        } else<span class="cov0" title="0"> {
                if t.falseFn != nil </span><span class="cov0" title="0">{
                        t.falseFn()
                }</span>
        }
}

// GetByValue 获取值 → 通过值
func (t Ternary[T]) GetByValue(condition bool) T <span class="cov8" title="1">{
        var empty T
        if condition </span><span class="cov8" title="1">{
                if t.trueFn != nil </span><span class="cov8" title="1">{
                        return t.trueFn()
                }</span> else<span class="cov0" title="0"> {
                        return empty
                }</span>
        } else<span class="cov0" title="0"> {
                if t.falseFn != nil </span><span class="cov0" title="0">{
                        return t.falseFn()
                }</span> else<span class="cov0" title="0"> {
                        return empty
                }</span>
        }
}

// GetByFunc 获取值 → 通过函数
func (t Ternary[T]) GetByFunc(condition func() bool) T <span class="cov8" title="1">{
        var empty T
        if condition() </span><span class="cov0" title="0">{
                if t.trueFn != nil </span><span class="cov0" title="0">{
                        return t.trueFn()
                }</span> else<span class="cov0" title="0"> {
                        return empty
                }</span>
        } else<span class="cov8" title="1"> {
                if t.falseFn != nil </span><span class="cov0" title="0">{
                        return t.falseFn()
                }</span> else<span class="cov8" title="1"> {
                        return empty
                }</span>
        }
}

// OrError 三元运算符 → 处理错误
func OrError(target bool, trueValue, falseValue error) error <span class="cov0" title="0">{
        return NewTernary(TrueValue(trueValue), FalseValue(falseValue)).GetByValue(target)
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">package operationV2

type (
        TernaryAttributer[T any] interface {
                Register(ternary *Ternary[T])
        }

        AttrTrueValue[T any]  struct{ trueValue T }
        AttrFalseValue[T any] struct{ falseValue T }
        AttrTrueFn[T any]     struct{ trueFn func() T }
        AttrFalseFn[T any]    struct{ falseFn func() T }
)

func TrueValue[T any](trueValue T) AttrTrueValue[T] <span class="cov8" title="1">{ return AttrTrueValue[T]{trueValue: trueValue} }</span>

func (my AttrTrueValue[T]) Register(ternary *Ternary[T]) <span class="cov8" title="1">{
        ternary.trueFn = func() T </span><span class="cov8" title="1">{ return my.trueValue }</span>
}

func FalseValue[T any](falseValue T) AttrFalseValue[T] <span class="cov8" title="1">{
        return AttrFalseValue[T]{falseValue: falseValue}
}</span>

func (my AttrFalseValue[T]) Register(ternary *Ternary[T]) <span class="cov8" title="1">{
        ternary.falseFn = func() T </span><span class="cov0" title="0">{ return my.falseValue }</span>
}

func TrueFn[T any](trueFn func() T) AttrTrueFn[T] <span class="cov8" title="1">{ return AttrTrueFn[T]{trueFn: trueFn} }</span>

func (my AttrTrueFn[T]) Register(ternary *Ternary[T]) <span class="cov8" title="1">{ ternary.trueFn = my.trueFn }</span>

func FalseFn[T any](falseFn func() T) AttrFalseFn[T] <span class="cov0" title="0">{ return AttrFalseFn[T]{falseFn: falseFn} }</span>

func (my AttrFalseFn[T]) Register(ternary *Ternary[T]) <span class="cov0" title="0">{ ternary.falseFn = my.falseFn }</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package operation

// Ternary 三元运算：通过值
func Ternary[V any](condition bool, T, F V) V <span class="cov0" title="0">{
        if condition </span><span class="cov0" title="0">{
                return T
        }</span>
        <span class="cov0" title="0">return F</span>
}

// TernaryFunc 三元运算：通过回调函数
func TernaryFunc[V any](condition func() bool, T V, F V) V <span class="cov0" title="0">{ return Ternary(condition(), T, F) }</span>

// TernaryFuncReturn 三元运算：返回值使用回调方法
func TernaryFuncReturn[V any](condition bool, trueFn func() V, falseFn func() V) V <span class="cov0" title="0">{
        var v V
        if trueFn == nil || falseFn == nil </span><span class="cov0" title="0">{
                return v
        }</span>

        <span class="cov0" title="0">if condition </span><span class="cov0" title="0">{
                return trueFn()
        }</span>

        <span class="cov0" title="0">return falseFn()</span>
}

// TernaryFuncAll 三元运算：通过回调函数，返回值也使用回调函数
func TernaryFuncAll[V any](condition func() bool, trueFn func() V, falseFn func() V) V <span class="cov8" title="1">{
        var v V
        if condition == nil || trueFn == nil || falseFn == nil </span><span class="cov0" title="0">{
                return v
        }</span>

        <span class="cov8" title="1">if condition() </span><span class="cov0" title="0">{
                return trueFn()
        }</span>

        <span class="cov8" title="1">return falseFn()</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package ptr

func New[T any](val T) *T <span class="cov8" title="1">{ return &amp;val }</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">package redisPool

import "github.com/aid297/aid/honestMan"

type RedisSetting struct {
        Host     string `yaml:"host"`
        Port     int    `yaml:"port"`
        Password string `yaml:"password"`
        Prefix   string `yaml:"prefix"`
        Pool     []struct {
                Key    string `yaml:"key"`
                Prefix string `yaml:"prefix"`
                DbNum  int    `yaml:"dbNum"`
        }
}

// New 初始化：数据库配置
func (*RedisSetting) New(path string) *RedisSetting <span class="cov0" title="0">{
        var redisSetting *RedisSetting = &amp;RedisSetting{}
        err := honestMan.HonestManApp.New(path).LoadYaml(redisSetting)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return redisSetting</span>
}

// ExampleYaml 示例配置文件
func (*RedisSetting) ExampleYaml() string <span class="cov0" title="0">{
        return `host: 127.0.0.1
port: 6379
password: ""
prefix: "abc-example"
pool:
  [
    {
      key: "auth",
      prefix: "auth",
      dbNum: 0
    }
  ]`
}</span>
</pre>
		
		<pre class="file" id="file64" style="display: none">package redisPool

import (
        "context"
        "errors"
        "fmt"
        "sync"
        "time"

        rds "github.com/redis/go-redis/v9"

        "github.com/aid297/aid/dict"
        "github.com/aid297/aid/str"
)

type (
        RedisPool struct {
                connections *dict.AnyDict[string, *redisConn]
        }

        redisConn struct {
                prefix string
                conn   *rds.Client
        }
)

var (
        redisPoolIns  *RedisPool
        redisPoolOnce sync.Once
)

func (*RedisPool) Once(redisSetting *RedisSetting) *RedisPool <span class="cov0" title="0">{
        redisPoolOnce.Do(func() </span><span class="cov0" title="0">{
                redisPoolIns = &amp;RedisPool{}
                redisPoolIns.connections = dict.Make[string, *redisConn]()

                if len(redisSetting.Pool) &gt; 0 </span><span class="cov0" title="0">{
                        for idx := range redisSetting.Pool </span><span class="cov0" title="0">{
                                redisPoolIns.connections.Set(redisSetting.Pool[idx].Key, &amp;redisConn{
                                        prefix: str.APP.Buffer.NewString(redisSetting.Prefix).S(":", redisSetting.Pool[idx].Prefix).String(),
                                        conn: rds.NewClient(&amp;rds.Options{
                                                Addr:     str.APP.Buffer.NewAny(redisSetting.Host).Any(":", redisSetting.Port).String(),
                                                Password: redisSetting.Password,
                                                DB:       redisSetting.Pool[idx].DbNum,
                                        }),
                                })
                        }</span>
                }
        })

        <span class="cov0" title="0">return redisPoolIns</span>
}

// GetClient 获取链接和链接前缀
func (*RedisPool) GetClient(key string) (string, *rds.Client) <span class="cov0" title="0">{
        if client, exist := redisPoolIns.connections.Get(key); exist </span><span class="cov0" title="0">{
                return client.prefix, client.conn
        }</span>

        <span class="cov0" title="0">return "", nil</span>
}

// Get 获取值
func (*RedisPool) Get(clientName, key string) (string, error) <span class="cov0" title="0">{
        var (
                err         error
                prefix, ret string
                client      *rds.Client
        )

        prefix, client = redisPoolIns.GetClient(clientName)
        if client == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("没有找到redis链接：%s", clientName)
        }</span>

        <span class="cov0" title="0">ret, err = client.Get(context.Background(), fmt.Sprintf("%s:%s", prefix, key)).Result()
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, rds.Nil) </span><span class="cov0" title="0">{
                        return "", nil
                }</span> else<span class="cov0" title="0"> {
                        return "", err
                }</span>
        }

        <span class="cov0" title="0">return ret, nil</span>
}

// Set 设置值
func (*RedisPool) Set(clientName, key string, val any, exp time.Duration) (string, error) <span class="cov0" title="0">{
        var (
                prefix string
                client *rds.Client
        )

        prefix, client = redisPoolIns.GetClient(clientName)
        if client == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("没有找到redis链接：%s", clientName)
        }</span>

        <span class="cov0" title="0">return client.Set(context.Background(), fmt.Sprintf("%s:%s", prefix, key), val, exp).Result()</span>
}

// Close 关闭链接
func (my *RedisPool) Close(key string) error <span class="cov0" title="0">{
        if client, exist := redisPoolIns.connections.Get(key); exist </span><span class="cov0" title="0">{
                return client.conn.Close()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Clean 清理链接
func (*RedisPool) Clean() <span class="cov0" title="0">{
        for key, val := range redisPoolIns.connections.ToMap() </span><span class="cov0" title="0">{
                _ = val.conn.Close()
                redisPoolIns.connections.RemoveByKey(key)
        }</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package reflection

import (
        "fmt"
        "reflect"
        "strings"
        "time"
        "unsafe"

        "github.com/aid297/aid/array"
        "github.com/aid297/aid/operation"
        "github.com/aid297/aid/str"
)

type (
        Reflection struct {
                original        any
                refValue        reflect.Value
                refType         reflect.Type
                IsPtr           bool
                IsZero          bool
                IsTime          bool // 是否是时间
                serializeFormat string
        }

        ReflectionType string
        AnyType        string
)

const (
        Int               ReflectionType = "I"
        Int8              ReflectionType = "I8"
        Int16             ReflectionType = "I16"
        Int32             ReflectionType = "I32"
        Int64             ReflectionType = "I64"
        Uint              ReflectionType = "U"
        Uint8             ReflectionType = "U8"
        Uint16            ReflectionType = "U16"
        Uint32            ReflectionType = "U32"
        Uint64            ReflectionType = "U64"
        String            ReflectionType = "STRING"
        Float32           ReflectionType = "F32"
        Float64           ReflectionType = "F64"
        Datetime          ReflectionType = "DATETIME"
        Bool              ReflectionType = "BOOL"
        Array             ReflectionType = "ARRAY"
        Map               ReflectionType = "MAP"
        Struct            ReflectionType = "STRUCT"
        Nil               ReflectionType = "NIL"
        PtrSliceAny       ReflectionType = "*[]ANY"
        PtrSlicePtrStruct ReflectionType = "*[]*STRUCT"
        PtrSliceStruct    ReflectionType = "*[]STRUCT"
        PtrSlicePtrMap    ReflectionType = "*[]*MAP"
        PtrSliceMap       ReflectionType = "*[]MAP"
        PtrStruct         ReflectionType = "*STRUCT"
        PtrPtrStruct      ReflectionType = "**STRUCT"
        PtrPtrMap         ReflectionType = "**MAP"
        PtrMap            ReflectionType = "*MAP" // 1
        Any               ReflectionType = "ANY"
        UnKnowType        ReflectionType = "UKT"
)

func (*Reflection) New(object any, attrs ...Attributer) *Reflection <span class="cov0" title="0">{ return New(object, attrs...) }</span>
func (*Reflection) NewByValue(refValue reflect.Value, attrs ...Attributer) *Reflection <span class="cov0" title="0">{
        return NewByReflectValue(refValue, attrs...)
}</span>

// New 实例化：反射帮助
//
//go:fix 推荐使用：ReflectionApp.New方法
func New(object any, attrs ...Attributer) *Reflection <span class="cov0" title="0">{
        var (
                ins      *Reflection = &amp;Reflection{original: object, serializeFormat: "%v"}
                refType  reflect.Type
                refValue reflect.Value
        )

        if object == nil </span><span class="cov0" title="0">{
                refType = reflect.TypeOf(nil)
                refValue = reflect.ValueOf(nil)
        }</span> else<span class="cov0" title="0"> {
                refType = reflect.TypeOf(object)
                refValue = reflect.ValueOf(object)
        }</span>

        // 如果 obj 是指针，获取其元素
        <span class="cov0" title="0">if refType == nil </span><span class="cov0" title="0">{
                ins.refValue = reflect.Value{}
                ins.refType = reflect.TypeOf(ins.refValue)
                ins.IsZero = true
        }</span> else<span class="cov0" title="0"> if refValue.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                ins.refValue = refValue.Elem()
                ins.refType = refType.Elem()
        }</span> else<span class="cov0" title="0"> {
                ins.refValue = refValue
                ins.refType = refType
        }</span>

        <span class="cov0" title="0">ins.IsPtr = ins.refType.Kind() == reflect.Ptr // 判断是否是指针

        if ins.refType == reflect.TypeOf(reflect.Value{}) </span><span class="cov0" title="0">{
                ins.IsZero = true
        }</span> else<span class="cov0" title="0"> if ins.GetReflectionType() == Array || ins.GetReflectionType() == Map </span><span class="cov0" title="0">{
                ins.IsZero = ins.refValue.Len() == 0
        }</span> else<span class="cov0" title="0"> {
                if !ins.IsZero </span><span class="cov0" title="0">{
                        ins.IsZero = ins.refValue.IsValid() &amp;&amp; ins.refValue.IsZero()
                        // ins.IsZero = ins.refValue.IsValid() &amp;&amp; ins.refValue.IsZero() &amp;&amp; !ins.refValue.IsNil()
                }</span>
        }

        // 判断是否是时间
        <span class="cov0" title="0">if !ins.IsZero </span><span class="cov0" title="0">{
                if ins.refValue.IsValid() </span><span class="cov0" title="0">{
                        ins.IsTime = ins.refValue.Type() == reflect.TypeOf(time.Time{})
                }</span>
        }

        <span class="cov0" title="0">ins.Set(attrs...)

        return ins</span>
}

// NewByReflectValue 实例化：通过reflect.Value
//
//go:fix 推荐使用：ReflectionApp.NewByValue方法
func NewByReflectValue(refValue reflect.Value, attrs ...Attributer) *Reflection <span class="cov0" title="0">{
        return New(refValue.Interface())
}</span>

func (my *Reflection) Set(attrs ...Attributer) *Reflection <span class="cov0" title="0">{
        if len(attrs) &gt; 0 </span><span class="cov0" title="0">{
                for idx := range attrs </span><span class="cov0" title="0">{
                        attrs[idx].Register(my)
                }</span>
        }

        <span class="cov0" title="0">return my</span>
}

// GetValue 获取reflect.Value
func (my *Reflection) GetValue() reflect.Value <span class="cov0" title="0">{ return my.refValue }</span>

// GetType 获取reflect.Kind
func (my *Reflection) GetType() reflect.Type <span class="cov0" title="0">{ return my.refType }</span>

// GetReflectionType 获取Reflection类型
func (my *Reflection) GetReflectionType() ReflectionType <span class="cov0" title="0">{
        var (
                ref      = reflect.ValueOf(my.original)
                elem     reflect.Value
                elemType reflect.Type
        )

        if ref.Kind() != reflect.Ptr </span><span class="cov0" title="0">{
                var is64 bool = unsafe.Sizeof(uintptr(0)) == 8

                if my.IsSame(time.Time{}) </span><span class="cov0" title="0">{
                        return Datetime
                }</span>

                <span class="cov0" title="0">switch my.GetType().Kind() </span>{
                case reflect.Int:<span class="cov0" title="0">
                        return operation.Ternary(is64, Int64, Int32)</span>
                case reflect.Int8:<span class="cov0" title="0">
                        return Int8</span>
                case reflect.Int16:<span class="cov0" title="0">
                        return Int16</span>
                case reflect.Int32:<span class="cov0" title="0">
                        return Int32</span>
                case reflect.Int64:<span class="cov0" title="0">
                        return Int64</span>
                case reflect.Uint:<span class="cov0" title="0">
                        return operation.Ternary(is64, Uint64, Uint32)</span>
                case reflect.Uint8:<span class="cov0" title="0">
                        return Uint8</span>
                case reflect.Uint16:<span class="cov0" title="0">
                        return Uint16</span>
                case reflect.Uint32:<span class="cov0" title="0">
                        return Uint32</span>
                case reflect.Uint64:<span class="cov0" title="0">
                        return Uint64</span>
                case reflect.Float32:<span class="cov0" title="0">
                        return Float32</span>
                case reflect.Float64:<span class="cov0" title="0">
                        return Float64</span>
                case reflect.Bool:<span class="cov0" title="0">
                        return Bool</span>
                case reflect.String:<span class="cov0" title="0">
                        return String</span>
                case reflect.Array, reflect.Slice:<span class="cov0" title="0">
                        return Array</span>
                case reflect.Map:<span class="cov0" title="0">
                        return Map</span>
                case reflect.Struct:<span class="cov0" title="0">
                        return Struct</span>
                default:<span class="cov0" title="0">
                        return Nil</span>
                }
        }

        <span class="cov0" title="0">elem = ref.Elem()

        if elem.Kind() != reflect.Ptr </span><span class="cov0" title="0">{ // 如果不是指针，则判断是否是切片
                if elem.Kind() == reflect.Slice </span><span class="cov0" title="0">{ // 如果是切片，则判断切片元素是否是指针
                        elemType = elem.Type().Elem()
                        switch elemType.Kind() </span>{
                        case reflect.Ptr:<span class="cov0" title="0"> // *[]*struct
                                if elemType.Elem().Kind() == reflect.Struct </span><span class="cov0" title="0">{ // *[]*struct
                                        return PtrSlicePtrStruct
                                }</span> else<span class="cov0" title="0"> if elemType.Elem().Kind() == reflect.Map </span><span class="cov0" title="0">{ // *[]*map
                                        return PtrSlicePtrMap
                                }</span> else<span class="cov0" title="0"> { // *[]*Other
                                        return UnKnowType
                                }</span>
                        case reflect.Struct:<span class="cov0" title="0"> // *[]struct
                                return PtrSliceStruct</span>
                        case reflect.Map:<span class="cov0" title="0"> // *[]map
                                return PtrSliceMap</span>
                        }
                } else<span class="cov0" title="0"> if elem.Kind() == reflect.Struct </span><span class="cov0" title="0">{ // *struct
                        return PtrStruct
                }</span> else<span class="cov0" title="0"> if elem.Kind() == reflect.Map </span><span class="cov0" title="0">{ // *map
                        return PtrMap
                }</span> else<span class="cov0" title="0"> {
                        return Any
                }</span>
        } else<span class="cov0" title="0"> {
                elemType = elem.Type().Elem()
                if elemType.Kind() == reflect.Struct </span><span class="cov0" title="0">{ // **struct
                        return PtrPtrStruct
                }</span> else<span class="cov0" title="0"> if elemType.Kind() == reflect.Map </span><span class="cov0" title="0">{ // **map
                        return PtrPtrMap
                }</span> else<span class="cov0" title="0"> {
                        return Any
                }</span>
        }

        <span class="cov0" title="0">return UnKnowType</span>
}

// IsSame 判断两个类型是否相等
func (my *Reflection) IsSame(value any) bool <span class="cov0" title="0">{ return my.refType == reflect.TypeOf(value) }</span>

// IsSameDeepEqual 判断两个值是否相等
func (my *Reflection) IsSameDeepEqual(value any) bool <span class="cov0" title="0">{
        return reflect.DeepEqual(my.refValue.Interface(), value)
}</span>

// CallMethodByName 通过名称调用方法
func (my *Reflection) CallMethodByName(
        methodName string,
        values ...reflect.Value,
) []reflect.Value <span class="cov0" title="0">{
        refVal := reflect.ValueOf(my.original)
        if refVal.Kind() != reflect.Ptr </span><span class="cov0" title="0">{
                ptr := reflect.New(refVal.Type())
                ptr.Elem().Set(refVal)
                refVal = ptr
        }</span>

        <span class="cov0" title="0">method := refVal.MethodByName(methodName)
        if method.IsValid() </span><span class="cov0" title="0">{
                return method.Call(values)
        }</span>

        <span class="cov0" title="0">return []reflect.Value{}</span>
}

// FindFieldAndFill 递归查找字段并填充
func (my *Reflection) FindFieldAndFill(
        target,
        tagTitle,
        tagField string,
        process func(val reflect.Value),
) <span class="cov0" title="0">{
        findFieldAndFill(my.original, target, tagTitle, tagField, process)
}</span>

// findFieldAndFill 递归查找字段并填充
func findFieldAndFill(
        model any,
        target,
        tagTitle,
        tagField string,
        process func(val reflect.Value),
) <span class="cov0" title="0">{
        var (
                refValue = reflect.ValueOf(model)
                refType  = reflect.TypeOf(model)
        )

        if refValue.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                refValue = refValue.Elem()
                refType = refType.Elem()
        }</span>

        // 遍历结构体的所有字段
        <span class="cov0" title="0">for i := 0; i &lt; refValue.NumField(); i++ </span><span class="cov0" title="0">{
                fieldValue := refValue.Field(i)
                fieldType := refType.Field(i)

                if !fieldValue.CanInterface() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if fieldValue.Kind() == reflect.Struct &amp;&amp; fieldValue.Type() != reflect.TypeOf(time.Time{}) </span><span class="cov0" title="0">{
                        // 如果是纯结构体则进入递归
                        findFieldAndFill(fieldValue.Addr().Interface(), target, tagTitle, tagField, process)
                }</span> else<span class="cov0" title="0"> {
                        if compareTagAndTarget(fieldType.Tag, target, tagTitle, tagField) || str.NewTransfer(fieldType.Name).PascalToSnake() == target </span><span class="cov0" title="0">{
                                process(fieldValue)
                        }</span>
                }
        }
}

// 匹配tag和target
func compareTagAndTarget(
        tag reflect.StructTag,
        target,
        tagTitle,
        tagField string,
) bool <span class="cov0" title="0">{
        var tagValue string = tag.Get(tagTitle)

        if tagValue == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if tagField != "" </span><span class="cov0" title="0">{
                return array.New(strings.Split(tagValue, ";")).
                        Every(func(s string) string </span><span class="cov0" title="0">{
                                t := array.New(strings.Split(s, ":"))
                                return operation.Ternary(t.First() == tagField, t.Last(), "")
                        }</span>).
                        In(target)
        } else<span class="cov0" title="0"> {
                return tagValue == target
        }</span>
}

// HasField 判断结构体是否有某个字段
func (my *Reflection) HasField(fieldName string) bool <span class="cov0" title="0">{ return my.hasField(my.original, fieldName) }</span>

// hasField 判断结构体是否有某个字段
func (my *Reflection) hasField(v any, fieldName string) bool <span class="cov0" title="0">{
        val := reflect.ValueOf(v)

        if val.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                val = val.Elem()
                return my.hasField(val.Interface(), fieldName)
        }</span>

        <span class="cov0" title="0">if val.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">field := val.FieldByName(fieldName)

        return field.IsValid()</span>
}

// Iter 迭代
func (my *Reflection) Iter(fn func(k, v any)) (isIter bool) <span class="cov0" title="0">{
        if _, isBytes := my.original.([]byte); isBytes </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">val := reflect.ValueOf(my.original)

        switch val.Kind() </span>{
        case reflect.Slice, reflect.Array:<span class="cov0" title="0">
                for i := range val.Len() </span><span class="cov0" title="0">{
                        if val.Index(i).Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                                if val.Index(i).IsNil() </span><span class="cov0" title="0">{
                                        fn(i, nil)
                                }</span> else<span class="cov0" title="0"> {
                                        fn(i, val.Index(i).Elem().Interface())
                                }</span>
                        } else<span class="cov0" title="0"> {
                                fn(i, val.Index(i).Interface())
                        }</span>
                }
                <span class="cov0" title="0">isIter = true</span>
        case reflect.Struct:<span class="cov0" title="0">
                for i := range val.NumField() </span><span class="cov0" title="0">{
                        if val.Field(i).Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                                if val.Field(i).IsNil() </span><span class="cov0" title="0">{
                                        fn(val.Type().Field(i).Name, nil)
                                }</span> else<span class="cov0" title="0"> {
                                        fn(val.Type().Field(i).Name, val.Field(i).Elem().Interface())
                                }</span>
                        } else<span class="cov0" title="0"> {
                                fn(val.Type().Field(i).Name, val.Field(i).Interface())
                        }</span>
                }
                <span class="cov0" title="0">isIter = true</span>
        case reflect.Map:<span class="cov0" title="0">
                iter := val.MapRange()
                for iter.Next() </span><span class="cov0" title="0">{
                        if iter.Value().Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                                if iter.Value().IsNil() </span><span class="cov0" title="0">{
                                        fn(iter.Key().Interface(), nil)
                                }</span> else<span class="cov0" title="0"> {
                                        fn(iter.Key().Interface(), iter.Value().Elem().Interface())
                                }</span>
                        } else<span class="cov0" title="0"> {
                                fn(iter.Key().Interface(), iter.Value().Interface())
                        }</span>
                }
                <span class="cov0" title="0">isIter = true</span>
        default:<span class="cov0" title="0">
                isIter = false</span>
        }

        <span class="cov0" title="0">return</span>
}

// Serialize 序列化
func (my *Reflection) Serialize() []string <span class="cov0" title="0">{
        var ret = array.Make[string](0)

        if !my.Iter(func(k, v any) </span><span class="cov0" title="0">{
                ret.Append(fmt.Sprintf(str.APP.Buffer.JoinString("%v", "=&gt;", my.serializeFormat), k, v))
        }</span>) <span class="cov0" title="0">{
                ret.Append(fmt.Sprintf(my.serializeFormat, my.original))
        }</span>

        <span class="cov0" title="0">return ret.ToSlice()</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package reflection

type (
        Attributer interface {
                Register(ref *Reflection)
        }

        AttrSerializeFormat struct{ format string }
)

func SerializeFormat(format string) AttrSerializeFormat <span class="cov0" title="0">{ return AttrSerializeFormat{format} }</span>
func (my AttrSerializeFormat) Register(ref *Reflection) <span class="cov0" title="0">{ ref.serializeFormat = my.format }</span>
</pre>
		
		<pre class="file" id="file67" style="display: none">package regexp

import (
        "regexp"
        "slices"
)

type Regexp struct {
        target  string
        targets []string
        re      regexp.Regexp
}

var RegexpApp Regexp

func (Regexp) New(original string, attrs ...Attributer) Regexp <span class="cov0" title="0">{
        return Regexp{re: *regexp.MustCompile(original)}.SetAttrs(attrs...)
}</span>

func (my Regexp) SetAttrs(attrs ...Attributer) Regexp <span class="cov0" title="0">{
        if len(attrs) &gt; 0 </span><span class="cov0" title="0">{
                for idx := range attrs </span><span class="cov0" title="0">{
                        attrs[idx].Register(&amp;my)
                }</span>
        }

        <span class="cov0" title="0">return my</span>
}

// MatchFirst 查找第一个匹配项
func (my Regexp) MatchFirst() string <span class="cov0" title="0">{
        matched := my.re.FindStringSubmatch(my.target)
        if len(matched) &gt; 1 </span><span class="cov0" title="0">{
                return matched[1]
        }</span>

        <span class="cov0" title="0">return ""</span>
}

// MatchAll 查找所有匹配项
func (my Regexp) MatchAll() []string <span class="cov0" title="0">{
        matched := my.re.FindStringSubmatch(my.target)
        if len(matched) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if len(matched) &gt; 1 </span><span class="cov0" title="0">{
                ret := make([]string, 0, len(matched)-1)
                ret = append(ret, matched[1:]...)
                return ret
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Contains 是否包含匹配项
func (my Regexp) Contains() bool <span class="cov0" title="0">{ return my.re.MatchString(my.target) }</span>

// ContainsAny 是否包含任意一个匹配项
func (my Regexp) ContainsAny() bool <span class="cov0" title="0">{
        if len(my.targets) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return slices.ContainsFunc(my.targets, my.re.MatchString)</span>
}

// FindAllStringSubmatch 查找所有匹配项及子匹配项
func (my Regexp) FindAllStringSubmatch(matchIdx int) []string <span class="cov0" title="0">{
        var msg []string
        matches := my.re.FindAllStringSubmatch(my.target, -1)
        for idx := range matches </span><span class="cov0" title="0">{
                if matchIdx == -1 </span><span class="cov0" title="0">{
                        msg = append(msg, matches[idx]...)
                }</span> else<span class="cov0" title="0"> {
                        msg = append(msg, matches[idx][matchIdx])
                }</span>
        }

        <span class="cov0" title="0">return msg</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package regexp

type (
        Attributer interface{ Register(regexp *Regexp) }

        AttrTargetString  struct{ target string }
        AttrTargetsString struct{ targets []string }
        AttrTargetError   struct{ target error }
        AttrTargetsError  struct{ targets []error }
)

func TargetString(target string) AttrTargetString   <span class="cov0" title="0">{ return AttrTargetString{target} }</span>
func (my AttrTargetString) Register(regexp *Regexp) <span class="cov0" title="0">{ regexp.target = my.target }</span>

func TargetsString(targets ...string) AttrTargetsString <span class="cov0" title="0">{ return AttrTargetsString{targets} }</span>
func (my AttrTargetsString) Register(regexp *Regexp)    <span class="cov0" title="0">{ regexp.targets = my.targets }</span>

func TargetError(target error) AttrTargetError     <span class="cov0" title="0">{ return AttrTargetError{target} }</span>
func (my AttrTargetError) Register(regexp *Regexp) <span class="cov0" title="0">{ regexp.target = my.target.Error() }</span>

func TargetsError(targets ...error) AttrTargetsError <span class="cov0" title="0">{ return AttrTargetsError{targets} }</span>
func (my AttrTargetsError) Register(regexp *Regexp) <span class="cov0" title="0">{
        if len(my.targets) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">ret := make([]string, 0, len(my.targets))
        for idx := range my.targets </span><span class="cov0" title="0">{
                ret = append(ret, my.targets[idx].Error())
        }</span>
        <span class="cov0" title="0">regexp.targets = ret</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package retry

import (
        "context"
        "math/rand"
        "time"
)

type Retry struct {
        sleep time.Duration
        fn    func() error
        ctx   context.Context
}

func (Retry) New(attrs ...Attributer) Retry <span class="cov8" title="1">{
        ins := Retry{fn: nil, ctx: context.TODO()}
        return ins.Set(attrs...)
}</span>

func (my Retry) Set(attrs ...Attributer) Retry <span class="cov8" title="1">{
        if len(attrs) &gt; 0 </span><span class="cov8" title="1">{
                for idx := range attrs </span><span class="cov8" title="1">{
                        attrs[idx].Register(&amp;my)
                }</span>
        }

        <span class="cov8" title="1">return my</span>
}

// Simple 线性重试
func (my Retry) Simple(attempts int) error <span class="cov0" title="0">{
        if my.fn == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if err := my.fn(); err != nil </span><span class="cov0" title="0">{
                if attempts--; attempts &gt; 0 </span><span class="cov0" title="0">{
                        time.Sleep(my.sleep)
                        return my.Simple(attempts)
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Do 指数退避
func (my Retry) Do(attempts int) error <span class="cov8" title="1">{
        if my.fn == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if err := my.fn(); err != nil </span><span class="cov8" title="1">{
                if attempts--; attempts &gt; 0 </span><span class="cov8" title="1">{
                        time.Sleep(my.sleep)
                        return my.Set(Sleep(2 * my.sleep)).Do(attempts)
                }</span>
                <span class="cov8" title="1">return err</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// WithContext 带上下文的重试
func (my Retry) WithContext(attempts int) error <span class="cov8" title="1">{
        if my.fn == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if err := my.fn(); err != nil </span><span class="cov8" title="1">{
                if attempts--; attempts &gt; 0 </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-time.After(my.sleep):<span class="cov8" title="1">
                                return my.Set(Sleep(2 * my.sleep)).WithContext(attempts)</span> // 指数退避
                        case &lt;-my.ctx.Done():<span class="cov8" title="1">
                                return my.ctx.Err()</span>
                        }
                }
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (my Retry) WithContextAndJitter(attempts int) error <span class="cov8" title="1">{
        if my.fn == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if err := my.fn(); err != nil </span><span class="cov8" title="1">{
                if attempts--; attempts &gt; 0 </span><span class="cov8" title="1">{
                        // 加入随机退避
                        jitter := time.Duration(rand.Int63n(int64(my.sleep)))
                        my.sleep = my.sleep + jitter

                        select </span>{
                        case &lt;-time.After(my.sleep):<span class="cov8" title="1">
                                return my.Set(Sleep(2 * my.sleep)).WithContextAndJitter(attempts)</span> // 指数退避
                        case &lt;-my.ctx.Done():<span class="cov8" title="1">
                                return my.ctx.Err()</span>
                        }
                }
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package retry

import (
        "context"
        "time"
)

type (
        Attributer interface {
                Register(retry *Retry)
        }

        AttrSleep   struct{ sleep time.Duration }
        AttrFn      struct{ fn func() error }
        AttrContext struct{ ctx context.Context }
)

func Sleep(sleep time.Duration) AttrSleep <span class="cov8" title="1">{ return AttrSleep{sleep: sleep} }</span>

func (my AttrSleep) Register(retry *Retry) <span class="cov8" title="1">{ retry.sleep = my.sleep }</span>

func Fn(fn func() error) AttrFn <span class="cov8" title="1">{ return AttrFn{fn: fn} }</span>

func (my AttrFn) Register(retry *Retry) <span class="cov8" title="1">{ retry.fn = my.fn }</span>

func Context(ctx context.Context) AttrContext <span class="cov8" title="1">{ return AttrContext{ctx: ctx} }</span>

func (my AttrContext) Register(retry *Retry) <span class="cov8" title="1">{ retry.ctx = my.ctx }</span>
</pre>
		
		<pre class="file" id="file71" style="display: none">package rpcServer

import (
        "net"
        "net/rpc"
)

type Server struct {
        rpc      *rpc.Server
        listener net.Listener
}

func (*Server) New(port string) (*Server, error) <span class="cov8" title="1">{
        var (
                err      error
                listener net.Listener
        )

        if listener, err = net.Listen("tcp", port); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ins := &amp;Server{listener: listener, rpc: rpc.NewServer()}

        return ins, nil</span>
}

func (my *Server) GetRpc() *rpc.Server <span class="cov0" title="0">{ return my.rpc }</span>

func (my *Server) Close() error <span class="cov0" title="0">{ return my.listener.Close() }</span>

func (my *Server) Launch() <span class="cov0" title="0">{ go my.rpc.Accept(my.listener) }</span>
</pre>
		
		<pre class="file" id="file72" style="display: none">package rpcServer

import (
        "sync"

        "github.com/aid297/aid/dict"
)

type Pool struct {
        pool *dict.AnyDict[string, *Server]
        lock sync.RWMutex
        err  error
}

var (
        poolOnce sync.Once
        poolIns  *Pool
)

func (*Pool) Once() *Pool <span class="cov8" title="1">{
        poolOnce.Do(func() </span><span class="cov8" title="1">{ poolIns = &amp;Pool{pool: dict.Make[string, *Server]()} }</span>)
        <span class="cov8" title="1">return poolIns</span>
}

func (*Pool) Error() error <span class="cov0" title="0">{ return poolIns.err }</span>

func (*Pool) Set(name string, port string) (*Server, error) <span class="cov8" title="1">{
        poolIns.lock.RLock()
        defer poolIns.lock.RUnlock()

        var rpcServer *Server
        if rpcServer, poolIns.err = new(Server).New(port); poolIns.err != nil </span><span class="cov8" title="1">{
                return nil, poolIns.err
        }</span>
        <span class="cov0" title="0">poolIns.pool.Set(name, rpcServer)

        return rpcServer, nil</span>
}

func (*Pool) Get(key string) *Server <span class="cov0" title="0">{
        poolIns.lock.RLock()
        defer poolIns.lock.RUnlock()

        if val, ok := poolIns.pool.Get(key); ok </span><span class="cov0" title="0">{
                return val
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (*Pool) Close(key string) *Pool <span class="cov0" title="0">{
        poolIns.lock.RLock()
        defer poolIns.lock.RUnlock()

        var rpcServer = poolIns.Get(key)

        if rpcServer != nil </span><span class="cov0" title="0">{
                if poolIns.err = rpcServer.Close(); poolIns.err != nil </span><span class="cov0" title="0">{
                        return poolIns
                }</span>
                <span class="cov0" title="0">poolIns.pool.RemoveByKey(key)</span>
        }

        <span class="cov0" title="0">return poolIns</span>
}

func (*Pool) Clean() []error <span class="cov0" title="0">{
        poolIns.lock.RLock()
        defer poolIns.lock.RUnlock()

        var errs []error

        for key, rpcServer := range poolIns.pool.ToMap() </span><span class="cov0" title="0">{
                if err := rpcServer.Close(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                        continue</span>
                }
                <span class="cov0" title="0">poolIns.pool.RemoveByKey(key)</span>
        }

        <span class="cov0" title="0">return errs</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">package asymmetric

import (
        "crypto/x509"
        "encoding/base64"
        "encoding/pem"
        "errors"
        "fmt"
)

type PemBase64 struct {
        base64PublicKey  string
        base64PrivateKey string
        publicKey        []byte
        privateKey       []byte
}

var PemBase64App PemBase64

func (*PemBase64) New() *PemBase64 <span class="cov0" title="0">{ return &amp;PemBase64{} }</span>

// NewPemBase64 实例化
//
//go:fix 推荐使用：New方法
func NewPemBase64() *PemBase64 <span class="cov0" title="0">{ return &amp;PemBase64{} }</span>

func (my *PemBase64) SetBase64PublicKey(base64PublicKey string) *PemBase64 <span class="cov0" title="0">{
        my.base64PublicKey = base64PublicKey

        return my
}</span>

func (my *PemBase64) SetBase64PrivateKye(base64PrivateKey string) *PemBase64 <span class="cov0" title="0">{
        my.base64PrivateKey = base64PrivateKey

        return my
}</span>

func (my *PemBase64) GetBase64PublicKey() string <span class="cov0" title="0">{ return my.base64PublicKey }</span>

func (my *PemBase64) GetBase64PrivateKey() string <span class="cov0" title="0">{ return my.base64PrivateKey }</span>

func (my *PemBase64) GetPemPublicKey() []byte <span class="cov0" title="0">{ return my.publicKey }</span>

func (my *PemBase64) GeneratePemPublicKey() (*PemBase64, error) <span class="cov0" title="0">{
        // 解码Base64字符串
        publicKeyBytes, err := base64.StdEncoding.DecodeString(my.base64PublicKey)
        if err != nil </span><span class="cov0" title="0">{
                return my, fmt.Errorf("解码Base64失败: %v", err)
        }</span>

        // 尝试解析为PEM块
        <span class="cov0" title="0">block, _ := pem.Decode(publicKeyBytes)
        if block == nil </span><span class="cov0" title="0">{
                // 如果不是PEM格式，则尝试解析为x509公钥并创建一个PEM块
                _, err = x509.ParsePKIXPublicKey(publicKeyBytes)
                if err != nil </span><span class="cov0" title="0">{
                        return my, fmt.Errorf("解析公钥失败se64失败: %v", err)
                }</span>

                // 创建PEM块
                <span class="cov0" title="0">block = &amp;pem.Block{
                        Type:  "PUBLIC KEY",
                        Bytes: publicKeyBytes,
                }</span>
        }

        // 将PEM块编码为内存中的字节切片
        <span class="cov0" title="0">my.publicKey = pem.EncodeToMemory(block)

        return my, nil</span>
}

// GetPemPrivateKey 获取pem私钥
func (my *PemBase64) GetPemPrivateKey() []byte <span class="cov0" title="0">{ return my.privateKey }</span>

// GeneratePemPrivateKey 生成pem密钥
func (my *PemBase64) GeneratePemPrivateKey() (*PemBase64, error) <span class="cov0" title="0">{
        // 解码Base64字符串
        privateKeyBytes, err := base64.StdEncoding.DecodeString(my.base64PrivateKey)
        if err != nil </span><span class="cov0" title="0">{
                return my, fmt.Errorf("解码Base64失败: %v", err)
        }</span>

        // 手动添加PEM头部和尾部
        <span class="cov0" title="0">pemBlock := &amp;pem.Block{
                Type:  "RSA PRIVATE KEY",
                Bytes: privateKeyBytes,
        }

        my.privateKey = pem.EncodeToMemory(pemBlock)

        // 尝试解析为PEM块
        block, _ := pem.Decode(my.privateKey)
        if block == nil </span><span class="cov0" title="0">{
                return my, errors.New("不是有效的PEM编码私钥")
        }</span>

        <span class="cov0" title="0">return my, nil</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package asymmetric

import (
        "bytes"
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "encoding/base64"
        "encoding/json"
        "encoding/pem"
        "errors"
        "fmt"

        "github.com/aid297/aid/compression"
        "github.com/aid297/aid/str"
)

type (
        Rsa       struct{}
        UnEncrypt struct {
                Username string `json:"username"`
                Password string `json:"password"`
                AesKey   string `json:"aes_key"`
        }
)

var RsaApp Rsa

func (*Rsa) New() *Rsa <span class="cov0" title="0">{ return &amp;Rsa{} }</span>

// NewRsa 实例化：Rsa加密
//
//go:fix 推荐使用：New方法
func NewRsa() *Rsa <span class="cov0" title="0">{ return &amp;Rsa{} }</span>

// EncryptByBase64 通过base64公钥加密
func (my *Rsa) EncryptByBase64(base64PublicKey string, plainText []byte) ([]byte, error) <span class="cov0" title="0">{
        var (
                pemBase64 *PemBase64
                err       error
        )

        pemBase64, err = NewPemBase64().
                SetBase64PublicKey(base64PublicKey).
                GeneratePemPublicKey()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return my.EncryptByPem(pemBase64.GetPemPublicKey(), plainText)</span>
}

// EncryptByPem 通过pem公钥加密
func (my *Rsa) EncryptByPem(pemPublicKey []byte, plainText []byte) ([]byte, error) <span class="cov0" title="0">{
        var (
                err                error
                block              *pem.Block
                publicKeyInterface any
                publicKey          *rsa.PublicKey
                cipherText         []byte
        )

        block, _ = pem.Decode(pemPublicKey)
        if block == nil || block.Type != "PUBLIC KEY" </span><span class="cov0" title="0">{
                return nil, errors.New("公钥类型错误")
        }</span>

        // x509解码
        <span class="cov0" title="0">publicKeyInterface, err = x509.ParsePKIXPublicKey(block.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // 类型断言
        <span class="cov0" title="0">publicKey = publicKeyInterface.(*rsa.PublicKey)

        if len(plainText) &gt; publicKey.N.BitLen()/8-11 </span><span class="cov0" title="0">{
                // 密文长度超过密钥长度，需要分段加密
                cipherText, err = my.encryptWithTooLong(publicKey, plainText)
        }</span> else<span class="cov0" title="0"> {
                // 对明文进行加密
                cipherText, err = rsa.EncryptPKCS1v15(rand.Reader, publicKey, plainText)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 返回密文
        <span class="cov0" title="0">return cipherText, nil</span>
}

// encryptWithTooLong 分段加密处理
func (my *Rsa) encryptWithTooLong(publicKey *rsa.PublicKey, plainText []byte) ([]byte, error) <span class="cov0" title="0">{
        var (
                maxChunkSize = publicKey.N.BitLen()/8 - 11 // 计算每个分段的最大长度
                cipherTexts  [][]byte                      // 存储每个分段加密后的结果
        )

        // 分割明文
        for i := 0; i &lt; len(plainText); i += maxChunkSize </span><span class="cov0" title="0">{
                end := i + maxChunkSize
                if end &gt; len(plainText) </span><span class="cov0" title="0">{
                        end = len(plainText)
                }</span>

                <span class="cov0" title="0">chunk := plainText[i:end]

                // 加密当前分段
                encryptedChunk, err := rsa.EncryptPKCS1v15(rand.Reader, publicKey, chunk)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">cipherTexts = append(cipherTexts, encryptedChunk)</span>
        }

        // 合并所有加密后的分段
        <span class="cov0" title="0">finalCipherText := bytes.Join(cipherTexts, []byte{})

        return finalCipherText, nil</span>
}

// DecryptByBase64 通过base64私钥解密
func (my *Rsa) DecryptByBase64(base64PrivateKey string, cipherText []byte) ([]byte, error) <span class="cov0" title="0">{
        var (
                pemBase64 *PemBase64
                err       error
        )

        pemBase64, err = NewPemBase64().SetBase64PrivateKye(base64PrivateKey).GeneratePemPrivateKey()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return my.DecryptByPem(pemBase64.GetPemPrivateKey(), cipherText)</span>
}

// DecryptByPem 使用PEM私钥进行RSA解密
func (my *Rsa) DecryptByPem(pemPrivateKey []byte, cipherText []byte) ([]byte, error) <span class="cov0" title="0">{
        var (
                err                       error
                block                     *pem.Block
                privateKey, rsaPrivateKey *rsa.PrivateKey
                privateKeyInterface       any
                ok                        bool
                plainText                 []byte
        )

        block, _ = pem.Decode(pemPrivateKey)
        if block == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode PEM block containing the private key")
        }</span>

        // 解析DER编码的私钥
        <span class="cov0" title="0">privateKey, err = x509.ParsePKCS1PrivateKey(block.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                // 尝试解析PKCS8格式的私钥
                privateKeyInterface, err = x509.ParsePKCS8PrivateKey(block.Bytes)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse private key: %w", err)
                }</span>

                // 使用类型断言将interface{}转换为*rsa.PrivateKey
                <span class="cov0" title="0">rsaPrivateKey, ok = privateKeyInterface.(*rsa.PrivateKey)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to cast private key to *rsa.PrivateKey")
                }</span>
                <span class="cov0" title="0">privateKey = rsaPrivateKey</span>
        }

        <span class="cov0" title="0">if len(plainText) &gt; privateKey.PublicKey.N.BitLen() </span><span class="cov0" title="0">{
                // 分段解密
                _, err2 := my.decryptWithTooLong(privateKey, cipherText)
                if err2 != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("分段解密错误：%v", err2)
                }</span>
        } else<span class="cov0" title="0"> {
                // 解密数据
                plainText, err = rsa.DecryptPKCS1v15(rand.Reader, privateKey, cipherText)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to decrypt: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return plainText, nil</span>
}

// decryptWithTooLong 分段解密
func (my *Rsa) decryptWithTooLong(privateKey *rsa.PrivateKey, cipherText []byte) ([]byte, error) <span class="cov0" title="0">{
        var (
                maxChunkSize int
                plainTexts   [][]byte
        )

        // 计算每个分段的最大长度
        maxChunkSize = privateKey.PublicKey.N.BitLen() / 8

        // 分割密文
        for i := 0; i &lt; len(cipherText); i += maxChunkSize </span><span class="cov0" title="0">{
                end := i + maxChunkSize
                if end &gt; len(cipherText) </span><span class="cov0" title="0">{
                        end = len(cipherText)
                }</span>

                <span class="cov0" title="0">chunk := cipherText[i:end]

                // 解密当前分段
                decryptedChunk, err := rsa.DecryptPKCS1v15(rand.Reader, privateKey, chunk)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to decrypt segment: %w", err)
                }</span>
                <span class="cov0" title="0">plainTexts = append(plainTexts, decryptedChunk)</span>
        }

        // 合并所有解密后的分段
        <span class="cov0" title="0">finalPlainText := bytes.Join(plainTexts, []byte{})

        return finalPlainText, nil</span>
}

func (*Rsa) DemoEncryptRsa(unEncrypt []byte) string <span class="cov0" title="0">{
        var (
                base64PublicKey                     = "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCFbbjNGuqhF3HhmvnZxjG6mS6Q3OmD/vh9voriZTyNCVLJ7y2r0bHZZ7brWwkgtGPQXosZ0IzUZAvlMuZ0m11DiuXZzlCnRz1owwMXKalJeeKQwA8CoJBSy99zCo9fxIErqTMhGwPFCKUaByt8TEIkNq8fUsmqjqqshRLKSazWuwIDAQAB"
                encrypted                           []byte
                base64Encrypted                     string
                pemPublicKey                        []byte
                pemBase64                           *PemBase64
                generatePemPublicKeyErr, encryptErr error
        )

        pemBase64, generatePemPublicKeyErr = PemBase64App.New().SetBase64PublicKey(base64PublicKey).GeneratePemPublicKey()
        if generatePemPublicKeyErr != nil </span><span class="cov0" title="0">{
                str.TerminalLogApp.New("[RSA] generate public key: %v").Error(generatePemPublicKeyErr)
        }</span>

        <span class="cov0" title="0">pemPublicKey = pemBase64.GetPemPublicKey()
        str.TerminalLogApp.New("[RSA] generate public key: \n%s").Info(pemPublicKey)

        encrypted, encryptErr = RsaApp.New().EncryptByPem(pemPublicKey, unEncrypt)
        if encryptErr != nil </span><span class="cov0" title="0">{
                str.TerminalLogApp.New("[RSA] encrypt: %v").Error(encryptErr)
        }</span>
        <span class="cov0" title="0">base64Encrypted = base64.StdEncoding.EncodeToString(encrypted)

        return base64Encrypted</span>
}

func (*Rsa) DemoDecryptRsa(base64Encrypted string) string <span class="cov0" title="0">{
        var (
                base64PrivateKey                                     = "MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAIVtuM0a6qEXceGa+dnGMbqZLpDc6YP++H2+iuJlPI0JUsnvLavRsdlntutbCSC0Y9BeixnQjNRkC+Uy5nSbXUOK5dnOUKdHPWjDAxcpqUl54pDADwKgkFLL33MKj1/EgSupMyEbA8UIpRoHK3xMQiQ2rx9SyaqOqqyFEspJrNa7AgMBAAECgYATaA4E5vFRVNOfeKb2YblB5p27PCZKqH8D6v7QRuEzsjN0Y3FFGE7BzC/ys170fsg1ukqJCqgxDAwe3fRe6Wn6/Y5IEF/wRYODQn6yAXhCUepheaRl9zK+P+XXbGWENdL2N/KchNZrKUF97Eu00OhBI7uEKpUrhPuzaYDPiHujQQJBAOvc+Xwz3j/srv26bk5UJOAJtU096pNseEeVzFqSTU903NdgFUQupTsPeokUtMBeMihAYlfDZypIK0kvBoymTNkCQQCQ0e/vEGnqh9C0y340HUlIZe0Q5mAJ5e+3a7lR21LS9ki5vQLUf2Wjxw/QVbPDZthGK33BusrobyuwcVOMmROzAkEAz9lefeZTb6/Kkcvtktcx28CSZawvgJTw9dx7RkFxIZkRWDbS5s/YSdCdIhn+IxufRbtfLooC6s7IXmizc9TFGQJAZP1hum7RzbFkg4+ctK7vmcMqbKyasIxefKRsmX6+5UrGMHB0dsdYk7uPdZMuRseDbnuJuP2P3kMYTnTY9KUTLQJANq7Cy5OjtHiJ5EsRBePfGm9Qvs3mwJZAKDpZsmTRSyaQCTCpL6RQ+7gVFIEmiEU4REjag9/aq8C1G0MyvwxkiA=="
                pemPrivateKey, encrypted                             []byte
                base64DecodeErr, generatePemPublicKeyErr, decryptErr error
                pemBase64                                            *PemBase64
                decrypted                                            []byte
        )

        pemBase64, generatePemPublicKeyErr = PemBase64App.New().SetBase64PrivateKye(base64PrivateKey).GeneratePemPrivateKey()
        if generatePemPublicKeyErr != nil </span><span class="cov0" title="0">{
                str.TerminalLogApp.New("[RSA] generate private key: %v").Info(generatePemPublicKeyErr)
        }</span>

        <span class="cov0" title="0">pemPrivateKey = pemBase64.GetPemPrivateKey()
        str.TerminalLogApp.New("[RSA] generate private key: %s").Info(pemPrivateKey)

        encrypted, base64DecodeErr = base64.StdEncoding.DecodeString(base64Encrypted)
        if base64DecodeErr != nil </span><span class="cov0" title="0">{
                str.TerminalLogApp.New("[RSA] base64 decode: %v").Error(base64DecodeErr)
        }</span>

        <span class="cov0" title="0">decrypted, decryptErr = RsaApp.New().DecryptByPem(pemPrivateKey, encrypted)
        if decryptErr != nil </span><span class="cov0" title="0">{
                str.TerminalLogApp.New("[RSA] decrypt: %v").Error(decryptErr)
        }</span>

        <span class="cov0" title="0">return string(decrypted)</span>
}

func (my *Rsa) Demo() <span class="cov0" title="0">{
        var (
                unEncrypt = UnEncrypt{
                        Username: "cbit",
                        Password: "cbit-pwd",
                        // AesKey:   "tjp5OPIU1ETF5s33fsLWdA==",
                        AesKey: "87dwQRkoNFNoIcq1A+zFHA==",
                }
                jsonByte, zipByte, unzipByte  []byte
                jsonErr, zipErr, unzipByteErr error
        )

        // json序列化
        jsonByte, jsonErr = json.Marshal(unEncrypt)
        if jsonErr != nil </span><span class="cov0" title="0">{
                str.TerminalLogApp.New("[RSA] json marshal failed: %v").Error(zipErr)
        }</span>

        // zip压缩
        <span class="cov0" title="0">zipByte, zipErr = compression.ZlibApp.New().Compress(jsonByte)
        if zipErr != nil </span><span class="cov0" title="0">{
                str.TerminalLogApp.New("[RSA] zip failed: %v").Error(zipErr)
        }</span>

        <span class="cov0" title="0">base64Encrypted := my.DemoEncryptRsa(zipByte) // 加密
        str.TerminalLogApp.New("[RSA] encrypting: %s").Success(base64Encrypted)

        decrypted := my.DemoDecryptRsa(base64Encrypted) // 解密
        str.TerminalLogApp.New("[RSA] decrypted").Info()

        // 解密后解压缩
        unzipByte, unzipByteErr = compression.ZlibApp.New().Decompress([]byte(decrypted))
        if unzipByteErr != nil </span><span class="cov0" title="0">{
                str.TerminalLogApp.New("[RSA] unzipped failed: %v").Error(unzipByteErr)
        }</span>
        <span class="cov0" title="0">str.TerminalLogApp.New("[RSA] unzipped").Info()

        str.TerminalLogApp.New("[RSA] decrypted: %s").Success(string(unzipByte))</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">package secret

import (
        "crypto/md5"
        "encoding/base64"
        "encoding/json"
        "errors"
        "fmt"
        "hash"

        "github.com/aid297/aid/compression"

        "github.com/aid297/aid/common"
        "github.com/aid297/aid/secret/symmetric"
        "github.com/aid297/aid/str"
)

func EncryptAuthorization(key, secretKey string, iv []byte, randStr ...string) (string, string, error) <span class="cov0" title="0">{
        var (
                err   error
                uuid  string
                token []byte
        )

        if key == "" </span><span class="cov0" title="0">{
                return "", "", err
        }</span>
        // 生成随机串
        <span class="cov0" title="0">if len(randStr) &gt; 0 </span><span class="cov0" title="0">{
                uuid = randStr[0]
        }</span> else<span class="cov0" title="0"> {
                uuid, err = MustEncrypt(str.NewRand().GetLetters(10))
                if err != nil </span><span class="cov0" title="0">{
                        return "", "", err
                }</span>
        }

        <span class="cov0" title="0">token, err = symmetric.Cbc{}.Encrypt([]byte(key+uuid), []byte(secretKey), iv)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov0" title="0">return base64.StdEncoding.EncodeToString(token), uuid, nil</span>
}

func DecryptAuthorization(token, secretKey string, iv []byte) (string, string, error) <span class="cov0" title="0">{
        var (
                err                   error
                token64, decryptToken []byte
        )

        if token == "" </span><span class="cov0" title="0">{
                return "", "", errors.New("token 不能为空")
        }</span>

        <span class="cov0" title="0">token64, err = base64.StdEncoding.DecodeString(token)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("base64解码token失败：%s", err.Error())
        }</span>
        <span class="cov0" title="0">decryptToken, err = symmetric.Cbc{}.Decrypt(token64, []byte(secretKey), iv)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("解密失败：%s", err.Error())
        }</span>

        <span class="cov0" title="0">return string(decryptToken[:len(decryptToken)-32]), string(decryptToken[len(decryptToken)-32:]), nil</span>
}

func MustEncrypt(data any) (string, error) <span class="cov0" title="0">{
        var (
                err       error
                dataBytes []byte
                h         hash.Hash
        )
        dataBytes = common.ToBytes(data)

        h = md5.New()
        if _, err = h.Write(dataBytes); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%x", h.Sum(nil)), nil</span>
}

func Ecb16Encrypt(data any, needEncrypt, needZip bool, aes *symmetric.Aes) (string, error) <span class="cov0" title="0">{
        var (
                jsonByte, b                        []byte
                jsonMarshalErr, zipErr, encryptErr error
        )

        // json序列化
        jsonByte, jsonMarshalErr = json.Marshal(data)
        if jsonMarshalErr != nil </span><span class="cov0" title="0">{
                return "", jsonMarshalErr
        }</span>

        // 压缩
        <span class="cov0" title="0">if needZip </span><span class="cov0" title="0">{
                b, zipErr = compression.NewZlib().Compress(jsonByte)
                if zipErr != nil </span><span class="cov0" title="0">{
                        return "", zipErr
                }</span>
        }

        // 加密
        <span class="cov0" title="0">if needEncrypt </span><span class="cov0" title="0">{
                b, encryptErr = symmetric.Ecb{}.Encrypt(b, aes.Encrypt.GetAesKey())
                if encryptErr != nil </span><span class="cov0" title="0">{
                        return "", encryptErr
                }</span>
        }

        <span class="cov0" title="0">if !needZip &amp;&amp; !needEncrypt </span><span class="cov0" title="0">{
                return string(b), nil
        }</span> else<span class="cov0" title="0"> {
                return base64.StdEncoding.EncodeToString(b), nil
        }</span>
}

func Ecb16Decrypt(data string, needEncrypt, needZip bool, aes *symmetric.Aes) (any, error) <span class="cov0" title="0">{
        var (
                r                                                     any
                cipherText, decryptedByte, decompressedByte           []byte
                base64DecodeErr, jsonUnmarshalErr, decryptErr, zipErr error
        )

        if needEncrypt </span><span class="cov0" title="0">{
                // base64 解码
                cipherText, base64DecodeErr = base64.StdEncoding.DecodeString(data)
                if base64DecodeErr != nil </span><span class="cov0" title="0">{
                        return nil, base64DecodeErr
                }</span>

                // aes解密：ecb
                <span class="cov0" title="0">decryptedByte, decryptErr = symmetric.Ecb{}.Decrypt(cipherText, aes.Encrypt.GetAesKey())
                if decryptErr != nil </span><span class="cov0" title="0">{
                        return nil, decryptErr
                }</span>

                // 解压
                <span class="cov0" title="0">if needZip </span><span class="cov0" title="0">{
                        decompressedByte, zipErr = compression.NewZlib().Decompress(decryptedByte)
                        if zipErr != nil </span><span class="cov0" title="0">{
                                return nil, zipErr
                        }</span>

                        <span class="cov0" title="0">jsonUnmarshalErr = json.Unmarshal(decompressedByte, &amp;r)
                        if jsonUnmarshalErr != nil </span><span class="cov0" title="0">{
                                return nil, jsonUnmarshalErr
                        }</span>

                        <span class="cov0" title="0">return r, nil</span>
                } else<span class="cov0" title="0"> {
                        // 将data反序列化
                        jsonUnmarshalErr = json.Unmarshal(decryptedByte, &amp;r)
                        if jsonUnmarshalErr != nil </span><span class="cov0" title="0">{
                                return nil, jsonUnmarshalErr
                        }</span>

                        <span class="cov0" title="0">return r, nil</span>
                }
        } else<span class="cov0" title="0"> {
                jsonUnmarshalErr = json.Unmarshal([]byte(data), &amp;r)
                if jsonUnmarshalErr != nil </span><span class="cov0" title="0">{
                        return nil, jsonUnmarshalErr
                }</span>
        }

        <span class="cov0" title="0">return r, nil</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">package symmetric

import (
        "crypto/rand"
        "encoding/base64"
        "io"
)

type (
        // Aes Aes密钥对象
        Aes struct {
                Err     error
                Encrypt *AesEncrypt
                Decrypt *AesDecrypt
                sailStr string
        }

        // AesEncrypt Aes加密密钥对象
        AesEncrypt struct {
                Err      error
                sailStr  string
                sailByte []byte
                randKey  []byte
                aesKey   []byte
                openKey  string
        }

        // AesDecrypt Aes解密密钥对象
        AesDecrypt struct {
                Err      error
                sailStr  string
                sailByte []byte
                randKey  []byte
                aesKey   []byte
                openKey  string
        }
)

var AesApp Aes

func (*Aes) New(sail string) *Aes <span class="cov0" title="0">{ return &amp;Aes{sailStr: sail} }</span>

// NewAes 实例化：Aes密钥
//
//go:fix 推荐使用：New方法
func NewAes(sail string) *Aes <span class="cov8" title="1">{ return &amp;Aes{sailStr: sail} }</span>

// NewEncrypt 实例化：Aes加密密钥对象
func (my *Aes) NewEncrypt() *Aes <span class="cov8" title="1">{
        my.Encrypt = NewAesEncrypt(my.sailStr)

        return my
}</span>

// NewDecrypt 实例化：Aes解密密钥对象
func (my *Aes) NewDecrypt(openKey string) *Aes <span class="cov8" title="1">{
        my.Decrypt = NewAesDecrypt(my.sailStr, openKey)

        return my
}</span>

// GetEncrypt 获取加密密钥
func (my *Aes) GetEncrypt() *AesEncrypt <span class="cov8" title="1">{ return my.Encrypt }</span>

// GetDecrypt 获取解密密钥
func (my *Aes) GetDecrypt() *AesDecrypt <span class="cov8" title="1">{ return my.Decrypt }</span>

// NewAesEncrypt 实例化：Aes加密密钥对象
func NewAesEncrypt(sail string) *AesEncrypt <span class="cov8" title="1">{
        aesHelper := &amp;AesEncrypt{
                sailStr:  sail,
                sailByte: make([]byte, 16),
                randKey:  make([]byte, 16),
                aesKey:   make([]byte, 16),
                openKey:  "",
        }

        aesHelper.randKey = make([]byte, 16)
        _, aesHelper.Err = io.ReadFull(rand.Reader, aesHelper.randKey)
        aesHelper.sailByte, aesHelper.Err = base64.StdEncoding.DecodeString(sail)

        return aesHelper.sailByByte()
}</span>

// sailByByte 密码加盐：使用byte盐
func (r *AesEncrypt) sailByByte() *AesEncrypt <span class="cov8" title="1">{
        copy(r.aesKey, r.randKey)

        for i := 0; i &lt; 4; i++ </span><span class="cov8" title="1">{
                index := int(r.randKey[i]) % 16
                r.aesKey[index] = r.sailByte[index]
        }</span>

        <span class="cov8" title="1">r.openKey = base64.StdEncoding.EncodeToString(r.randKey)

        return r</span>
}

// GetAesKey 获取加盐后的密钥
func (r *AesEncrypt) GetAesKey() []byte <span class="cov8" title="1">{ return r.aesKey }</span>

// SetAesKey 设置加盐后的密钥
func (r *AesEncrypt) SetAesKey(aesKey []byte) *AesEncrypt <span class="cov0" title="0">{
        r.aesKey = aesKey

        return r
}</span>

// GetOpenKey 获取公开密码
func (r *AesEncrypt) GetOpenKey() string <span class="cov8" title="1">{ return r.openKey }</span>

// NewAesDecrypt 实例化：Aes解密密钥对象
func NewAesDecrypt(sailStr, openKey string) *AesDecrypt <span class="cov8" title="1">{
        aesDecrypt := &amp;AesDecrypt{
                sailStr:  sailStr,
                sailByte: make([]byte, 16),
                randKey:  make([]byte, 16),
                aesKey:   make([]byte, 16),
                openKey:  openKey,
        }

        aesDecrypt.randKey, aesDecrypt.Err = base64.StdEncoding.DecodeString(openKey)
        copy(aesDecrypt.aesKey, aesDecrypt.randKey)
        aesDecrypt.sailByte, aesDecrypt.Err = base64.StdEncoding.DecodeString(sailStr)

        return aesDecrypt.deSailByByte()
}</span>

// deSailByByte 密码解盐：使用byte盐
func (r *AesDecrypt) deSailByByte() *AesDecrypt <span class="cov8" title="1">{
        index := r.randKey[:4]

        // 替换key中的字节
        for _, x := range index </span><span class="cov8" title="1">{
                i := int(x) % 16
                r.aesKey[i] = r.sailByte[i]
        }</span>

        <span class="cov8" title="1">return r</span>
}

// GetAesKey 获取加盐后的密钥
func (r *AesDecrypt) GetAesKey() []byte <span class="cov8" title="1">{
        return r.aesKey
}</span>

// SetAesKey 设置加盐后的密钥
func (r *AesDecrypt) SetAesKey(aesKey []byte) *AesDecrypt <span class="cov0" title="0">{
        r.aesKey = aesKey
        return r
}</span>

// GetOpenKey 获取公开密码
func (r *AesDecrypt) GetOpenKey() string <span class="cov0" title="0">{
        return r.openKey
}</span>
</pre>
		
		<pre class="file" id="file77" style="display: none">package symmetric

import (
        "bytes"
        "crypto/aes"
        "crypto/cipher"
        "encoding/base64"
        "errors"
        "fmt"

        "github.com/aid297/aid/str"
)

type Cbc struct{}

var CbcApp Cbc

func (Cbc) padPKCS7(src []byte, blockSize int) []byte <span class="cov0" title="0">{
        padding := blockSize - len(src)%blockSize
        padtext := bytes.Repeat([]byte{byte(padding)}, padding)
        return append(src, padtext...)
}</span>

func (Cbc) unPadPKCS7(src []byte, blockSize int) ([]byte, error) <span class="cov0" title="0">{
        length := len(src)
        if blockSize &lt;= 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid blockSize: %d", blockSize)
        }</span>

        <span class="cov0" title="0">if length%blockSize != 0 || length == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("invalid data len")
        }</span>

        <span class="cov0" title="0">unpadding := int(src[length-1])
        if unpadding &gt; blockSize || unpadding == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("invalid unpadding")
        }</span>

        <span class="cov0" title="0">padding := src[length-unpadding:]
        for i := 0; i &lt; unpadding; i++ </span><span class="cov0" title="0">{
                if padding[i] != byte(unpadding) </span><span class="cov0" title="0">{
                        return nil, errors.New("invalid padding")
                }</span>
        }

        <span class="cov0" title="0">return src[:(length - unpadding)], nil</span>
}

func (Cbc) Encrypt(plainText, key, iv []byte, ivs ...[]byte) ([]byte, error) <span class="cov0" title="0">{
        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">blockSize := block.BlockSize()
        plainText = Cbc{}.padPKCS7(plainText, blockSize)
        ivValue := ([]byte)(nil)
        if len(ivs) &gt; 0 </span><span class="cov0" title="0">{
                ivValue = ivs[0]
        }</span> else<span class="cov0" title="0"> {
                ivValue = iv
        }</span>
        <span class="cov0" title="0">blockMode := cipher.NewCBCEncrypter(block, ivValue)
        cipherText := make([]byte, len(plainText))
        blockMode.CryptBlocks(cipherText, plainText)

        return cipherText, nil</span>
}

func (Cbc) Decrypt(cipherText, key, iv []byte, ivs ...[]byte) ([]byte, error) <span class="cov0" title="0">{
        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">blockSize := block.BlockSize()
        if len(cipherText) &lt; blockSize </span><span class="cov0" title="0">{
                return nil, errors.New("cipherText too short")
        }</span>
        <span class="cov0" title="0">ivValue := ([]byte)(nil)
        if len(ivs) &gt; 0 </span><span class="cov0" title="0">{
                ivValue = ivs[0]
        }</span> else<span class="cov0" title="0"> {
                ivValue = iv
        }</span>
        <span class="cov0" title="0">if len(cipherText)%blockSize != 0 </span><span class="cov0" title="0">{
                return nil, errors.New("cipherText is not a multiple of the block size")
        }</span>
        <span class="cov0" title="0">blockModel := cipher.NewCBCDecrypter(block, ivValue)
        plainText := make([]byte, len(cipherText))
        blockModel.CryptBlocks(plainText, cipherText)
        plainText, e := Cbc{}.unPadPKCS7(plainText, blockSize)
        if e != nil </span><span class="cov0" title="0">{
                return nil, e
        }</span>
        <span class="cov0" title="0">return plainText, nil</span>
}

func (Cbc) Demo() <span class="cov0" title="0">{
        key := "tjp5OPIU1ETF5s33fsLWdA=="
        iv := "0987654321098765"

        encrypted, err := Cbc{}.Encrypt([]byte("abcdefghijklmnopqrstuvwxyz"), []byte(key), []byte(iv))
        if err != nil </span><span class="cov0" title="0">{
                str.TerminalLogApp.New("[CBC] encrypt: %v").Error(err)
        }</span>

        <span class="cov0" title="0">base64Encoded := base64.StdEncoding.EncodeToString(encrypted)
        str.TerminalLogApp.New("[CBC] base64 encoded: %s").Success(base64Encoded)

        base64Decoded, base64DecodeErr := base64.StdEncoding.DecodeString(base64Encoded)
        if base64DecodeErr != nil </span><span class="cov0" title="0">{
                str.TerminalLogApp.New("[CBC] base64 decode %v").Error(base64DecodeErr)
        }</span>

        <span class="cov0" title="0">decryptCBC, err := Cbc{}.Decrypt(base64Decoded, []byte(key), []byte(iv))
        if err != nil </span><span class="cov0" title="0">{
                str.TerminalLogApp.New("[CBC] decrypt: %v").Error(err)
        }</span>

        <span class="cov0" title="0">str.TerminalLogApp.New("[CBC] decrypted: %s").Success(string(decryptCBC))</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package symmetric

import (
        "bytes"
        "crypto/aes"
        "errors"
        "fmt"
)

type Ecb struct{}

var EcbApp Ecb

// padPKCS7 pads the plaintext to be a multiple of the block size
func (Ecb) padPKCS7(plaintext []byte, blockSize int) []byte <span class="cov8" title="1">{
        padding := blockSize - len(plaintext)%blockSize
        padtext := bytes.Repeat([]byte{byte(padding)}, padding)

        return append(plaintext, padtext...)
}</span>

// unPadPKCS7 removes the padding from the decrypted text
func (Ecb) unPadPKCS7(plaintext []byte) []byte <span class="cov0" title="0">{
        length := len(plaintext)
        unpadding := int(plaintext[length-1])

        return plaintext[:(length - unpadding)]
}</span>

func (Ecb) unPadPKCS72(src []byte, blockSize int) ([]byte, error) <span class="cov8" title="1">{
        length := len(src)
        if blockSize &lt;= 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid blockSize: %d", blockSize)
        }</span>

        <span class="cov8" title="1">if length%blockSize != 0 || length == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("invalid data len")
        }</span>

        <span class="cov8" title="1">unpadding := int(src[length-1])
        if unpadding &gt; blockSize </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid unpadding: %d", unpadding)
        }</span>

        <span class="cov8" title="1">if unpadding == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("invalid unpadding: 0")
        }</span>

        <span class="cov8" title="1">padding := src[length-unpadding:]
        for i := 0; i &lt; unpadding; i++ </span><span class="cov8" title="1">{
                if padding[i] != byte(unpadding) </span><span class="cov0" title="0">{
                        return nil, errors.New("invalid padding")
                }</span>
        }

        <span class="cov8" title="1">return src[:(length - unpadding)], nil</span>
}

// Encrypt encrypts plaintext using AES in ECB mode
func (Ecb) Encrypt(key, plaintext []byte) ([]byte, error) <span class="cov8" title="1">{
        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">blockSize := block.BlockSize()
        plaintext = Ecb{}.padPKCS7(plaintext, blockSize)
        cipherText := make([]byte, len(plaintext))

        for start := 0; start &lt; len(plaintext); start += blockSize </span><span class="cov8" title="1">{
                block.Encrypt(cipherText[start:start+blockSize], plaintext[start:start+blockSize])
        }</span>

        <span class="cov8" title="1">return cipherText, nil</span>
}

// Decrypt decrypts cipherText using AES in ECB mode
func (Ecb) Decrypt(key, cipherText []byte) ([]byte, error) <span class="cov8" title="1">{
        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">blockSize := block.BlockSize()
        if len(cipherText)%blockSize != 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cipherText is not a multiple of the block size")
        }</span>

        <span class="cov8" title="1">plaintext := make([]byte, len(cipherText))

        for start := 0; start &lt; len(cipherText); start += blockSize </span><span class="cov8" title="1">{
                block.Decrypt(plaintext[start:start+blockSize], cipherText[start:start+blockSize])
        }</span>

        <span class="cov8" title="1">return Ecb{}.unPadPKCS72(plaintext, blockSize)</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">package setting

import (
        "github.com/fsnotify/fsnotify"
        "github.com/spf13/viper"
)

// ******************** 配置文件属性 ********************
type (
        SettingAttributes interface{ Register(setting *Setting) }

        AttrConfigFilename struct{ configFilename string }
        AttrEnvName        struct{ envName string }
        AttrConfig         struct{ content any }
        AttrOnChange       struct {
                onChange func(v *viper.Viper, e fsnotify.Event)
        }
)

func ConfigFilename(configFilename string) AttrConfigFilename <span class="cov0" title="0">{
        return AttrConfigFilename{configFilename}
}</span>
func (my AttrConfigFilename) Register(setting *Setting) <span class="cov0" title="0">{ setting.configFilename = my.configFilename }</span>

func EnvName(envName string) AttrEnvName         <span class="cov0" title="0">{ return AttrEnvName{envName} }</span>
func (my AttrEnvName) Register(setting *Setting) <span class="cov0" title="0">{ setting.envName = my.envName }</span>

func Content(content any) AttrConfig            <span class="cov0" title="0">{ return AttrConfig{content} }</span>
func (my AttrConfig) Register(setting *Setting) <span class="cov0" title="0">{ setting.config = my.content }</span>

func OnChange(onChange func(v *viper.Viper, e fsnotify.Event)) AttrOnChange <span class="cov0" title="0">{
        return AttrOnChange{onChange}
}</span>
func (my AttrOnChange) Register(setting *Setting) <span class="cov0" title="0">{ setting.onChange = my.onChange }</span>
</pre>
		
		<pre class="file" id="file80" style="display: none">package setting

import (
        "fmt"
        "log"
        "os"
        "path/filepath"

        "github.com/aid297/aid/str"
        "github.com/fsnotify/fsnotify"
        "github.com/spf13/viper"
)

// ******************** 配置文件 ********************
// Setting
type Setting struct {
        configFilename string
        envName        string
        config         any
        onChange       func(v *viper.Viper, e fsnotify.Event)
}

func (Setting) New(attrs ...SettingAttributes) (v *viper.Viper) <span class="cov0" title="0">{
        var (
                err        error
                configPath string
                configEnv  string
                ins        = Setting{}.SetAttrs(attrs...)
        )

        if configEnv = os.Getenv(ins.envName); configEnv != "" </span><span class="cov0" title="0">{
                configPath = configEnv
        }</span>

        <span class="cov0" title="0">if ins.configFilename != "" </span><span class="cov0" title="0">{
                configPath = ins.configFilename
        }</span>

        <span class="cov0" title="0">v = viper.New()
        v.SetConfigFile(configPath)
        v.SetConfigType(filepath.Ext(configPath)[1:])
        if err = v.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("读取配置文件失败: %s \n", err))</span>
        }
        <span class="cov0" title="0">v.WatchConfig()

        v.OnConfigChange(func(e fsnotify.Event) </span><span class="cov0" title="0">{
                if ins.onChange != nil </span><span class="cov0" title="0">{
                        ins.onChange(v, e)
                }</span> else<span class="cov0" title="0"> {
                        log.Println(str.APP.Buffer.JoinString("配置文件改变：", e.Name))
                        if err = v.Unmarshal(ins.config); err != nil </span><span class="cov0" title="0">{
                                log.Println(str.APP.Buffer.JoinString("更新配置文件失败：", err.Error()))
                        }</span>
                }
        })

        <span class="cov0" title="0">if err = v.Unmarshal(ins.config); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return</span>
}

func (my Setting) SetAttrs(attrs ...SettingAttributes) Setting <span class="cov0" title="0">{
        if len(attrs) == 0 </span><span class="cov0" title="0">{
                return my
        }</span>

        <span class="cov0" title="0">for _, attr := range attrs </span><span class="cov0" title="0">{
                attr.Register(&amp;my)
        }</span>

        <span class="cov0" title="0">return my</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">package sonarqube

import (
        "fmt"
        "net/http"
        "strings"
        "sync"

        "errors"

        "go.uber.org/zap"

        "github.com/aid297/aid/httpClient/httpClientV2"
        "github.com/aid297/aid/str"
)

type (
        ClientService struct {
                baseURL, token string
                hc             *httpClientV2.HTTPClient
                log            *zap.Logger
        }

        ClientServiceAttributer  interface{ Register() }
        AttrClientServiceBaseURL struct{ baseURL string }
        AttrClientServiceToken   struct{ token string }
)

var (
        once      sync.Once
        clientIns *ClientService
)

func ClientServiceBaseURL(baseURL string) AttrClientServiceBaseURL <span class="cov0" title="0">{
        return AttrClientServiceBaseURL{baseURL: baseURL}
}</span>
func (my AttrClientServiceBaseURL) Register() <span class="cov0" title="0">{
        clientIns.baseURL = my.baseURL
}</span>

func ClientServiceToken(token string) AttrClientServiceToken <span class="cov0" title="0">{
        return AttrClientServiceToken{token: token}
}</span>
func (my AttrClientServiceToken) Register() <span class="cov0" title="0">{
        clientIns.token = my.token
}</span>

func (ClientService) New(attrs ...ClientServiceAttributer) *ClientService <span class="cov0" title="0">{
        once.Do(func() </span><span class="cov0" title="0">{ clientIns = new(ClientService) }</span>)
        <span class="cov0" title="0">return clientIns.SetAttrs(attrs...)</span>
}

func (ClientService) SetAttrs(attrs ...ClientServiceAttributer) *ClientService <span class="cov0" title="0">{
        for idx := range attrs </span><span class="cov0" title="0">{
                attrs[idx].Register()
        }</span>

        <span class="cov0" title="0">return clientIns</span>
}

func (ClientService) newHC(url string, attrs ...httpClientV2.HTTPClientAttributer) *httpClientV2.HTTPClient <span class="cov0" title="0">{
        clientIns.hc = httpClientV2.APP.HTTPClient.New(
                httpClientV2.URL(clientIns.baseURL, url),
                httpClientV2.SetHeaderValue(map[string]any{"Authorization": str.APP.Buffer.JoinString("Bearer ", clientIns.token)}).Accept(httpClientV2.AcceptJSON),
                httpClientV2.AutoCopy(false),
        ).
                SetAttrs(attrs...)
        return clientIns.hc
}</span>

func (ClientService) Find(url string, page, pageSize int, attrs ...httpClientV2.HTTPClientAttributer) *httpClientV2.HTTPClient <span class="cov0" title="0">{
        return APP.Client.newHC(url, httpClientV2.Method(http.MethodGet), httpClientV2.Queries(map[string]any{"p": page, "ps": pageSize})).SetAttrs(attrs...)
}</span>

func (ClientService) First(url string, attrs ...httpClientV2.HTTPClientAttributer) *httpClientV2.HTTPClient <span class="cov0" title="0">{
        return APP.Client.newHC(url, httpClientV2.Method(http.MethodGet)).SetAttrs(attrs...)
}</span>

func (ClientService) POST(url string, attrs ...httpClientV2.HTTPClientAttributer) *httpClientV2.HTTPClient <span class="cov0" title="0">{
        return APP.Client.newHC(url, httpClientV2.Method(http.MethodPost)).SetAttrs(attrs...)
}</span>

func (ClientService) GET(url string, attrs ...httpClientV2.HTTPClientAttributer) *httpClientV2.HTTPClient <span class="cov0" title="0">{
        return APP.Client.newHC(url, httpClientV2.Method(http.MethodGet)).SetAttrs(attrs...)
}</span>

// ProcessHTTPWrong http请求错误处理
func (my ClientService) ProcessHTTPWrong(title string, hc *httpClientV2.HTTPClient) (err error) <span class="cov0" title="0">{

        var (
                statusCode       = hc.GetStatusCode()
                codeQualityWrong CodeQualityWrong
                wrongs           []string
        )

        if statusCode &gt; 399 </span><span class="cov0" title="0">{
                if err = hc.ToJSON(codeQualityWrong).Error(); err != nil </span><span class="cov0" title="0">{
                        my.log.Error(title, zap.String(fmt.Sprintf("状态码：%d", statusCode), fmt.Sprintf("响应体：%s", string(hc.GetBody()))), zap.Error(hc.Error()))
                }</span>

                <span class="cov0" title="0">if len(codeQualityWrong.Errors) &gt; 0 </span><span class="cov0" title="0">{
                        wrongs = make([]string, 0, len(codeQualityWrong.Errors))
                        for idx := range codeQualityWrong.Errors </span><span class="cov0" title="0">{
                                wrongs = append(wrongs, codeQualityWrong.Errors[idx].Msg)
                        }</span>
                }

                <span class="cov0" title="0">err = errors.New(strings.Join(wrongs, "；"))</span>
        }
        <span class="cov0" title="0">return</span>
}

func (ClientService) Next(title string, hc *httpClientV2.HTTPClient) (ret map[string]any, err error) <span class="cov0" title="0">{
        if err = APP.Client.ProcessHTTPWrong(title, hc); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if err = hc.ToJSON(&amp;ret).Error(); err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s失败：%w", title, err)
                return
        }</span>

        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">package steam

import (
        "bytes"
        "errors"
        "io"
)

type (
        Steam struct {
                Error      error
                readCloser io.ReadCloser
                copyFn     func(copied []byte) error
        }
)

// New 实例化：Steam
func (Steam) New(attrs ...Attributer) Steam <span class="cov0" title="0">{ return Steam{}.SetAttrs(attrs...) }</span>

// SetAttrs 设置属性
func (my Steam) SetAttrs(attrs ...Attributer) Steam <span class="cov0" title="0">{
        if len(attrs) &gt; 0 </span><span class="cov0" title="0">{
                for _, attr := range attrs </span><span class="cov0" title="0">{
                        attr.Register(&amp;my)
                }</span>
        }
        <span class="cov0" title="0">return my</span>
}

// Copy 复制流
func (my Steam) Copy() (io.ReadCloser, error) <span class="cov0" title="0">{
        var (
                err    error
                copied = make([]byte, 0)
        )

        if my.readCloser == nil </span><span class="cov0" title="0">{
                return nil, errors.New("空内容")
        }</span>

        <span class="cov0" title="0">if copied, err = io.ReadAll(my.readCloser); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(copied) &gt; 0 </span><span class="cov0" title="0">{
                if err = my.copyFn(copied); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return io.NopCloser(bytes.NewBuffer(copied)), err</span>
}
</pre>
		
		<pre class="file" id="file83" style="display: none">package steam

import "io"

type (
        Attributer interface {
                Register(steam *Steam)
        }

        AttrReadCloser struct{ readCloser io.ReadCloser }
        AttrCopyFn     struct{ fn func(copied []byte) error }
)

func ReadCloser(readCloser io.ReadCloser) AttrReadCloser <span class="cov0" title="0">{ return AttrReadCloser{readCloser} }</span>
func (my AttrReadCloser) Register(steam *Steam)          <span class="cov0" title="0">{ steam.readCloser = my.readCloser }</span>

func CopyFn(fn func(copied []byte) error) AttrCopyFn <span class="cov0" title="0">{ return AttrCopyFn{fn} }</span>
func (my AttrCopyFn) Register(steam *Steam)          <span class="cov0" title="0">{ steam.copyFn = my.fn }</span>
</pre>
		
		<pre class="file" id="file84" style="display: none">package str

import (
        "bytes"
        "net/url"
        "sync"
        "unicode/utf8"

        "github.com/aid297/aid/digest"
        "github.com/spf13/cast"
)

type Buffer struct {
        original *bytes.Buffer
        lock     *sync.RWMutex
}

func totalLenStrings(ss []string) int <span class="cov8" title="1">{
        total := 0
        for _, s := range ss </span><span class="cov8" title="1">{
                total += len(s)
        }</span>
        <span class="cov8" title="1">return total</span>
}

func totalLenAny(values []any) int <span class="cov0" title="0">{
        total := 0
        for _, v := range values </span><span class="cov0" title="0">{
                total += len(cast.ToString(v))
        }</span>
        <span class="cov0" title="0">return total</span>
}

func totalLenRunes(rs []rune) int <span class="cov0" title="0">{
        total := 0
        for _, r := range rs </span><span class="cov0" title="0">{
                total += utf8.RuneLen(r)
        }</span>
        <span class="cov0" title="0">return total</span>
}

func (Buffer) JoinString(strings ...string) string <span class="cov0" title="0">{
        switch len(strings) </span>{
        case 0:<span class="cov0" title="0">
                return ""</span>
        case 1:<span class="cov0" title="0">
                return strings[0]</span>
        default:<span class="cov0" title="0">
                return APP.Buffer.NewString(strings[0]).S(strings[1:]...).String()</span>
        }
}

func (Buffer) JoinStringLimit(limit string, strings ...string) string <span class="cov0" title="0">{
        switch len(strings) </span>{
        case 0:<span class="cov0" title="0">
                return ""</span>
        case 1:<span class="cov0" title="0">
                return strings[0]</span>
        default:<span class="cov0" title="0">
                buf := APP.Buffer.NewString(strings[0])
                remainingTotal := 0
                for _, s := range strings[1:] </span><span class="cov0" title="0">{
                        remainingTotal += len(limit) + len(s)
                }</span>
                <span class="cov0" title="0">buf.original.Grow(remainingTotal)
                for idx := range strings[1:] </span><span class="cov0" title="0">{
                        buf.S(limit).S(strings[idx+1])
                }</span>
                <span class="cov0" title="0">return buf.String()</span>
        }
}

func (Buffer) JoinAny(values ...any) string <span class="cov0" title="0">{
        switch len(values) </span>{
        case 0:<span class="cov0" title="0">
                return ""</span>
        case 1:<span class="cov0" title="0">
                return cast.ToString(values[0])</span>
        default:<span class="cov0" title="0">
                buf := APP.Buffer.NewAny(values[0])
                buf.original.Grow(totalLenAny(values))
                for idx := range values[1:] </span><span class="cov0" title="0">{
                        buf.Any(values[idx+1])
                }</span>
                <span class="cov0" title="0">return buf.String()</span>
        }
}

func (Buffer) JoinAnyLimit(limit string, values ...any) string <span class="cov0" title="0">{
        switch len(values) </span>{
        case 0:<span class="cov0" title="0">
                return ""</span>
        case 1:<span class="cov0" title="0">
                return cast.ToString(values[0])</span>
        default:<span class="cov0" title="0">
                buf := APP.Buffer.NewAny(values[0])
                extra := len(limit) * (len(values) - 1)
                buf.original.Grow(totalLenAny(values) + extra)
                for idx := range values[1:] </span><span class="cov0" title="0">{
                        buf.S(limit).Any(values[idx+1])
                }</span>
                <span class="cov0" title="0">return buf.String()</span>
        }
}

// NewString 实例化：通过字符串
func (Buffer) NewString(data ...string) Buffer <span class="cov8" title="1">{
        switch len(data) </span>{
        case 0:<span class="cov0" title="0">
                return Buffer{original: bytes.NewBufferString(""), lock: &amp;sync.RWMutex{}}</span>
        case 1:<span class="cov8" title="1">
                return Buffer{original: bytes.NewBufferString(data[0]), lock: &amp;sync.RWMutex{}}</span>
        default:<span class="cov0" title="0">
                buf := Buffer{original: bytes.NewBufferString(data[0]), lock: &amp;sync.RWMutex{}}
                buf.original.Grow(totalLenStrings(data[1:]))
                for idx := range data[1:] </span><span class="cov0" title="0">{
                        buf.original.WriteString(data[idx+1])
                }</span>
                <span class="cov0" title="0">return buf</span>
        }
}

// NewBytes 实例化：通过字节码
func (Buffer) NewBytes(original []byte) Buffer <span class="cov0" title="0">{
        return Buffer{original: bytes.NewBuffer(original), lock: &amp;sync.RWMutex{}}
}</span>

// NewRune 实例化：通过字符
func (Buffer) NewRune(data ...rune) Buffer <span class="cov0" title="0">{
        switch len(data) </span>{
        case 0:<span class="cov0" title="0">
                return Buffer{original: bytes.NewBufferString(""), lock: &amp;sync.RWMutex{}}</span>
        case 1:<span class="cov0" title="0">
                return Buffer{original: bytes.NewBufferString(string(data[0])), lock: &amp;sync.RWMutex{}}</span>
        default:<span class="cov0" title="0">
                buf := Buffer{original: bytes.NewBufferString(string(data)), lock: &amp;sync.RWMutex{}}
                buf.original.Grow(totalLenRunes(data[1:]))
                for idx := range data[1:] </span><span class="cov0" title="0">{
                        buf.original.WriteRune(data[idx+1])
                }</span>
                <span class="cov0" title="0">return buf</span>
        }
}

func (Buffer) NewAny(data ...any) Buffer <span class="cov0" title="0">{
        switch len(data) </span>{
        case 0:<span class="cov0" title="0">
                return Buffer{original: bytes.NewBufferString(""), lock: &amp;sync.RWMutex{}}</span>
        case 1:<span class="cov0" title="0">
                return Buffer{original: bytes.NewBufferString(cast.ToString(data[0])), lock: &amp;sync.RWMutex{}}</span>
        default:<span class="cov0" title="0">
                buf := Buffer{original: bytes.NewBufferString(cast.ToString(data[0])), lock: &amp;sync.RWMutex{}}
                buf.original.Grow(totalLenAny(data[1:]))
                for idx := range data[1:] </span><span class="cov0" title="0">{
                        buf.original.WriteString(cast.ToString(data[idx+1]))
                }</span>
                <span class="cov0" title="0">return buf</span>
        }
}

// Any 追加任意内容到字符串
func (my Buffer) Any(values ...any) Buffer <span class="cov0" title="0">{
        for _, value := range values </span><span class="cov0" title="0">{
                my.original.Grow(totalLenAny(values))
                my.original.WriteString(cast.ToString(value))
        }</span>

        <span class="cov0" title="0">return my</span>
}

// URLPath 字符串 -&gt; 追加写入 URL 路径
func (my Buffer) URLPath(values ...string) Buffer <span class="cov0" title="0">{
        total := 0
        escs := make([]string, 0, len(values))
        for _, v := range values </span><span class="cov0" title="0">{
                e := url.PathEscape(v)
                escs = append(escs, e)
                total += len(e)
        }</span>
        <span class="cov0" title="0">my.original.Grow(total)
        // 然后使用 escs 而不是重复调用 PathEscape
        for _, e := range escs </span><span class="cov0" title="0">{
                my.original.WriteString(e)
        }</span>

        <span class="cov0" title="0">return my</span>
}

// URLQuery 字符串 -&gt; 追加写入 URL 查询
func (my Buffer) URLQuery(values ...string) Buffer <span class="cov0" title="0">{
        total := 0
        escs := make([]string, 0, len(values))
        for _, v := range values </span><span class="cov0" title="0">{
                e := url.PathEscape(v)
                escs = append(escs, e)
                total += len(e)
        }</span>
        <span class="cov0" title="0">my.original.Grow(total)
        // 然后使用 escs 而不是重复调用 PathEscape
        for _, e := range escs </span><span class="cov0" title="0">{
                my.original.WriteString(e)
        }</span>

        <span class="cov0" title="0">return my</span>
}

func (my Buffer) s(values ...string) Buffer <span class="cov8" title="1">{
        for _, value := range values </span><span class="cov8" title="1">{
                my.original.Grow(totalLenStrings(values))
                my.original.WriteString(value)
        }</span>

        <span class="cov8" title="1">return my</span>
}

// S 追加写入字符串
func (my Buffer) S(values ...string) Buffer <span class="cov8" title="1">{
        my.lock.Lock()
        defer my.lock.Unlock()
        return my.s(values...)
}</span>

func (my Buffer) b(values ...byte) Buffer <span class="cov0" title="0">{
        for _, b := range values </span><span class="cov0" title="0">{
                my.original.Grow(len(values) - 1)
                my.original.WriteByte(b)
        }</span>

        <span class="cov0" title="0">return my</span>
}

// B 追加写入字节
func (my Buffer) B(values ...byte) Buffer <span class="cov0" title="0">{
        my.lock.Lock()
        defer my.lock.Unlock()
        return my.b(values...)
}</span>

func (my Buffer) r(values ...rune) Buffer <span class="cov0" title="0">{
        for _, v := range values </span><span class="cov0" title="0">{
                my.original.Grow(totalLenRunes(values))
                my.original.WriteRune(v)
        }</span>

        <span class="cov0" title="0">return my</span>
}

// R 追加写入字符
func (my Buffer) R(values ...rune) Buffer <span class="cov0" title="0">{
        my.lock.Lock()
        defer my.lock.Unlock()
        return my.r(values...)
}</span>

// String 获取字符串
func (my Buffer) String() string <span class="cov8" title="1">{
        my.lock.RLock()
        defer my.lock.RUnlock()
        defer my.original.Reset()
        return my.original.String()
}</span>

// Bytes 获取字节码
func (my Buffer) Bytes() []byte <span class="cov0" title="0">{
        my.lock.RLock()
        defer my.lock.RUnlock()
        defer my.original.Reset()
        return my.original.Bytes()
}</span>

// Ptr 获取字符串指针
func (my Buffer) Ptr() *string <span class="cov0" title="0">{
        my.lock.RLock()
        defer my.lock.RUnlock()
        defer my.original.Reset()
        ret := my.original.String()
        return &amp;ret
}</span>

func (my Buffer) Sha256Sum256() string <span class="cov0" title="0">{
        my.lock.RLock()
        defer my.lock.RUnlock()
        defer my.original.Reset()
        return digest.Sha256Sum256(my.original.Bytes())
}</span>

// Copy 复制当前对象
func (my Buffer) Copy() Buffer <span class="cov0" title="0">{
        my.lock.RLock()
        defer my.lock.RUnlock()
        return Buffer{original: bytes.NewBuffer(my.original.Bytes()), lock: &amp;sync.RWMutex{}}
}</span>
</pre>
		
		<pre class="file" id="file85" style="display: none">package str

type (
        HtmlAttributer interface{ Register(html *HTML) }

        AttrHtmlNormal struct{ content string }
        AttrHtmlA      struct {
                name, href string
                properties []HtmlProperty
        }
        AttrHtmlP   struct{ content string }
        AttrHtmlBr  struct{ content string }
        AttrHtmlUl  struct{ contents []string }
        AttrHtmlAny struct {
                tag, content string
                properties   []HtmlProperty
        }
        AttrHtmlTable struct {
                properties []HtmlProperty
                options    []HtmlAttributer
        }
        AttrHtmlTr struct {
                properties []HtmlProperty
                options    []HtmlAttributer
        }
        AttrHtmlTd struct {
                properties []HtmlProperty
                content    string
        }
        AttrHtmlTh struct {
                properties []HtmlProperty
                content    string
        }
        AttrHtmlTHead struct {
                properties []HtmlProperty
                options    []HtmlAttributer
        }
        AttrHtmlTBody struct {
                properties []HtmlProperty
                options    []HtmlAttributer
        }

        HtmlProperty struct {
                Key   string
                Value string
        }
)

func HtmlNormal(content string) AttrHtmlNormal <span class="cov8" title="1">{
        return AttrHtmlNormal{content: content}
}</span>

func (my AttrHtmlNormal) Register(html *HTML) <span class="cov8" title="1">{
        html.buffer.S(my.content)
}</span>

func HtmlA(name, href string, properties ...HtmlProperty) AttrHtmlA <span class="cov8" title="1">{
        return AttrHtmlA{name: name, href: href, properties: properties}
}</span>

func (my AttrHtmlA) Register(html *HTML) <span class="cov8" title="1">{
        html.buffer.S(`&lt;a href="`, my.href, `"`)
        if len(my.properties) &gt; 0 </span><span class="cov8" title="1">{
                for idx := range my.properties </span><span class="cov8" title="1">{
                        html.buffer.S(" ", my.properties[idx].Key, `="`, my.properties[idx].Value, `"`)
                }</span>
        }
        <span class="cov8" title="1">html.buffer.S("&gt;", my.name, "&lt;/a&gt;")</span>
}

func HtmlP(content string) AttrHtmlP <span class="cov8" title="1">{
        return AttrHtmlP{content: content}
}</span>

func (my AttrHtmlP) Register(html *HTML) <span class="cov8" title="1">{
        html.buffer.S("&lt;p&gt;").S(my.content).S("&lt;/p&gt;")
}</span>

func HtmlBr() AttrHtmlBr <span class="cov8" title="1">{
        return AttrHtmlBr{content: "&lt;br /&gt;"}
}</span>

func (my AttrHtmlBr) Register(html *HTML) <span class="cov8" title="1">{
        html.buffer.S(my.content)
}</span>

func HtmlUl(contents ...string) AttrHtmlUl <span class="cov8" title="1">{
        return AttrHtmlUl{contents: contents}
}</span>

func (my AttrHtmlUl) Register(html *HTML) <span class="cov8" title="1">{
        if len(my.contents) &gt; 0 </span><span class="cov8" title="1">{
                html.buffer.S("&lt;ul&gt;")
                for idx := range my.contents </span><span class="cov8" title="1">{
                        html.buffer.S("&lt;li&gt;", my.contents[idx], "&lt;/li&gt;")
                }</span>
                <span class="cov8" title="1">html.buffer.S("&lt;/ul&gt;")</span>
        }
}

func HtmlAny(tag, content string) AttrHtmlAny <span class="cov0" title="0">{
        return AttrHtmlAny{tag: tag, content: content, properties: []HtmlProperty{}}
}</span>

func (my AttrHtmlAny) Register(html *HTML) <span class="cov0" title="0">{
        html.buffer.S("&lt;", my.tag)
        if len(my.properties) &gt; 0 </span><span class="cov0" title="0">{
                for idx := range my.properties </span><span class="cov0" title="0">{
                        html.buffer.S(" ", my.properties[idx].Key, `="`, my.properties[idx].Value, `"`)
                }</span>
        }
        <span class="cov0" title="0">if my.content == "" </span><span class="cov0" title="0">{
                html.buffer.S(" /&gt;")
        }</span> else<span class="cov0" title="0"> {
                html.buffer.S("&gt;", my.content, "&lt;/", my.tag, "&gt;")
        }</span>
}

func (my AttrHtmlAny) AppendProperties(properties ...HtmlProperty) AttrHtmlAny <span class="cov0" title="0">{
        my.properties = append(my.properties, properties...)
        return my
}</span>

func HtmlTable(options ...HtmlAttributer) AttrHtmlTable <span class="cov8" title="1">{
        return AttrHtmlTable{options: options, properties: []HtmlProperty{}}
}</span>

func (my AttrHtmlTable) Register(html *HTML) <span class="cov8" title="1">{
        html.buffer.S("&lt;table")
        if len(my.properties) &gt; 0 </span><span class="cov8" title="1">{
                for idx := range my.properties </span><span class="cov8" title="1">{
                        html.buffer.S(" ", my.properties[idx].Key, `="`, my.properties[idx].Value, `"`)
                }</span>
        }
        <span class="cov8" title="1">html.buffer.S("&gt;")
        if len(my.options) &gt; 0 </span><span class="cov8" title="1">{
                for idx := range my.options </span><span class="cov8" title="1">{
                        my.options[idx].Register(html)
                }</span>
        }
        <span class="cov8" title="1">html.buffer.S("&lt;/table&gt;")</span>
}

func (my AttrHtmlTable) AppendProperties(properties ...HtmlProperty) AttrHtmlTable <span class="cov8" title="1">{
        my.properties = append(my.properties, properties...)
        return my
}</span>

func HtmlTr(options ...HtmlAttributer) AttrHtmlTr <span class="cov8" title="1">{
        return AttrHtmlTr{options: options, properties: []HtmlProperty{}}
}</span>

func (my AttrHtmlTr) Register(html *HTML) <span class="cov8" title="1">{
        html.buffer.S("&lt;tr")
        if len(my.properties) &gt; 0 </span><span class="cov0" title="0">{
                for idx := range my.properties </span><span class="cov0" title="0">{
                        html.buffer.S(" ", my.properties[idx].Key, `="`, my.properties[idx].Value, `"`)
                }</span>
        }
        <span class="cov8" title="1">html.buffer.S("&gt;")
        if len(my.options) &gt; 0 </span><span class="cov8" title="1">{
                for idx := range my.options </span><span class="cov8" title="1">{
                        my.options[idx].Register(html)
                }</span>
        }
        <span class="cov8" title="1">html.buffer.S("&lt;/tr&gt;")</span>
}

func (my AttrHtmlTr) AppendProperties(properties ...HtmlProperty) AttrHtmlTr <span class="cov0" title="0">{
        my.properties = append(my.properties, properties...)
        return my
}</span>

func HtmlTd(content string) AttrHtmlTd <span class="cov8" title="1">{
        return AttrHtmlTd{content: content, properties: []HtmlProperty{}}
}</span>

func (my AttrHtmlTd) Register(html *HTML) <span class="cov8" title="1">{
        html.buffer.S("&lt;td")
        if len(my.properties) &gt; 0 </span><span class="cov8" title="1">{
                for idx := range my.properties </span><span class="cov8" title="1">{
                        html.buffer.S(" ", my.properties[idx].Key, `="`, my.properties[idx].Value, `"`)
                }</span>
        }
        <span class="cov8" title="1">html.buffer.S("&gt;", my.content, "&lt;/td&gt;")</span>
}

func (my AttrHtmlTd) AppendProperties(properties ...HtmlProperty) AttrHtmlTd <span class="cov8" title="1">{
        my.properties = append(my.properties, properties...)
        return my
}</span>

func HtmlTh(content string) AttrHtmlTh <span class="cov8" title="1">{
        return AttrHtmlTh{content: content, properties: []HtmlProperty{}}
}</span>

func (my AttrHtmlTh) Register(html *HTML) <span class="cov8" title="1">{
        html.buffer.S("&lt;th")
        if len(my.properties) &gt; 0 </span><span class="cov8" title="1">{
                for idx := range my.properties </span><span class="cov8" title="1">{
                        html.buffer.S(" ", my.properties[idx].Key, `="`, my.properties[idx].Value, `"`)
                }</span>
        }
        <span class="cov8" title="1">html.buffer.S("&gt;", my.content, "&lt;/th&gt;")</span>
}

func (my AttrHtmlTh) AppendProperties(properties ...HtmlProperty) AttrHtmlTh <span class="cov8" title="1">{
        my.properties = append(my.properties, properties...)
        return my
}</span>

func HtmlTHead(options ...HtmlAttributer) AttrHtmlTHead <span class="cov8" title="1">{
        return AttrHtmlTHead{options: options, properties: []HtmlProperty{}}
}</span>

func (my AttrHtmlTHead) Register(html *HTML) <span class="cov8" title="1">{
        html.buffer.S("&lt;thead")
        if len(my.properties) &gt; 0 </span><span class="cov8" title="1">{
                for idx := range my.properties </span><span class="cov8" title="1">{
                        html.buffer.S(" ", my.properties[idx].Key, `="`, my.properties[idx].Value, `"`)
                }</span>
        }
        <span class="cov8" title="1">html.buffer.S("&gt;")
        if len(my.options) &gt; 0 </span><span class="cov8" title="1">{
                for idx := range my.options </span><span class="cov8" title="1">{
                        my.options[idx].Register(html)
                }</span>
        }
        <span class="cov8" title="1">html.buffer.S("&lt;/thead&gt;")</span>
}

func (my AttrHtmlTHead) AppendProperties(properties ...HtmlProperty) AttrHtmlTHead <span class="cov8" title="1">{
        my.properties = append(my.properties, properties...)
        return my
}</span>

func HtmlTBody(options ...HtmlAttributer) AttrHtmlTBody <span class="cov8" title="1">{
        return AttrHtmlTBody{options: options, properties: []HtmlProperty{}}
}</span>

func (my AttrHtmlTBody) Register(html *HTML) <span class="cov8" title="1">{
        html.buffer.S("&lt;tbody")
        if len(my.properties) &gt; 0 </span><span class="cov8" title="1">{
                for idx := range my.properties </span><span class="cov8" title="1">{
                        html.buffer.S(" ", my.properties[idx].Key, `="`, my.properties[idx].Value, `"`)
                }</span>
        }
        <span class="cov8" title="1">html.buffer.S("&gt;")
        if len(my.options) &gt; 0 </span><span class="cov8" title="1">{
                for idx := range my.options </span><span class="cov8" title="1">{
                        my.options[idx].Register(html)
                }</span>
        }
        <span class="cov8" title="1">html.buffer.S("&lt;/tbody&gt;")</span>
}

func (my AttrHtmlTBody) AppendProperties(properties ...HtmlProperty) AttrHtmlTBody <span class="cov8" title="1">{
        my.properties = append(my.properties, properties...)
        return my
}</span>
</pre>
		
		<pre class="file" id="file86" style="display: none">package str

type HTML struct{ buffer Buffer }

func (HTML) New(options ...HtmlAttributer) HTML <span class="cov8" title="1">{
        return HTML{buffer: APP.Buffer.NewString("")}.Set(options...)
}</span>

func (HTML) NewString(options ...HtmlAttributer) string <span class="cov8" title="1">{
        return APP.HTML.New(options...).End()
}</span>

func (my HTML) Set(options ...HtmlAttributer) HTML <span class="cov8" title="1">{
        if len(options) &gt; 0 </span><span class="cov8" title="1">{
                for _, option := range options </span><span class="cov8" title="1">{
                        option.Register(&amp;my)
                }</span>
        }
        <span class="cov8" title="1">return my</span>
}

func (my HTML) End() string <span class="cov8" title="1">{
        return my.buffer.String()
}</span>
</pre>
		
		<pre class="file" id="file87" style="display: none">package str

import "github.com/spf13/cast"

type (
        MarkdownAttributer interface {
                Register(markdown *Markdown)
        }

        AttrMarkdownNormal struct{ content string }
        AttrMarkdownA      struct{ name, href string }
        AttrMarkdownBr     struct{}
        AttrMarkdownUl     struct{ contents []string }
        AttrMarkdownOl     struct{ contents []string }
)

func MarkdownNormal(content string) AttrMarkdownNormal <span class="cov8" title="1">{
        return AttrMarkdownNormal{content: content}
}</span>

func (my AttrMarkdownNormal) Register(markdown *Markdown) <span class="cov8" title="1">{
        markdown.buffer.S(my.content, "\n")
}</span>

func MarkdownA(name, href string) AttrMarkdownA <span class="cov8" title="1">{
        return AttrMarkdownA{name: name, href: href}
}</span>

func (my AttrMarkdownA) Register(markdown *Markdown) <span class="cov8" title="1">{
        markdown.buffer.S("[", my.name, "]", "(", my.href, ")\n")
}</span>

func MarkdownBr() AttrMarkdownBr <span class="cov8" title="1">{ return AttrMarkdownBr{} }</span>

func (AttrMarkdownBr) Register(markdown *Markdown) <span class="cov8" title="1">{
        markdown.buffer.S("\n\n")
}</span>

func MarkdownUl(contents ...string) AttrMarkdownUl <span class="cov8" title="1">{
        return AttrMarkdownUl{contents: contents}
}</span>

func (my AttrMarkdownUl) Register(markdown *Markdown) <span class="cov8" title="1">{
        if len(my.contents) &gt; 0 </span><span class="cov8" title="1">{
                for idx := range my.contents </span><span class="cov8" title="1">{
                        markdown.buffer.S("* ", my.contents[idx], "\n")
                }</span>
        }
}

func (my AttrMarkdownUl) Append(contents ...string) AttrMarkdownUl <span class="cov0" title="0">{
        my.contents = append(my.contents, contents...)
        return my
}</span>

func MarkdownOl(contents ...string) AttrMarkdownOl <span class="cov0" title="0">{ return AttrMarkdownOl{contents: contents} }</span>

func (my AttrMarkdownOl) Register(markdown *Markdown) <span class="cov0" title="0">{
        if len(my.contents) &gt; 0 </span><span class="cov0" title="0">{
                for idx := range my.contents </span><span class="cov0" title="0">{
                        markdown.buffer.S(cast.ToString(idx+1), ". ", my.contents[idx], "\n")
                }</span>
        }
}

func (my AttrMarkdownOl) Append(contents ...string) AttrMarkdownOl <span class="cov0" title="0">{
        my.contents = append(my.contents, contents...)
        return my
}</span>
</pre>
		
		<pre class="file" id="file88" style="display: none">package str

type Markdown struct{ buffer Buffer }

func (Markdown) New(options ...MarkdownAttributer) Markdown <span class="cov8" title="1">{
        return Markdown{buffer: APP.Buffer.NewString("")}.Set(options...)
}</span>

func (Markdown) NewString(options ...MarkdownAttributer) string <span class="cov0" title="0">{
        return APP.Markdown.New(options...).End()
}</span>

func (my Markdown) Set(options ...MarkdownAttributer) Markdown <span class="cov8" title="1">{
        if len(options) &gt; 0 </span><span class="cov8" title="1">{
                for idx := range options </span><span class="cov8" title="1">{
                        options[idx].Register(&amp;my)
                }</span>
        }
        <span class="cov8" title="1">return my</span>
}

func (my Markdown) End() string <span class="cov8" title="1">{
        return my.buffer.String()
}</span>
</pre>
		
		<pre class="file" id="file89" style="display: none">package str

import (
        "crypto/rand"
        "encoding/binary"
        "time"
)

type Rand struct {
        // bufferChan is the buffer for random bytes,
        // every item storing 4 bytes.
        bufferChan chan []byte
}

var (
        Letters      = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" // 52
        UpperLetters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"                           // 26
        LowerLetters = "abcdefghijklmnopqrstuvwxyz"                           // 26
        Symbols      = "!\"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~"                   // 32
        Digits       = "0123456789"                                           // 10
        characters   = Letters + Digits + Symbols                             // 94
        RandApp      Rand
)

var ()

// Buffer size for uint32 random number.
const bufferChanSize = 10000

func (*Rand) New() *Rand <span class="cov0" title="0">{
        ins := &amp;Rand{}
        ins.bufferChan = make(chan []byte, bufferChanSize)

        go ins.asyncProducingRandomBufferBytesLoop()

        return ins
}</span>

// NewRand 实例化：随机字符串
//
//go:fix 推荐使用：New方法
func NewRand() *Rand <span class="cov0" title="0">{
        ins := &amp;Rand{}
        ins.bufferChan = make(chan []byte, bufferChanSize)

        go ins.asyncProducingRandomBufferBytesLoop()

        return ins
}</span>

// asyncProducingRandomBufferBytes is a named goroutine, which uses an asynchronous goroutine
// to produce the random bytes, and a buffer chan to store the random bytes.
// So it has high performance to generate random numbers.
func (my *Rand) asyncProducingRandomBufferBytesLoop() <span class="cov0" title="0">{
        var step int
        for </span><span class="cov0" title="0">{
                buffer := make([]byte, 1024)
                if n, err := rand.Read(buffer); err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                } else<span class="cov0" title="0"> {
                        // The random buffer from system is very expensive,
                        // so fully reuse the random buffer by changing
                        // the step with a different number can
                        // improve the performance a lot.
                        // for _, step = range []int{4, 5, 6, 7} {
                        for _, step = range []int{4} </span><span class="cov0" title="0">{
                                for i := 0; i &lt;= n-4; i += step </span><span class="cov0" title="0">{
                                        my.bufferChan &lt;- buffer[i : i+4]
                                }</span>
                        }
                }
        }
}

func (my *Rand) Intn(max int) int <span class="cov0" title="0">{
        if max &lt;= 0 </span><span class="cov0" title="0">{
                return max
        }</span>
        <span class="cov0" title="0">n := int(binary.LittleEndian.Uint32(&lt;-my.bufferChan)) % max
        if (max &gt; 0 &amp;&amp; n &lt; 0) || (max &lt; 0 &amp;&amp; n &gt; 0) </span><span class="cov0" title="0">{
                return -n
        }</span>

        <span class="cov0" title="0">return n</span>
}

// B retrieves and returns random bytes of given length `n`.
func (my *Rand) B(n int) []byte <span class="cov0" title="0">{
        if n &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">i := 0
        b := make([]byte, n)
        for </span><span class="cov0" title="0">{
                copy(b[i:], &lt;-my.bufferChan)
                i += 4
                if i &gt;= n </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">return b</span>
}

// N returns a random int between min and max: [min, max].
// The `min` and `max` also support negative numbers.
func (my *Rand) N(min, max int) int <span class="cov0" title="0">{
        if min &gt;= max </span><span class="cov0" title="0">{
                return min
        }</span>
        <span class="cov0" title="0">if min &gt;= 0 </span><span class="cov0" title="0">{
                return my.Intn(max-min+1) + min
        }</span>
        // As `Intn` dose not support negative number,
        // so we should first shift the value to right,
        // then call `Intn` to produce the random number,
        // and finally shift the result back to left.
        <span class="cov0" title="0">return my.Intn(max+(0-min)+1) - (0 - min)</span>
}

// S returns a random str which contains digits and letters, and its length is `n`.
// The optional parameter `symbols` specifies whether the result could contain symbols,
// which is false in default.
func (my *Rand) S(n int, symbols ...bool) string <span class="cov0" title="0">{
        if n &lt;= 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">var (
                b           = make([]byte, n)
                numberBytes = my.B(n)
        )
        for i := range b </span><span class="cov0" title="0">{
                if len(symbols) &gt; 0 &amp;&amp; symbols[0] </span><span class="cov0" title="0">{
                        b[i] = characters[numberBytes[i]%94]
                }</span> else<span class="cov0" title="0"> {
                        b[i] = characters[numberBytes[i]%62]
                }</span>
        }

        <span class="cov0" title="0">return string(b)</span>
}

// D returns a random time.Duration between min and max: [min, max].
func (my *Rand) D(min, max time.Duration) time.Duration <span class="cov0" title="0">{
        multiple := int64(1)
        if min != 0 </span><span class="cov0" title="0">{
                for min%10 == 0 </span><span class="cov0" title="0">{
                        multiple *= 10
                        min /= 10
                        max /= 10
                }</span>
        }
        <span class="cov0" title="0">n := int64(my.N(int(min), int(max)))

        return time.Duration(n * multiple)</span>
}

// GetString randomly picks and returns `n` count of chars from given str `s`.
// It also supports unicode str like Chinese/Russian/Japanese, etc.
func (my *Rand) GetString(s string, n int) string <span class="cov0" title="0">{
        if n &lt;= 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">var (
                b     = make([]rune, n)
                runes = []rune(s)
        )
        if len(runes) &lt;= 255 </span><span class="cov0" title="0">{
                numberBytes := my.B(n)
                for i := range b </span><span class="cov0" title="0">{
                        b[i] = runes[int(numberBytes[i])%len(runes)]
                }</span>
        } else<span class="cov0" title="0"> {
                for i := range b </span><span class="cov0" title="0">{
                        b[i] = runes[my.Intn(len(runes))]
                }</span>
        }

        <span class="cov0" title="0">return string(b)</span>
}

// GetDigits returns a random str which contains only digits, and its length is `n`.
func (my *Rand) GetDigits(n int) string <span class="cov0" title="0">{
        if n &lt;= 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">var (
                b           = make([]byte, n)
                numberBytes = my.B(n)
        )
        for i := range b </span><span class="cov0" title="0">{
                b[i] = Digits[numberBytes[i]%10]
        }</span>
        <span class="cov0" title="0">return string(b)</span>
}

// GetLetters returns a random str which contains only letters, and its length is `n`.
func (my *Rand) GetLetters(n int) string <span class="cov0" title="0">{
        if n &lt;= 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">var (
                b           = make([]byte, n)
                numberBytes = my.B(n)
        )
        for i := range b </span><span class="cov0" title="0">{
                b[i] = Letters[numberBytes[i]%52]
        }</span>

        <span class="cov0" title="0">return string(b)</span>
}

// GetSymbols returns a random str which contains only symbols, and its length is `n`.
func (my *Rand) GetSymbols(n int) string <span class="cov0" title="0">{
        if n &lt;= 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">var (
                b           = make([]byte, n)
                numberBytes = my.B(n)
        )
        for i := range b </span><span class="cov0" title="0">{
                b[i] = Symbols[numberBytes[i]%32]
        }</span>

        <span class="cov0" title="0">return string(b)</span>
}

// Perm returns, as a slice of n int numbers, a pseudo-random permutation of the integers [0,n).
// TODO performance improving for large slice producing.
func (my *Rand) Perm(n int) []int <span class="cov0" title="0">{
        m := make([]int, n)
        for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                j := my.Intn(i + 1)
                m[i] = m[j]
                m[j] = i
        }</span>

        <span class="cov0" title="0">return m</span>
}

// Meet randomly calculate whether the given probability `num`/`total` is met.
func (my *Rand) Meet(num, total int) bool <span class="cov0" title="0">{ return my.Intn(total) &lt; num }</span>

// MeetProb randomly calculate whether the given probability is met.
func (my *Rand) MeetProb(prob float32) bool <span class="cov0" title="0">{ return my.Intn(1e7) &lt; int(prob*1e7) }</span>
</pre>
		
		<pre class="file" id="file90" style="display: none">package str

import (
        "regexp"
        "slices"
)

type (
        Regexp struct {
                original string
                target   string
                targets  []string
                re       regexp.Regexp
        }
)

var (
        RegexpApp Regexp
)

func (Regexp) New(original string, attrs ...RegexpRegexpAttributer) Regexp <span class="cov8" title="1">{
        ins := Regexp{original: original, re: *regexp.MustCompile(original)}
        return ins.Set(attrs...)
}</span>

func (my Regexp) Set(attrs ...RegexpRegexpAttributer) Regexp <span class="cov8" title="1">{
        if len(attrs) &gt; 0 </span><span class="cov8" title="1">{
                for idx := range attrs </span><span class="cov8" title="1">{
                        attrs[idx].Register(&amp;my)
                }</span>
        }

        <span class="cov8" title="1">return my</span>
}

// MatchFirst 查找第一个匹配项
func (my Regexp) MatchFirst() string <span class="cov0" title="0">{
        matched := my.re.FindStringSubmatch(my.target)
        if len(matched) &gt; 1 </span><span class="cov0" title="0">{
                return matched[1]
        }</span>

        <span class="cov0" title="0">return ""</span>
}

// MatchAll 查找所有匹配项
func (my Regexp) MatchAll() []string <span class="cov0" title="0">{
        matched := my.re.FindStringSubmatch(my.target)
        if len(matched) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if len(matched) &gt; 1 </span><span class="cov0" title="0">{
                ret := make([]string, 0, len(matched)-1)
                ret = append(ret, matched[1:]...)
                return ret
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Contains 是否包含匹配项
func (my Regexp) Contains() bool <span class="cov0" title="0">{ return my.re.MatchString(my.target) }</span>

// ContainsAll 是否包含任意一个匹配项
func (my Regexp) ContainsAll() bool <span class="cov0" title="0">{
        if len(my.targets) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return slices.ContainsFunc(my.targets, my.re.MatchString)</span>
}

// ReplaceAllString 替换所有匹配项
func (my Regexp) ReplaceAllString(replace string) string <span class="cov8" title="1">{
        return my.re.ReplaceAllString(my.target, replace)
}</span>
</pre>
		
		<pre class="file" id="file91" style="display: none">package str

type (
        RegexpRegexpAttributer interface{ Register(regexp *Regexp) }

        AttrRegexpTargetString  struct{ target string }
        AttrRegexpTargetsString struct{ targets []string }
        AttrRegexpTargetError   struct{ target error }
        AttrRegexpTargetsError  struct{ targets []error }
)

func RegexpTargetString(target string) AttrRegexpTargetString <span class="cov8" title="1">{
        return AttrRegexpTargetString{target: target}
}</span>
func (my AttrRegexpTargetString) Register(regexp *Regexp) <span class="cov8" title="1">{ regexp.target = my.target }</span>

func RegexpTargetsString(targets ...string) AttrRegexpTargetsString <span class="cov0" title="0">{
        return AttrRegexpTargetsString{targets: targets}
}</span>
func (my AttrRegexpTargetsString) Register(regexp *Regexp) <span class="cov0" title="0">{ regexp.targets = my.targets }</span>

func RegexpTargetError(target error) AttrRegexpTargetError <span class="cov0" title="0">{
        return AttrRegexpTargetError{target: target}
}</span>
func (my AttrRegexpTargetError) Register(regexp *Regexp) <span class="cov0" title="0">{ regexp.target = my.target.Error() }</span>

func RegexpTargetsError(targets ...error) AttrRegexpTargetsError <span class="cov0" title="0">{
        return AttrRegexpTargetsError{targets: targets}
}</span>
func (my AttrRegexpTargetsError) Register(regexp *Regexp) <span class="cov0" title="0">{
        if len(my.targets) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">ret := make([]string, 0, len(my.targets))
        for idx := range my.targets </span><span class="cov0" title="0">{
                ret = append(ret, my.targets[idx].Error())
        }</span>
        <span class="cov0" title="0">regexp.targets = ret</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">package str

import (
        "fmt"
        "os"
        "strings"
        "time"

        "github.com/spf13/cast"
)

type (
        Str struct{ original string }

        TerminalLog struct {
                format string
                enable bool
        }

        TerminalLogColor string
)

var (
        StrApp         Str
        TerminalLogApp TerminalLog
)

const (
        TerminalLogColorBlack   TerminalLogColor = "\033[30m"
        TerminalLogColorRed     TerminalLogColor = "\033[31m"
        TerminalLogColorGreen   TerminalLogColor = "\033[32m"
        TerminalLogColorYellow  TerminalLogColor = "\033[33m"
        TerminalLogColorBlue    TerminalLogColor = "\033[34m"
        TerminalLogColorMagenta TerminalLogColor = "\033[35m"
        TerminalLogColorCyan    TerminalLogColor = "\033[36m"
        TerminalLogColorWhite   TerminalLogColor = "\033[37m"
        TerminalLogColorReset   TerminalLogColor = "\033[0m"
)

func (*Str) New(original string) *Str <span class="cov0" title="0">{ return &amp;Str{original: original} }</span>

// NewStr 实例化：字符串
//
//go:fix 推荐使用：New方法
func NewStr(original string) *Str <span class="cov0" title="0">{ return &amp;Str{original: original} }</span>

// PadLeftZeros 前置补零
func (my *Str) PadLeftZeros(length int) (string, error) <span class="cov0" title="0">{
        var (
                err error
                res strings.Builder = strings.Builder{}
        )

        if len(my.original) &gt;= length </span><span class="cov0" title="0">{
                return my.original, nil
        }</span>

        <span class="cov0" title="0">for i := 0; i &lt; length-len(my.original); i++ </span><span class="cov0" title="0">{
                res.WriteRune('0')
        }</span>

        <span class="cov0" title="0">if _, err = res.WriteString(my.original); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return res.String(), nil</span>
}

// PadRightZeros 后置补零
func (my *Str) PadRightZeros(length int) (string, error) <span class="cov0" title="0">{
        var (
                err error
                res strings.Builder = strings.Builder{}
        )

        if len(my.original) &gt;= length </span><span class="cov0" title="0">{
                return my.original, nil
        }</span>

        <span class="cov0" title="0">if _, err = res.WriteString(my.original); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">for i := 0; i &lt; length-len(my.original); i++ </span><span class="cov0" title="0">{
                res.WriteRune('0')
        }</span>

        <span class="cov0" title="0">return res.String(), nil</span>
}

// PadRight 后置填充
func (my *Str) PadRight(length int, s string) string <span class="cov0" title="0">{
        my.original += strings.Repeat(s, length-(len(my.original)%length))

        return my.original
}</span>

// PadLeft 前置补充
func (my *Str) PadLeft(length int, s string) string <span class="cov0" title="0">{
        my.original = strings.Repeat(s, length-(len(my.original)%length)) + s

        return my.original
}</span>

// ToLong 超出长度截断
func (my *Str) ToLong(length int, ends ...string) string <span class="cov0" title="0">{
        end := "..."
        if len(ends) &gt; 0 </span><span class="cov0" title="0">{
                end = ends[0]
        }</span>

        <span class="cov0" title="0">if len(my.original) &gt; length </span><span class="cov0" title="0">{
                return my.original[:length] + end
        }</span>

        <span class="cov0" title="0">return my.original</span>
}

// New 实例化：控制台日志
func (*TerminalLog) New(format ...string) *TerminalLog <span class="cov0" title="0">{
        var f string
        for _, v := range format </span><span class="cov0" title="0">{
                f += v
        }</span>

        <span class="cov0" title="0">return &amp;TerminalLog{format: f, enable: cast.ToBool(os.Getenv("AID__STR__TERMINAL_LOG__ENABLE"))}</span>
}

// NewTerminalLog 实例化：控制台日志
func NewTerminalLog(format ...string) *TerminalLog <span class="cov0" title="0">{
        var f string
        for _, v := range format </span><span class="cov0" title="0">{
                f += v
        }</span>

        <span class="cov0" title="0">return &amp;TerminalLog{format: f, enable: cast.ToBool(os.Getenv("AID__STR__TERMINAL_LOG__ENABLE"))}</span>
}

// Default 打印日志行
func (r *TerminalLog) Default(v ...any) <span class="cov0" title="0">{
        if !r.enable </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("%v「%s」%v\n", TerminalLogColorReset, time.Now().Format(time.DateTime), TerminalLogColorReset)
        fmt.Printf(fmt.Sprintf("%v&gt;&gt; %s%v\n\n", TerminalLogColorReset, r.format, TerminalLogColorReset), v...)</span>
}

// Info 打印日志行
func (r *TerminalLog) Info(v ...any) <span class="cov0" title="0">{
        if !r.enable </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("%v「%s」%v\n", TerminalLogColorMagenta, time.Now().Format(time.DateTime), TerminalLogColorReset)
        fmt.Printf(fmt.Sprintf("%v&gt;&gt; %s%v\n\n", TerminalLogColorMagenta, r.format, TerminalLogColorReset), v...)</span>
}

// Success 打印成功
func (r *TerminalLog) Success(v ...any) <span class="cov0" title="0">{
        if !r.enable </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("%v「%s」%v\n", TerminalLogColorGreen, time.Now().Format(time.DateTime), TerminalLogColorReset)
        fmt.Printf(fmt.Sprintf("%v&gt;&gt; %s%v\n\n", TerminalLogColorGreen, r.format, TerminalLogColorReset), v...)</span>
}

// Wrong 打印错误
func (r *TerminalLog) Wrong(v ...any) <span class="cov0" title="0">{
        if !r.enable </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("%v「%s」%v\n", TerminalLogColorRed, time.Now().Format(time.DateTime), TerminalLogColorReset)
        fmt.Printf(fmt.Sprintf("%v&gt;&gt; %s%v\n\n", TerminalLogColorRed, r.format, TerminalLogColorReset), v...)</span>
}

// Error 打印错误并终止程序
func (r *TerminalLog) Error(v ...any) <span class="cov0" title="0">{
        if !r.enable </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("%v「%s」%v\n", TerminalLogColorRed, time.Now().Format(time.DateTime), TerminalLogColorReset)
        fmt.Printf(fmt.Sprintf("%v&gt;&gt; %s%v\n\n", TerminalLogColorRed, r.format, TerminalLogColorReset), v...)
        os.Exit(-1)</span>
}
</pre>
		
		<pre class="file" id="file93" style="display: none">package str

import (
        "regexp"
        "strings"
        "unicode"
)

type Transfer struct{ original string }

var TransferApp Transfer

func (*Transfer) New(original string) *Transfer <span class="cov0" title="0">{ return &amp;Transfer{original: original} }</span>

// NewTransfer 实例化：字符串转换
//
//go:fix 推荐使用：New方法
func NewTransfer(original string) *Transfer <span class="cov0" title="0">{ return &amp;Transfer{original: original} }</span>

// PascalToCamel 大驼峰 -&gt; 小驼峰
func (my *Transfer) PascalToCamel() string <span class="cov0" title="0">{
        if len(my.original) == 0 </span><span class="cov0" title="0">{
                return my.original
        }</span>
        // 将第一个字符转换为小写
        <span class="cov0" title="0">firstRune := []rune(my.original)[0]
        if unicode.IsUpper(firstRune) </span><span class="cov0" title="0">{
                firstRune = unicode.ToLower(firstRune)
        }</span>

        // 拼接第一个字符和剩余部分
        <span class="cov0" title="0">return string(firstRune) + my.original[1:]</span>
}

// PascalToSnake 大驼峰 -&gt; 下划线
func (my *Transfer) PascalToSnake() string <span class="cov0" title="0">{
        var result strings.Builder

        for i, r := range my.original </span><span class="cov0" title="0">{
                if unicode.IsUpper(r) &amp;&amp; i &gt; 0 </span><span class="cov0" title="0">{
                        result.WriteRune('_')
                }</span>
                <span class="cov0" title="0">result.WriteRune(unicode.ToLower(r))</span>
        }

        <span class="cov0" title="0">return result.String()</span>
}

// PascalToBabel 大驼峰 -&gt; babel
func (my *Transfer) PascalToBabel() string <span class="cov0" title="0">{
        var result strings.Builder

        for i, r := range my.original </span><span class="cov0" title="0">{
                if unicode.IsUpper(r) &amp;&amp; i &gt; 0 </span><span class="cov0" title="0">{
                        result.WriteRune('-')
                }</span>
                <span class="cov0" title="0">result.WriteRune(unicode.ToLower(r))</span>
        }

        <span class="cov0" title="0">return result.String()</span>
}

// CamelToPascal 小驼峰 -&gt; 大驼峰
func (my *Transfer) CamelToPascal() string <span class="cov0" title="0">{
        if len(my.original) == 0 </span><span class="cov0" title="0">{
                return my.original
        }</span>
        <span class="cov0" title="0">firstRune := []rune(my.original)[0]
        if unicode.IsLower(firstRune) </span><span class="cov0" title="0">{
                firstRune = unicode.ToUpper(firstRune)
        }</span>

        <span class="cov0" title="0">return string(firstRune) + my.original[1:]</span>
}

// CamelToSnake 小驼峰 -&gt; 下划线
func (my *Transfer) CamelToSnake() string <span class="cov0" title="0">{
        var result strings.Builder

        for idx, ite := range my.original </span><span class="cov0" title="0">{
                if unicode.IsUpper(ite) &amp;&amp; idx &gt; 0 </span><span class="cov0" title="0">{
                        result.WriteRune('_')
                }</span>
                <span class="cov0" title="0">result.WriteRune(unicode.ToLower(ite))</span>
        }

        <span class="cov0" title="0">return result.String()</span>
}

// CamelToBabel 小驼峰 -&gt; babel
func (my *Transfer) CamelToBabel() string <span class="cov0" title="0">{
        var result strings.Builder

        for idx, ite := range my.original </span><span class="cov0" title="0">{
                if unicode.IsUpper(ite) &amp;&amp; idx &gt; 0 </span><span class="cov0" title="0">{
                        result.WriteRune('-')
                }</span>
                <span class="cov0" title="0">result.WriteRune(unicode.ToLower(ite))</span>
        }

        <span class="cov0" title="0">return result.String()</span>
}

// SnakeToPascal 下划线 -&gt; 大驼峰
func (my *Transfer) SnakeToPascal() string <span class="cov0" title="0">{
        // 将下划线分割成单词
        words := strings.Split(my.original, "_")

        // 处理每个单词，将首字母大写
        for i, word := range words </span><span class="cov0" title="0">{
                if len(word) &gt; 0 </span><span class="cov0" title="0">{
                        runes := []rune(word)
                        runes[0] = unicode.ToUpper(runes[0])
                        words[i] = string(runes)
                }</span>
        }

        // 拼接所有单词
        <span class="cov0" title="0">pascal := strings.Join(words, "")

        return pascal</span>
}

// SnakeToCamel 下划线 -&gt; 小驼峰
func (my *Transfer) SnakeToCamel() string <span class="cov0" title="0">{
        // 将下划线分割成单词
        words := strings.Split(my.original, "_")

        // 处理每个单词，将首字母大写
        for i, word := range words </span><span class="cov0" title="0">{
                if len(word) &gt; 0 </span><span class="cov0" title="0">{
                        runes := []rune(word)
                        runes[0] = unicode.ToLower(runes[0])
                        words[i] = string(runes)
                }</span>
        }

        // 拼接所有单词
        <span class="cov0" title="0">pascal := strings.Join(words, "")

        return pascal</span>
}

// SnakeToBabel 下划线 -&gt; babel
func (my *Transfer) SnakeToBabel() string <span class="cov0" title="0">{
        return strings.ReplaceAll(my.original, "_", "-")
}</span>

// BabelToPascal babel -&gt; 大驼峰
func (my *Transfer) BabelToPascal() string <span class="cov0" title="0">{
        words := strings.Split(my.original, "-")
        for i, word := range words </span><span class="cov0" title="0">{
                if len(word) &gt; 0 </span><span class="cov0" title="0">{
                        runes := []rune(word)
                        runes[0] = unicode.ToUpper(runes[0])
                        words[i] = string(runes)
                }</span>
        }
        <span class="cov0" title="0">pascal := strings.Join(words, "")

        return pascal</span>
}

// KebabToCamel babel -&gt; 小驼峰
func (my *Transfer) KebabToCamel() string <span class="cov0" title="0">{
        // 将 kebab-case 分割成单词
        words := strings.Split(my.original, "-")

        // 处理每个单词，除了第一个单词外，将每个单词的首字母大写
        for i := 1; i &lt; len(words); i++ </span><span class="cov0" title="0">{
                if len(words[i]) &gt; 0 </span><span class="cov0" title="0">{
                        runes := []rune(words[i])
                        runes[0] = unicode.ToUpper(runes[0])
                        words[i] = string(runes)
                }</span>
        }

        // 拼接所有单词
        <span class="cov0" title="0">camel := strings.Join(words, "")

        // 确保第一个字符是小写
        if len(camel) &gt; 0 </span><span class="cov0" title="0">{
                runes := []rune(camel)
                runes[0] = unicode.ToLower(runes[0])
                camel = string(runes)
        }</span>

        <span class="cov0" title="0">return camel</span>
}

// BabelToSnake babel -&gt; 下划线
func (my *Transfer) BabelToSnake() string <span class="cov0" title="0">{ return strings.ReplaceAll(my.original, "_", "-") }</span>

// Pluralize 单数变复数
func (my *Transfer) Pluralize() string <span class="cov0" title="0">{
        // 定义正则表达式
        sXChSh := regexp.MustCompile(`[sxz]|[cs]h$`)
        yEnding := regexp.MustCompile(`[^aeiou]y$`)
        fFeEnding := regexp.MustCompile(`[f]e?$`)

        // 处理以 s, x, ch, sh 结尾的名词
        if sXChSh.MatchString(my.original) </span><span class="cov0" title="0">{
                return my.original + "es"
        }</span>

        // 处理以辅音字母 + y 结尾的名词
        <span class="cov0" title="0">if yEnding.MatchString(my.original) </span><span class="cov0" title="0">{
                return yEnding.ReplaceAllString(my.original, "ies")
        }</span>

        // 处理以 f 或 fe 结尾的名词
        <span class="cov0" title="0">if fFeEnding.MatchString(my.original) </span><span class="cov0" title="0">{
                return fFeEnding.ReplaceAllString(my.original, "ves")
        }</span>

        // 默认情况下，直接加 s
        <span class="cov0" title="0">return my.original + "s"</span>
}
</pre>
		
		<pre class="file" id="file94" style="display: none">package time

import (
        "fmt"
        "time"
)

// Time 时间帮助
type Time struct{ original time.Time }

var App Time

const (
        Nanosecond  time.Duration = 1
        Microsecond               = 1000 * Nanosecond
        Millisecond               = 1000 * Microsecond
        Second                    = 1000 * Millisecond
        Minute                    = 60 * Second
        Hour                      = 60 * Minute

        Layout      = time.Layout
        ANSIC       = time.ANSIC
        UnixDate    = time.UnixDate
        RubyDate    = time.RubyDate
        RFC822      = time.RFC822
        RFC822Z     = time.RFC822Z
        RFC850      = time.RFC850
        RFC1123     = time.RFC1123
        RFC1123Z    = time.RFC1123Z
        RFC3339     = time.RFC3339
        RFC3339Nano = time.RFC3339Nano
        Kitchen     = time.Kitchen
        Stamp       = time.Stamp
        StampMilli  = time.StampMilli
        StampMicro  = time.StampMicro
        StampNano   = time.StampNano
        DateTime    = time.DateTime
        DateOnly    = time.DateOnly
        TimeOnly    = time.TimeOnly
)

// New 实例化：时间帮助
func (*Time) New(t time.Time) *Time <span class="cov0" title="0">{ return &amp;Time{original: t} }</span>

// Now 实例化：时间帮助 -&gt; 当前时间
func (*Time) Now() *Time <span class="cov0" title="0">{ return &amp;Time{original: time.Now()} }</span>

// FromFormat 实例化：时间帮助 -&gt; 通过格式化模板
func (*Time) FromFormat(format, t string) (*Time, error) <span class="cov0" title="0">{
        parsedTime, err := time.Parse(format, t)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;Time{original: parsedTime}, nil</span>
}

// FormString 实例化：时间帮助 -&gt; 通过时间字符串自动解析
func (*Time) FormString(t string) (*Time, error) <span class="cov0" title="0">{
        formats := []string{
                time.Layout,
                time.ANSIC,
                time.UnixDate,
                time.RubyDate,
                time.RFC822,
                time.RFC822Z,
                time.RFC850,
                time.RFC1123,
                time.RFC1123Z,
                time.RFC3339,
                time.RFC3339Nano,
                time.Kitchen,
                time.Stamp,
                time.StampMilli,
                time.StampMicro,
                time.StampNano,
                time.DateTime,
                time.DateOnly,
                time.TimeOnly,
        }

        for _, format := range formats </span><span class="cov0" title="0">{
                parsedTime, err := time.Parse(format, t)
                if err == nil </span><span class="cov0" title="0">{
                        return &amp;Time{original: parsedTime}, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("无法解析时间：%s", t)</span>
}

// AddDays 增加时间
func (my *Time) AddDays(days int) *Time <span class="cov0" title="0">{
        my.original = my.original.AddDate(0, 0, days)

        return my
}</span>

// AddMonths 增加月份
func (my *Time) AddMonths(months int) *Time <span class="cov0" title="0">{
        my.original = my.original.AddDate(0, months, 0)

        return my
}</span>

// AddYears 增加年份
func (my *Time) AddYears(years int) *Time <span class="cov0" title="0">{
        my.original = my.original.AddDate(years, 0, 0)

        return my
}</span>

// Format 格式化
func (my *Time) Format(format string) string <span class="cov0" title="0">{ return my.original.Format(format) }</span>

// Diff 计算两个时间之间的差值
func (my *Time) Diff(other *Time) time.Duration <span class="cov0" title="0">{ return my.original.Sub(other.original) }</span>

// IsBefore 判断是否早于某时间
func (my *Time) IsBefore(other *Time) bool <span class="cov0" title="0">{ return my.original.Before(other.original) }</span>

// IsAfter 判断是否晚于某时间
func (my *Time) IsAfter(other *Time) bool <span class="cov0" title="0">{ return my.original.After(other.original) }</span>

// IsEqual 判断是否等于某时间
func (my *Time) IsEqual(other *Time) bool <span class="cov0" title="0">{ return my.original.Equal(other.original) }</span>

// IsZero 判断是否是0值
func (my *Time) IsZero() bool <span class="cov0" title="0">{ return my.original.IsZero() }</span>

// ToTime 转换为时间
func (my *Time) ToTime() time.Time <span class="cov0" title="0">{ return my.original }</span>

// ToTimePtr 转换为时间指针
func (my *Time) ToTimePtr() *time.Time <span class="cov0" title="0">{ return &amp;my.original }</span>
</pre>
		
		<pre class="file" id="file95" style="display: none">package validator

import (
        "fmt"
        "reflect"

        "github.com/aid297/aid/array"
        "github.com/aid297/aid/myError"
        "github.com/aid297/aid/operation"
)

type (
        ValidateError struct{ myError.MyError }
        RequiredError struct{ myError.MyError }
        EmailError    struct{ myError.MyError }
        TimeError     struct{ myError.MyError }
        LengthError   struct{ myError.MyError }
        RuleError     struct{ myError.MyError }
)

var (
        ValidateErr ValidateError
        RequiredErr RequiredError
        EmailErr    EmailError
        TimeErr     TimeError
        LengthErr   LengthError
        RuleErr     RuleError
)

func (*ValidateError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;ValidateError{myError.MyError{Msg: array.NewDestruction("验证错误", msg).JoinWithoutEmpty("：")}}
}</span>
func (my *ValidateError) NewFormat(format string, messages ...any) myError.IMyError <span class="cov0" title="0">{
        return &amp;ValidateError{myError.MyError{Msg: fmt.Sprintf(format, messages...)}}
}</span>

func (*ValidateError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;ValidateError{myError.MyError{Msg: fmt.Errorf("验证错误"+operation.Ternary(err != nil, "：%w", "%w"), err).Error()}}
}</span>

func (*ValidateError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;ValidateError{MyError: myError.MyError{Msg: "验证错误"}}
}</span>

func (my *ValidateError) Error() string <span class="cov0" title="0">{ return my.MyError.Msg }</span>

func (my *ValidateError) Is(target error) bool <span class="cov0" title="0">{ return reflect.DeepEqual(target, &amp;ValidateErr) }</span>

func (*RequiredError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;RequiredError{myError.MyError{Msg: fmt.Sprintf("[%s]必填", msg)}}
}</span>

func (*RequiredError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;RequiredError{myError.MyError{Msg: fmt.Errorf("[%w]必填", err).Error()}}
}</span>

func (*RequiredError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;RequiredError{MyError: myError.MyError{Msg: "缺少必填项目"}}
}</span>

func (my *RequiredError) Error() string <span class="cov0" title="0">{ return my.MyError.Msg }</span>

func (my *RequiredError) Is(target error) bool <span class="cov0" title="0">{ return reflect.DeepEqual(target, &amp;RequiredErr) }</span>

func (*EmailError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;EmailError{myError.MyError{Msg: fmt.Sprintf("[%s]不是有效的邮箱格式", msg)}}
}</span>

func (*EmailError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;EmailError{myError.MyError{Msg: fmt.Errorf("[%w]不是有效的邮箱格式", err).Error()}}
}</span>

func (*EmailError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;EmailError{myError.MyError{Msg: "邮箱格式错误"}}
}</span>

func (my *EmailError) Error() string <span class="cov0" title="0">{ return my.MyError.Msg }</span>

func (my *EmailError) Is(target error) bool <span class="cov0" title="0">{ return reflect.DeepEqual(target, &amp;EmailErr) }</span>

func (*TimeError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;TimeError{myError.MyError{Msg: fmt.Sprintf("[%s]不是有效的邮箱格式", msg)}}
}</span>

func (*TimeError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;TimeError{myError.MyError{Msg: fmt.Errorf("[%w]不是有效的邮箱格式", err).Error()}}
}</span>

func (*TimeError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;TimeError{myError.MyError{Msg: "时间格式错误"}}
}</span>

func (my *TimeError) Error() string <span class="cov0" title="0">{ return my.MyError.Msg }</span>

func (my *TimeError) Is(target error) bool <span class="cov0" title="0">{ return reflect.DeepEqual(target, &amp;TimeErr) }</span>

func (my *TimeError) NewFormat(format string, messages ...any) myError.IMyError <span class="cov0" title="0">{
        return &amp;TimeError{myError.MyError{Msg: fmt.Sprintf(format, messages...)}}
}</span>

func (*LengthError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;LengthError{myError.MyError{Msg: fmt.Sprintf("[%s]长度错误", msg)}}
}</span>

func (*LengthError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;LengthError{myError.MyError{Msg: fmt.Errorf("[%w]长度错误", err).Error()}}
}</span>

func (*LengthError) Panic() myError.IMyError <span class="cov0" title="0">{
        return &amp;LengthError{myError.MyError{Msg: "长度错误"}}
}</span>

func (my *LengthError) Error() string <span class="cov0" title="0">{ return my.MyError.Msg }</span>

func (my *LengthError) Is(target error) bool <span class="cov0" title="0">{ return reflect.DeepEqual(target, &amp;LengthErr) }</span>

func (my *LengthError) NewFormat(format string, messages ...any) myError.IMyError <span class="cov0" title="0">{
        return &amp;LengthError{myError.MyError{Msg: fmt.Sprintf(format, messages...)}}
}</span>

func (*RuleError) New(msg string) myError.IMyError <span class="cov0" title="0">{
        return &amp;RuleError{myError.MyError{Msg: fmt.Sprintf("[%s]规则错误", msg)}}
}</span>

func (*RuleError) Wrap(err error) myError.IMyError <span class="cov0" title="0">{
        return &amp;RuleError{myError.MyError{Msg: fmt.Errorf("[%w]规则错误", err).Error()}}
}</span>

func (*RuleError) Panic() myError.IMyError <span class="cov0" title="0">{ return &amp;RuleError{myError.MyError{Msg: "规则错误"}} }</span>

func (my *RuleError) Error() string <span class="cov0" title="0">{ return my.MyError.Msg }</span>

func (my *RuleError) Is(target error) bool <span class="cov0" title="0">{ return reflect.DeepEqual(target, &amp;LengthErr) }</span>

func (my *RuleError) NewFormat(format string, messages ...any) myError.IMyError <span class="cov0" title="0">{
        return &amp;RuleError{myError.MyError{Msg: fmt.Sprintf(format, messages...)}}
}</span>
</pre>
		
		<pre class="file" id="file96" style="display: none">package validator

import (
        "reflect"
        "strings"
        "sync"

        "github.com/gin-gonic/gin"
        "github.com/gofiber/fiber/v2"

        "github.com/aid297/aid/operation/operationV2"
        "github.com/aid297/aid/str"
)

type (
        // ValidatorApp 验证器
        ValidatorApp[T any] struct {
                data           T
                prefixNames    []string
                err            error
                emailFormat    string
                dateFormat     string
                timeFormat     string
                datetimeFormat string
                checkFunctions checkFunMap
        }

        ValidatorExCheckerApp struct{ ExFunMap exFunMap }

        checkFun    func(rule string, fieldName string, value any) error
        checkFunMap map[string]checkFun
        exFun       func(value any) error
        exFunMap    map[string]exFun
)

var (
        validatorExCheckerOnce sync.Once
        validatorExCheckerIns  *ValidatorExCheckerApp
        ValidatorExChecker     ValidatorExCheckerApp
)

// Once 单利化：额外验证器
func (*ValidatorExCheckerApp) Once() *ValidatorExCheckerApp <span class="cov8" title="1">{
        validatorExCheckerOnce.Do(func() </span><span class="cov8" title="1">{ validatorExCheckerIns = &amp;ValidatorExCheckerApp{ExFunMap: make(exFunMap)} }</span>)
        <span class="cov8" title="1">return validatorExCheckerIns</span>
}

// RegisterExFun 注册额外验证函数
func (my *ValidatorExCheckerApp) RegisterExFun(name string, exFun exFun) *ValidatorExCheckerApp <span class="cov8" title="1">{
        my.ExFunMap[name] = exFun
        return my
}</span>

// New 实例化：验证器
func New[T any](data T, prefixNames ...string) *ValidatorApp[T] <span class="cov8" title="1">{
        p := make([]string, 0)
        if len(prefixNames) &gt; 0 </span><span class="cov0" title="0">{
                p = prefixNames
        }</span>

        <span class="cov8" title="1">ins := &amp;ValidatorApp[T]{
                data:           data,
                prefixNames:    p,
                emailFormat:    `^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`,
                dateFormat:     `^\d{4}-\d{2}-\d{2}$`,
                timeFormat:     `^\d{2}:\d{2}:\d{2}\.{0,1}\d+$`,
                datetimeFormat: `^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$`,
                checkFunctions: make(checkFunMap, 0),
        }

        ins.checkFunctions = checkFunMap{
                "string":     ins.checkString,
                "*string":    ins.checkString,
                "int":        ins.checkInt,
                "*int":       ins.checkInt,
                "int8":       ins.checkInt8,
                "*int8":      ins.checkInt8,
                "int16":      ins.checkInt16,
                "*int16":     ins.checkInt16,
                "int32":      ins.checkInt32,
                "*int32":     ins.checkInt32,
                "int64":      ins.checkInt64,
                "*int64":     ins.checkInt64,
                "uint":       ins.checkUint,
                "*uint":      ins.checkUint,
                "uint8":      ins.checkUint8,
                "*uint8":     ins.checkUint8,
                "uint16":     ins.checkUint16,
                "*uint16":    ins.checkUint16,
                "uint32":     ins.checkUint32,
                "*uint32":    ins.checkUint32,
                "uint64":     ins.checkUint64,
                "*uint64":    ins.checkUint64,
                "float32":    ins.checkFloat32,
                "*float32":   ins.checkFloat32,
                "float64":    ins.checkFloat64,
                "*float64":   ins.checkFloat64,
                "time.Time":  ins.checkTime,
                "*time.Time": ins.checkTime,
        }

        return ins</span>
}

// WithGinPtr 执行验证，使用gin.Context(返回指针)
func WithGinPtr[T any](c *gin.Context, fns ...func(ins *T) (err error)) (*T, error) <span class="cov0" title="0">{
        ins, err := WithGin(c, fns...)
        return &amp;ins, err
}</span>

// WithGin 执行验证，使用gin.Context(返回值)
func WithGin[T any](c *gin.Context, fns ...func(ins *T) (err error)) (T, error) <span class="cov0" title="0">{
        var (
                err error
                ins = new(T)
        )

        if err = c.ShouldBind(ins); err != nil </span><span class="cov0" title="0">{
                return *ins, err
        }</span>

        <span class="cov0" title="0">if err = New(ins).Validate(fns...); err != nil </span><span class="cov0" title="0">{
                return *ins, err
        }</span>

        <span class="cov0" title="0">return *ins, nil</span>
}

func WithFiberPtr[T any](c *fiber.Ctx, fns ...func(ins *T) (err error)) (*T, error) <span class="cov0" title="0">{
        ins, err := WithFiber(c, fns...)
        return &amp;ins, err
}</span>

// WithFiber 执行验证，使用fiber.Ctx(返回值)
func WithFiber[T any](c *fiber.Ctx, fns ...func(ins *T) (err error)) (T, error) <span class="cov0" title="0">{
        var (
                err error
                ins = new(T)
        )

        if err = c.BodyParser(ins); err != nil </span><span class="cov0" title="0">{
                return *ins, err
        }</span>

        <span class="cov0" title="0">if err = New(ins).Validate(fns...); err != nil </span><span class="cov0" title="0">{
                return *ins, err
        }</span>

        <span class="cov0" title="0">return *ins, nil</span>
}

// Validate 执行验证
func (my *ValidatorApp[T]) Validate(funcs ...func(ins T) (err error)) error <span class="cov8" title="1">{
        defer my.clean()

        if my.err != nil </span><span class="cov0" title="0">{
                return my.err
        }</span>

        <span class="cov8" title="1">my.err = my.validate(my.data)
        if my.err != nil </span><span class="cov8" title="1">{
                return my.err
        }</span>
        <span class="cov0" title="0">if len(funcs) &gt; 0 </span><span class="cov0" title="0">{
                for _, fn := range funcs </span><span class="cov0" title="0">{
                        if err := fn(my.data); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">return my.err</span>
}

// EmailFormat 设置email默认规则
func (my *ValidatorApp[T]) EmailFormat(emailFormat string) *ValidatorApp[T] <span class="cov0" title="0">{
        my.emailFormat = emailFormat
        return my
}</span>

// DateFormat 设置日期默认规则
func (my *ValidatorApp[T]) DateFormat(dateFormat string) *ValidatorApp[T] <span class="cov0" title="0">{
        my.dateFormat = dateFormat
        return my
}</span>

// TimeFormat 设置时间默认规则
func (my *ValidatorApp[T]) TimeFormat(timeFormat string) *ValidatorApp[T] <span class="cov0" title="0">{
        my.timeFormat = timeFormat
        return my
}</span>

// DatetimeFormat 设置日期+时间默认规则
func (my *ValidatorApp[T]) DatetimeFormat(datetimeFormat string) *ValidatorApp[T] <span class="cov0" title="0">{
        my.datetimeFormat = datetimeFormat
        return my
}</span>

func (my *ValidatorApp[T]) clean() <span class="cov8" title="1">{ my.err = nil }</span>

// validate 执行验证
func (my *ValidatorApp[T]) validate(v any) error <span class="cov8" title="1">{
        val := reflect.ValueOf(v)
        if val.Kind() != reflect.Struct &amp;&amp; val.Kind() != reflect.Ptr </span><span class="cov0" title="0">{
                return ValidateErr.New("不符合结构或指针")
        }</span>
        <span class="cov8" title="1">if val.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                val = val.Elem()
        }</span>

        <span class="cov8" title="1">for i := range val.NumField() </span><span class="cov8" title="1">{
                field := val.Type().Field(i)
                if field.Anonymous </span><span class="cov0" title="0">{
                        // 递归验证嵌套字段
                        if err := New(val.Field(i).Interface(), my.prefixNames...).Validate(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov8" title="1">tag := field.Tag.Get("v-rule")
                if tag == "" || tag == "-" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">fieldName := my.concatFieldName(operationV2.NewTernary(operationV2.TrueValue(field.Tag.Get("v-name")), operationV2.FalseValue(str.APP.Transfer.New(val.Type().Name()).PascalToCamel())).GetByValue(field.Tag.Get("v-name") != ""))

                for _, rule := range strings.Split(tag, ";") </span><span class="cov8" title="1">{
                        if fn, exist := my.checkFunctions[val.Field(i).Type().String()]; exist </span><span class="cov8" title="1">{
                                if err := fn(rule, fieldName, val.Field(i).Interface()); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }

                <span class="cov8" title="1">exTag := field.Tag.Get("v-ex")
                if exTag == "" || exTag == "-" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">for _, exRule := range strings.Split(exTag, ";") </span><span class="cov8" title="1">{
                        if exFun, exist := ValidatorExChecker.Once().ExFunMap[exRule]; exist </span><span class="cov8" title="1">{
                                if err := exFun(val.Field(i).Interface()); err != nil </span><span class="cov8" title="1">{
                                        return err
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (my *ValidatorApp[T]) concatFieldName(fieldName string) string <span class="cov8" title="1">{
        var concatFieldNames = make([]string, len(my.prefixNames)+1)

        if len(my.prefixNames) &gt; 0 </span><span class="cov0" title="0">{
                copy(concatFieldNames, my.prefixNames)
                concatFieldNames[len(my.prefixNames)] = fieldName

                return strings.Join(concatFieldNames, ".")
        }</span>

        <span class="cov8" title="1">return fieldName</span>
}
</pre>
		
		<pre class="file" id="file97" style="display: none">package validatorV2

import (
        "errors"
        "fmt"
        "reflect"
        "regexp"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/gofiber/fiber/v2"
)

type (
        Validator struct{}

        // FieldResult 保留类型以兼容引用（目前不再返回 FieldResult）
        FieldResult struct {
                Field  string   `json:"field"`
                Errors []string `json:"errors"`
        }
)

// ExFn 扩展校验函数类型及注册表
type ExFn func(val any) error

var (
        exFns   = make(map[string]ExFn)
        exFnsMu sync.RWMutex
)

// RegisterExFun 注册一个扩展校验函数，key 为 v-ex 标签中的键
func RegisterExFun(key string, fn ExFn) <span class="cov8" title="1">{
        exFnsMu.Lock()
        defer exFnsMu.Unlock()
        exFns[key] = fn
}</span>

// UnregisterExFun 注销注册函数
func UnregisterExFun(key string) <span class="cov8" title="1">{
        exFnsMu.Lock()
        defer exFnsMu.Unlock()
        delete(exFns, key)
}</span>

func getExFun(key string) (ExFn, bool) <span class="cov8" title="1">{
        exFnsMu.RLock()
        defer exFnsMu.RUnlock()
        f, ok := exFns[key]
        return f, ok
}</span>

// splitExKeys 支持用逗号或分号分隔多个扩展 key
func splitExKeys(s string) []string <span class="cov8" title="1">{
        s = strings.TrimSpace(s)
        // 支持 ; 或 , 分隔
        if s == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">parts := strings.FieldsFunc(s, func(r rune) bool </span><span class="cov8" title="1">{
                return r == ';' || r == ','
        }</span>)
        <span class="cov8" title="1">out := make([]string, 0, len(parts))
        for _, p := range parts </span><span class="cov8" title="1">{
                p = strings.TrimSpace(p)
                if p != "" </span><span class="cov8" title="1">{
                        out = append(out, p)
                }</span>
        }
        <span class="cov8" title="1">return out</span>
}

// removeRule 从规则字符串中移除指定的规则 key（按分号分隔）
func removeRule(ruleStr, key string) string <span class="cov8" title="1">{
        if strings.TrimSpace(ruleStr) == "" </span><span class="cov8" title="1">{
                return ruleStr
        }</span>
        <span class="cov8" title="1">parts := strings.Split(ruleStr, ";")
        out := make([]string, 0, len(parts))
        for _, p := range parts </span><span class="cov8" title="1">{
                p = strings.TrimSpace(p)
                if p == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                // 取出规则名（遇到 : = &gt; &lt; 或 = 号时取左侧）
                <span class="cov8" title="1">name := p
                if idx := strings.IndexAny(p, ":=&lt;&gt;\"' "); idx &gt;= 0 </span><span class="cov8" title="1">{
                        name = strings.TrimSpace(p[:idx])
                }</span>
                <span class="cov8" title="1">if name == key </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">out = append(out, p)</span>
        }
        <span class="cov8" title="1">return strings.Join(out, ";")</span>
}

// WithFiber 在 Fiber 框架中绑定并验证请求数据。
func WithFiber[T any](c *fiber.Ctx, fns ...func(ins any) (err error)) (T, error) <span class="cov0" title="0">{
        var (
                err error
                ins = new(T)
        )

        if err = c.BodyParser(ins); err != nil </span><span class="cov0" title="0">{
                return *ins, err
        }</span>

        <span class="cov0" title="0">errs := app.Validator.Validate(ins, fns...)
        if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                parts := make([]string, 0, len(errs))
                for _, e := range errs </span><span class="cov0" title="0">{
                        parts = append(parts, e.Error())
                }</span>
                <span class="cov0" title="0">return *ins, errors.New(strings.Join(parts, "; "))</span>
        }

        <span class="cov0" title="0">return *ins, nil</span>
}

// WithGin 在 Gin 框架中绑定并验证请求数据。
func WithGin[T any](c *gin.Context, fns ...func(ins any) (err error)) (T, error) <span class="cov0" title="0">{
        var (
                err error
                ins = new(T)
        )

        if err = c.ShouldBind(ins); err != nil </span><span class="cov0" title="0">{
                return *ins, err
        }</span>

        <span class="cov0" title="0">errs := app.Validator.Validate(ins, fns...)
        if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                parts := make([]string, 0, len(errs))
                for _, e := range errs </span><span class="cov0" title="0">{
                        parts = append(parts, e.Error())
                }</span>
                <span class="cov0" title="0">return *ins, errors.New(strings.Join(parts, "; "))</span>
        }

        <span class="cov0" title="0">return *ins, nil</span>
}

// Validate 验证任意结构体，返回每个字段的验证结果（字段名和错误切片）。
// 支持的 tag:
// - v-rule: 规则串，规则之间以分号分隔。例如: "required;min&gt;3;max&lt;10;email;in=a,b"
// - v-name: 字段可读名称，嵌套时会以点号拼接，例如: 父.子
// 设计假设：
// - min / max 对字符串表示长度（&gt;= / &lt;=），对数字表示数值（&gt;= / &lt;=）。
// - in / not-in 使用逗号分隔的值列表。
// - regex=... 使用完整正则表达式。
// - 支持快捷规则: email, date(2006-01-02), time(15:04:05), datetime(2006-01-02 15:04:05)
func (Validator) Validate(data any, exFns ...func(d any) error) []error <span class="cov8" title="1">{
        if data == nil </span><span class="cov0" title="0">{
                return []error{fmt.Errorf("data is nil")}
        }</span>
        <span class="cov8" title="1">rv := reflect.ValueOf(data)
        for rv.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                if rv.IsNil() </span><span class="cov0" title="0">{
                        return []error{fmt.Errorf("不支持空指针验证")}
                }</span>
                <span class="cov0" title="0">rv = rv.Elem()</span>
        }
        <span class="cov8" title="1">if rv.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                return []error{fmt.Errorf("只支持指针或结构体")}
        }</span>

        <span class="cov8" title="1">errs := make([]error, 0)
        walkStruct(rv, "", &amp;errs)
        if len(errs) &gt; 0 </span><span class="cov8" title="1">{
                return errs
        }</span>

        <span class="cov8" title="1">for idx := range exFns </span><span class="cov0" title="0">{
                if exFns[idx] != nil </span><span class="cov0" title="0">{
                        if err := exFns[idx](&amp;data); err != nil </span><span class="cov0" title="0">{
                                errs = append(errs, err)
                        }</span>
                }
        }

        <span class="cov8" title="1">return errs</span>
}

// walkStruct 递归遍历结构体字段，处理嵌套结构体（排除 time.Time）
func walkStruct(rv reflect.Value, parent string, results *[]error) <span class="cov8" title="1">{
        rt := rv.Type()
        for i := 0; i &lt; rt.NumField(); i++ </span><span class="cov8" title="1">{
                sf := rt.Field(i)
                // 跳过未导出字段
                if sf.PkgPath != "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">fv := rv.Field(i)
                // 字段显示名
                vName := sf.Tag.Get("v-name")
                if vName == "" </span><span class="cov0" title="0">{
                        vName = sf.Name
                }</span>
                <span class="cov8" title="1">fullName := vName
                if parent != "" </span><span class="cov8" title="1">{
                        fullName = parent + "." + vName
                }</span>

                <span class="cov8" title="1">ruleStr := sf.Tag.Get("v-rule")
                // 扩展校验标签，可写多个 key，使用逗号或分号分隔
                exTag := sf.Tag.Get("v-ex")

                // 处理指针类型：保留nil信息以便 required 校验
                origVal := fv.Interface()
                if fv.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                        if fv.IsNil() </span><span class="cov8" title="1">{
                                // nil 指针 -&gt; 仅能检测 required
                                errs := applyRulesToNil(ruleStr, fullName)
                                for _, e := range errs </span><span class="cov8" title="1">{
                                        *results = append(*results, fmt.Errorf(e))
                                }</span>
                                // 执行扩展函数（nil 值）
                                <span class="cov8" title="1">if exTag != "" </span><span class="cov8" title="1">{
                                        exKeys := splitExKeys(exTag)
                                        for _, k := range exKeys </span><span class="cov8" title="1">{
                                                if fn, ok := getExFun(k); ok </span><span class="cov8" title="1">{
                                                        if err := fn(nil); err != nil </span><span class="cov8" title="1">{
                                                                *results = append(*results, err)
                                                        }</span>
                                                }
                                        }
                                }
                                <span class="cov8" title="1">continue</span>
                        }
                        <span class="cov8" title="1">fv = fv.Elem()</span>
                }

                // 当字段原始为非 nil 指针且包含 required 规则时，视为满足 required（只检查存在性），
                // 因此在后续对解引用值的校验中不再把 required 作为一项规则来检查。
                <span class="cov8" title="1">effectiveRuleStr := ruleStr
                if origVal != nil </span><span class="cov8" title="1">{
                        if rvOrig := reflect.ValueOf(origVal); rvOrig.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                                effectiveRuleStr = removeRule(effectiveRuleStr, "required")
                        }</span>
                }

                // 特殊处理 time.Time
                <span class="cov8" title="1">if fv.Kind() == reflect.Struct &amp;&amp; fv.Type().PkgPath() == "time" &amp;&amp; fv.Type().Name() == "Time" </span><span class="cov0" title="0">{
                        errs := checkTimeValue(fv.Interface(), effectiveRuleStr, fullName)
                        for _, e := range errs </span><span class="cov0" title="0">{
                                *results = append(*results, fmt.Errorf(e))
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov8" title="1">switch fv.Kind() </span>{
                case reflect.Struct:<span class="cov8" title="1">
                        // 嵌套结构体 -&gt; 递归
                        walkStruct(fv, fullName, results)</span>
                case reflect.String:<span class="cov8" title="1">
                        errs := checkString(fv.String(), effectiveRuleStr, fullName)
                        for _, e := range errs </span><span class="cov8" title="1">{
                                *results = append(*results, fmt.Errorf(e))
                        }</span>
                case reflect.Slice, reflect.Array:<span class="cov8" title="1">
                        errs := checkSlice(fv, effectiveRuleStr, fullName)
                        for _, e := range errs </span><span class="cov8" title="1">{
                                *results = append(*results, fmt.Errorf(e))
                        }</span>
                        // 如果元素是结构体或指针结构体，继续验证元素内部字段，并使用索引扩展名称
                        <span class="cov8" title="1">elemKind := fv.Type().Elem().Kind()
                        if elemKind == reflect.Struct || (elemKind == reflect.Ptr &amp;&amp; fv.Type().Elem().Elem().Kind() == reflect.Struct) </span><span class="cov8" title="1">{
                                for j := 0; j &lt; fv.Len(); j++ </span><span class="cov8" title="1">{
                                        e := fv.Index(j)
                                        for e.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                                                if e.IsNil() </span><span class="cov0" title="0">{
                                                        // 元素为 nil，跳过深度验证
                                                        e = reflect.Zero(e.Type().Elem())
                                                        break</span>
                                                }
                                                <span class="cov0" title="0">e = e.Elem()</span>
                                        }
                                        <span class="cov8" title="1">walkStruct(e, fmt.Sprintf("%s[%d]", fullName, j), results)</span>
                                }
                        }
                case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                        errs := checkNumberInt(fv.Int(), effectiveRuleStr, fullName)
                        for _, e := range errs </span><span class="cov8" title="1">{
                                *results = append(*results, fmt.Errorf(e))
                        }</span>
                case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                        errs := checkNumberUint(fv.Uint(), effectiveRuleStr, fullName)
                        for _, e := range errs </span><span class="cov0" title="0">{
                                *results = append(*results, fmt.Errorf(e))
                        }</span>
                case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                        errs := checkNumberFloat(fv.Float(), effectiveRuleStr, fullName)
                        for _, e := range errs </span><span class="cov0" title="0">{
                                *results = append(*results, fmt.Errorf(e))
                        }</span>
                case reflect.Bool:<span class="cov0" title="0">
                        // 目前不对 bool 做额外校验，除非有 in/not-in 等规则
                        errs := checkBool(fv.Bool(), effectiveRuleStr, fullName)
                        for _, e := range errs </span><span class="cov0" title="0">{
                                *results = append(*results, fmt.Errorf(e))
                        }</span>
                default:<span class="cov0" title="0">
                        // 其他类型目前不处理，但如果存在 required 规则需要提示
                        errs := applyRulesToAny(fv.Interface(), effectiveRuleStr, fullName)
                        for _, e := range errs </span><span class="cov0" title="0">{
                                *results = append(*results, fmt.Errorf(e))
                        }</span>
                }

                // 执行扩展校验函数（v-ex）: 传入原始值（指针未展开的 origVal if was pointer else fv.Interface()）
                <span class="cov8" title="1">if exTag != "" </span><span class="cov8" title="1">{
                        exKeys := splitExKeys(exTag)
                        var valForEx any
                        // 尝试使用原始未展开值（保持 pointer 状态），否则使用当前 fv.Interface()
                        if origVal != nil </span><span class="cov8" title="1">{
                                valForEx = origVal
                        }</span> else<span class="cov0" title="0"> {
                                valForEx = fv.Interface()
                        }</span>
                        <span class="cov8" title="1">for _, k := range exKeys </span><span class="cov8" title="1">{
                                if fn, ok := getExFun(k); ok </span><span class="cov8" title="1">{
                                        if err := fn(valForEx); err != nil </span><span class="cov8" title="1">{
                                                *results = append(*results, fmt.Errorf("[%s] %s", fullName, err.Error()))
                                        }</span>
                                }
                        }
                }
        }
}

// 解析简单规则串
type rule struct {
        key string
        op  string // =, &gt;, &lt;, : or empty
        val string
}

func parseRules(s string) []rule <span class="cov8" title="1">{
        out := make([]rule, 0)
        s = strings.TrimSpace(s)
        if s == "" </span><span class="cov8" title="1">{
                return out
        }</span>
        <span class="cov8" title="1">parts := strings.Split(s, ";")
        for _, p := range parts </span><span class="cov8" title="1">{
                p = strings.TrimSpace(p)
                if p == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                // 查找运算符
                <span class="cov8" title="1">var r rule
                if idx := strings.IndexAny(p, ":="); idx &gt;= 0 </span><span class="cov8" title="1">{
                        r.key = strings.TrimSpace(p[:idx])
                        r.op = string(p[idx])
                        r.val = strings.TrimSpace(p[idx+1:])
                }</span> else<span class="cov8" title="1"> if idx := strings.IndexAny(p, "&gt;"); idx &gt;= 0 </span><span class="cov8" title="1">{
                        r.key = strings.TrimSpace(p[:idx])
                        r.op = "&gt;"
                        r.val = strings.TrimSpace(p[idx+1:])
                }</span> else<span class="cov8" title="1"> if idx := strings.IndexAny(p, "&lt;"); idx &gt;= 0 </span><span class="cov8" title="1">{
                        r.key = strings.TrimSpace(p[:idx])
                        r.op = "&lt;"
                        r.val = strings.TrimSpace(p[idx+1:])
                }</span> else<span class="cov8" title="1"> if strings.Contains(p, "=") </span><span class="cov0" title="0">{ // fallback
                        if kv := strings.SplitN(p, "=", 2); len(kv) == 2 </span><span class="cov0" title="0">{
                                r.key = strings.TrimSpace(kv[0])
                                r.op = "="
                                r.val = strings.TrimSpace(kv[1])
                        }</span> else<span class="cov0" title="0"> {
                                r.key = p
                        }</span>
                } else<span class="cov8" title="1"> {
                        r.key = p
                }</span>
                <span class="cov8" title="1">out = append(out, r)</span>
        }
        <span class="cov8" title="1">return out</span>
}

// helper: apply rules when value is nil pointer
func applyRulesToNil(ruleStr, fieldName string) []string <span class="cov8" title="1">{
        rules := parseRules(ruleStr)
        errs := make([]string, 0)
        for _, r := range rules </span><span class="cov8" title="1">{
                if r.key == "required" </span><span class="cov8" title="1">{
                        errs = append(errs, fmt.Sprintf("[%s]为必填项", fieldName))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}

func applyRulesToAny(val any, ruleStr, fieldName string) []string <span class="cov0" title="0">{
        rules := parseRules(ruleStr)
        errs := make([]string, 0)
        for _, r := range rules </span><span class="cov0" title="0">{
                if r.key == "required" </span><span class="cov0" title="0">{
                        // 判断零值
                        if isZeroValue(reflect.ValueOf(val)) </span><span class="cov0" title="0">{
                                errs = append(errs, fmt.Sprintf("[%s]为必填项", fieldName))
                        }</span>
                }
        }
        <span class="cov0" title="0">return errs</span>
}

func isZeroValue(v reflect.Value) bool <span class="cov0" title="0">{
        z := reflect.Zero(v.Type())
        return reflect.DeepEqual(v.Interface(), z.Interface())
}</span>

// checkString 对字符串的验证
func checkString(s, ruleStr, fieldName string) []string <span class="cov8" title="1">{
        rules := parseRules(ruleStr)
        errs := make([]string, 0)
        for _, r := range rules </span><span class="cov8" title="1">{
                switch r.key </span>{
                case "required":<span class="cov8" title="1">
                        if strings.TrimSpace(s) == "" </span><span class="cov0" title="0">{
                                errs = append(errs, fmt.Sprintf("[%s]为必填项", fieldName))
                        }</span>
                case "nullable":<span class="cov0" title="0"></span>
                        // nothing
                case "min":<span class="cov8" title="1">
                        if n, err := strconv.Atoi(r.val); err == nil </span><span class="cov8" title="1">{
                                if len([]rune(s)) &lt; n </span><span class="cov0" title="0">{
                                        errs = append(errs, fmt.Sprintf("[%s]长度不能小于 %d", fieldName, n))
                                }</span>
                        }
                case "max":<span class="cov8" title="1">
                        if n, err := strconv.Atoi(r.val); err == nil </span><span class="cov8" title="1">{
                                if len([]rune(s)) &gt; n </span><span class="cov0" title="0">{
                                        errs = append(errs, fmt.Sprintf("[%s]长度不能大于 %d", fieldName, n))
                                }</span>
                        }
                case "len":<span class="cov8" title="1">
                        if n, err := strconv.Atoi(r.val); err == nil </span><span class="cov8" title="1">{
                                if len([]rune(s)) != n </span><span class="cov8" title="1">{
                                        errs = append(errs, fmt.Sprintf("[%s]长度必须为 %d", fieldName, n))
                                }</span>
                        }
                case "in":<span class="cov8" title="1">
                        if !inStringList(s, r.val) </span><span class="cov8" title="1">{
                                errs = append(errs, fmt.Sprintf("[%s]值必须在[%s]中", fieldName, r.val))
                        }</span>
                case "not-in":<span class="cov8" title="1">
                        if inStringList(s, r.val) </span><span class="cov8" title="1">{
                                errs = append(errs, fmt.Sprintf("[%s]值不可为[%s]", fieldName, r.val))
                        }</span>
                case "regex":<span class="cov8" title="1">
                        ok := matchRegex(r.val, s)
                        if !ok </span><span class="cov8" title="1">{
                                errs = append(errs, fmt.Sprintf("[%s]不匹配正则表达式", fieldName))
                        }</span>
                case "email":<span class="cov0" title="0">
                        if !isEmail(s) </span><span class="cov0" title="0">{
                                errs = append(errs, fmt.Sprintf("[%s]不是有效的邮箱", fieldName))
                        }</span>
                case "date":<span class="cov0" title="0">
                        if !isDate(s) </span><span class="cov0" title="0">{
                                errs = append(errs, fmt.Sprintf("[%s]不是有效的日期(YYYY-MM-DD)", fieldName))
                        }</span>
                case "time":<span class="cov0" title="0">
                        if !isTime(s) </span><span class="cov0" title="0">{
                                errs = append(errs, fmt.Sprintf("[%s]不是有效的时间(HH:MM:SS)", fieldName))
                        }</span>
                case "datetime":<span class="cov0" title="0">
                        if !isDateTime(s) </span><span class="cov0" title="0">{
                                errs = append(errs, fmt.Sprintf("[%s]不是有效的日期时间(YYYY-MM-DD HH:MM:SS)", fieldName))
                        }</span>
                default:<span class="cov8" title="1">
                        // 兼容形式: min&gt;3 / max&lt;10 / key&gt;n / key&lt;n
                        if r.op == "&gt;" </span><span class="cov0" title="0">{
                                if r.key == "min" </span><span class="cov0" title="0">{
                                        if n, err := strconv.Atoi(r.val); err == nil </span><span class="cov0" title="0">{
                                                if len([]rune(s)) &lt; n </span><span class="cov0" title="0">{
                                                        errs = append(errs, fmt.Sprintf("[%s]长度不能小于 %d", fieldName, n))
                                                }</span>
                                        }
                                }
                        } else<span class="cov8" title="1"> if r.op == "&lt;" </span><span class="cov0" title="0">{
                                if r.key == "max" </span><span class="cov0" title="0">{
                                        if n, err := strconv.Atoi(r.val); err == nil </span><span class="cov0" title="0">{
                                                if len([]rune(s)) &gt; n </span><span class="cov0" title="0">{
                                                        errs = append(errs, fmt.Sprintf("[%s]长度不能大于 %d", fieldName, n))
                                                }</span>
                                        }
                                }
                        }
                }
        }
        <span class="cov8" title="1">return errs</span>
}

func inStringList(s, list string) bool <span class="cov8" title="1">{
        list = strings.TrimSpace(list)
        if list == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">parts := strings.Split(list, ",")
        for _, p := range parts </span><span class="cov8" title="1">{
                if strings.TrimSpace(p) == s </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func matchRegex(pattern, s string) bool <span class="cov8" title="1">{
        re, err := regexp.Compile(pattern)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return re.MatchString(s)</span>
}

func isEmail(s string) bool <span class="cov0" title="0">{
        // 简单邮箱校验
        if s == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">re := regexp.MustCompile(`^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$`)
        return re.MatchString(s)</span>
}

func isDate(s string) bool <span class="cov0" title="0">{
        if _, err := time.Parse("2006-01-02", s); err == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func isTime(s string) bool <span class="cov0" title="0">{
        if _, err := time.Parse("15:04:05", s); err == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func isDateTime(s string) bool <span class="cov0" title="0">{
        layouts := []string{"2006-01-02 15:04:05", time.RFC3339}
        for _, l := range layouts </span><span class="cov0" title="0">{
                if _, err := time.Parse(l, s); err == nil </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// checkSlice 校验数组/切片长度及简单 in/not-in 对元素的约束
func checkSlice(v reflect.Value, ruleStr, fieldName string) []string <span class="cov8" title="1">{
        rules := parseRules(ruleStr)
        errs := make([]string, 0)
        length := v.Len()
        for _, r := range rules </span><span class="cov8" title="1">{
                switch r.key </span>{
                case "min":<span class="cov8" title="1">
                        if n, err := strconv.Atoi(r.val); err == nil </span><span class="cov8" title="1">{
                                if length &lt; n </span><span class="cov8" title="1">{
                                        errs = append(errs, fmt.Sprintf("[%s]长度不能小于 %d", fieldName, n))
                                }</span>
                        }
                case "max":<span class="cov8" title="1">
                        if n, err := strconv.Atoi(r.val); err == nil </span><span class="cov8" title="1">{
                                if length &gt; n </span><span class="cov0" title="0">{
                                        errs = append(errs, fmt.Sprintf("[%s]长度不能大于 %d", fieldName, n))
                                }</span>
                        }
                case "len":<span class="cov0" title="0">
                        if n, err := strconv.Atoi(r.val); err == nil </span><span class="cov0" title="0">{
                                if length != n </span><span class="cov0" title="0">{
                                        errs = append(errs, fmt.Sprintf("[%s]长度必须为 %d", fieldName, n))
                                }</span>
                        }
                case "required":<span class="cov0" title="0">
                        if length == 0 </span><span class="cov0" title="0">{
                                errs = append(errs, fmt.Sprintf("[%s]为必填项", fieldName))
                        }</span>
                }
        }
        <span class="cov8" title="1">return errs</span>
}

func checkNumberInt(val int64, ruleStr, fieldName string) []string <span class="cov8" title="1">{
        rules := parseRules(ruleStr)
        errs := make([]string, 0)
        for _, r := range rules </span><span class="cov8" title="1">{
                switch r.key </span>{
                case "required":<span class="cov0" title="0">
                        // 零值检查视为必填
                        if val == 0 </span><span class="cov0" title="0">{
                                errs = append(errs, fmt.Sprintf("[%s]为必填项", fieldName))
                        }</span>
                case "min":<span class="cov8" title="1">
                        if n, err := strconv.ParseInt(r.val, 10, 64); err == nil </span><span class="cov8" title="1">{
                                if val &lt; n </span><span class="cov8" title="1">{
                                        errs = append(errs, fmt.Sprintf("[%s]不能小于 %d", fieldName, n))
                                }</span>
                        }
                case "max":<span class="cov8" title="1">
                        if n, err := strconv.ParseInt(r.val, 10, 64); err == nil </span><span class="cov8" title="1">{
                                if val &gt; n </span><span class="cov0" title="0">{
                                        errs = append(errs, fmt.Sprintf("[%s]不能大于 %d", fieldName, n))
                                }</span>
                        }
                case "in":<span class="cov0" title="0">
                        if !inStringList(fmt.Sprintf("%d", val), r.val) </span><span class="cov0" title="0">{
                                errs = append(errs, fmt.Sprintf("[%s]值必须在[%s]中", fieldName, r.val))
                        }</span>
                case "not-in":<span class="cov0" title="0">
                        if inStringList(fmt.Sprintf("%d", val), r.val) </span><span class="cov0" title="0">{
                                errs = append(errs, fmt.Sprintf("[%s]值不可为[%s]", fieldName, r.val))
                        }</span>
                default:<span class="cov0" title="0">
                        if r.op == "&gt;" </span><span class="cov0" title="0">{
                                if n, err := strconv.ParseInt(r.val, 10, 64); err == nil </span><span class="cov0" title="0">{
                                        if val &lt; n </span><span class="cov0" title="0">{
                                                errs = append(errs, fmt.Sprintf("[%s]不能小于 %d", fieldName, n))
                                        }</span>
                                }
                        } else<span class="cov0" title="0"> if r.op == "&lt;" </span><span class="cov0" title="0">{
                                if n, err := strconv.ParseInt(r.val, 10, 64); err == nil </span><span class="cov0" title="0">{
                                        if val &gt; n </span><span class="cov0" title="0">{
                                                errs = append(errs, fmt.Sprintf("[%s]不能大于 %d", fieldName, n))
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov8" title="1">return errs</span>
}

func checkNumberUint(val uint64, ruleStr, fieldName string) []string <span class="cov0" title="0">{
        rules := parseRules(ruleStr)
        errs := make([]string, 0)
        for _, r := range rules </span><span class="cov0" title="0">{
                switch r.key </span>{
                case "required":<span class="cov0" title="0">
                        if val == 0 </span><span class="cov0" title="0">{
                                errs = append(errs, fmt.Sprintf("[%s]为必填项", fieldName))
                        }</span>
                case "min":<span class="cov0" title="0">
                        if n, err := strconv.ParseUint(r.val, 10, 64); err == nil </span><span class="cov0" title="0">{
                                if val &lt; n </span><span class="cov0" title="0">{
                                        errs = append(errs, fmt.Sprintf("[%s]不能小于 %d", fieldName, n))
                                }</span>
                        }
                case "max":<span class="cov0" title="0">
                        if n, err := strconv.ParseUint(r.val, 10, 64); err == nil </span><span class="cov0" title="0">{
                                if val &gt; n </span><span class="cov0" title="0">{
                                        errs = append(errs, fmt.Sprintf("[%s]不能大于 %d", fieldName, n))
                                }</span>
                        }
                case "in":<span class="cov0" title="0">
                        if !inStringList(fmt.Sprintf("%d", val), r.val) </span><span class="cov0" title="0">{
                                errs = append(errs, fmt.Sprintf("[%s]值必须在[%s]中", fieldName, r.val))
                        }</span>
                case "not-in":<span class="cov0" title="0">
                        if inStringList(fmt.Sprintf("%d", val), r.val) </span><span class="cov0" title="0">{
                                errs = append(errs, fmt.Sprintf("[%s]值不可为[%s]", fieldName, r.val))
                        }</span>
                }
        }
        <span class="cov0" title="0">return errs</span>
}

func checkNumberFloat(val float64, ruleStr, fieldName string) []string <span class="cov0" title="0">{
        rules := parseRules(ruleStr)
        errs := make([]string, 0)
        for _, r := range rules </span><span class="cov0" title="0">{
                switch r.key </span>{
                case "required":<span class="cov0" title="0">
                        if val == 0 </span><span class="cov0" title="0">{
                                errs = append(errs, fmt.Sprintf("[%s]为必填项", fieldName))
                        }</span>
                case "min":<span class="cov0" title="0">
                        if n, err := strconv.ParseFloat(r.val, 64); err == nil </span><span class="cov0" title="0">{
                                if val &lt; n </span><span class="cov0" title="0">{
                                        errs = append(errs, fmt.Sprintf("[%s]不能小于 %v", fieldName, n))
                                }</span>
                        }
                case "max":<span class="cov0" title="0">
                        if n, err := strconv.ParseFloat(r.val, 64); err == nil </span><span class="cov0" title="0">{
                                if val &gt; n </span><span class="cov0" title="0">{
                                        errs = append(errs, fmt.Sprintf("[%s]不能大于 %v", fieldName, n))
                                }</span>
                        }
                case "in":<span class="cov0" title="0">
                        if !inStringList(fmt.Sprintf("%v", val), r.val) </span><span class="cov0" title="0">{
                                errs = append(errs, fmt.Sprintf("[%s]值必须在[%s]中", fieldName, r.val))
                        }</span>
                case "not-in":<span class="cov0" title="0">
                        if inStringList(fmt.Sprintf("%v", val), r.val) </span><span class="cov0" title="0">{
                                errs = append(errs, fmt.Sprintf("[%s]值不可为[%s]", fieldName, r.val))
                        }</span>
                }
        }
        <span class="cov0" title="0">return errs</span>
}

func checkBool(val bool, ruleStr, fieldName string) []string <span class="cov0" title="0">{
        rules := parseRules(ruleStr)
        errs := make([]string, 0)
        for _, r := range rules </span><span class="cov0" title="0">{
                switch r.key </span>{
                case "required":<span class="cov0" title="0"></span>
                        // 对 bool 来说，无法区分零值和未赋值，通常不检查
                case "in":<span class="cov0" title="0">
                        if !inStringList(fmt.Sprintf("%v", val), r.val) </span><span class="cov0" title="0">{
                                errs = append(errs, fmt.Sprintf("[%s]值必须在[%s]中", fieldName, r.val))
                        }</span>
                }
        }
        <span class="cov0" title="0">return errs</span>
}

// checkTimeValue 用于 time.Time 类型的字段
func checkTimeValue(val any, ruleStr, fieldName string) []string <span class="cov0" title="0">{
        rules := parseRules(ruleStr)
        errs := make([]string, 0)
        t, ok := val.(time.Time)
        if !ok </span><span class="cov0" title="0">{
                return append(errs, fmt.Sprintf("[%s]不是时间类型", fieldName))
        }</span>
        <span class="cov0" title="0">for _, r := range rules </span><span class="cov0" title="0">{
                switch r.key </span>{
                case "required":<span class="cov0" title="0">
                        if t.IsZero() </span><span class="cov0" title="0">{
                                errs = append(errs, fmt.Sprintf("[%s]为必填项", fieldName))
                        }</span>
                case "datetime":<span class="cov0" title="0">
                        if t.IsZero() </span><span class="cov0" title="0">{
                                errs = append(errs, fmt.Sprintf("[%s]不是有效的日期时间", fieldName))
                        }</span>
                }
        }
        <span class="cov0" title="0">return errs</span>
}
</pre>
		
		<pre class="file" id="file98" style="display: none">package validatorV3

import (
        "fmt"
        "strings"

        "github.com/aid297/aid/array/anyArrayV2"
)

// checkBool 检查布尔值，支持：required、[bool|b]、in、not-in：
func (my FieldInfo) checkBool() FieldInfo <span class="cov0" title="0">{
        var (
                rules    = anyArrayV2.NewList(my.VRuleTags)
                ruleType = my.getRuleType(rules)
                in       []string
                notIn    []string
                value    string
                ok       bool
                def      = []string{"true", "True", "t", "yes", "on", "ok", "1", "false", "False", "f", "off", "no", "0"}
        )

        if value, ok = my.Value.(string); !ok </span><span class="cov0" title="0">{
                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：字符串", my.getName(), ErrInvalidType))
                return my
        }</span>

        <span class="cov0" title="0">for idx := range my.VRuleTags </span><span class="cov0" title="0">{
                if my.VRuleTags[idx] == "required" &amp;&amp; my.IsPtr &amp;&amp; my.IsNil </span><span class="cov0" title="0">{
                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w", my.getName(), ErrRequired))
                }</span>

                <span class="cov0" title="0">switch ruleType </span>{
                case "", "string":<span class="cov0" title="0">
                        if strings.HasPrefix(my.VRuleTags[idx], "in") </span><span class="cov0" title="0">{
                                if in = getRuleIn(my.VRuleTags[idx]); len(in) &gt; 0 </span><span class="cov0" title="0">{
                                        anyArrayV2.NewList(in).IfNotIn(func() </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：在 %v 之中", my.getName(), ErrInvalidValue, in))
                                        }</span>, value)
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "not-in") </span><span class="cov0" title="0">{
                                if notIn = getRuleNotIn(my.VRuleTags[idx]); len(notIn) &gt; 0 </span><span class="cov0" title="0">{
                                        anyArrayV2.NewList(notIn).IfIn(func() </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：在 %v 之外", my.getName(), ErrInvalidValue, notIn))
                                        }</span>, value)
                                }
                        }
                        <span class="cov0" title="0">if len(in) == 0 &amp;&amp; len(notIn) == 0 </span><span class="cov0" title="0">{
                                anyArrayV2.NewList(def).IfNotIn(func() </span><span class="cov0" title="0">{
                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：在 %v 之外", my.getName(), ErrInvalidValue, def))
                                }</span>, value)
                        }
                }

                <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "ex") </span><span class="cov0" title="0">{
                        if exFnNames := getRuleExFnNames(my.VRuleTags[idx]); len(exFnNames) &gt; 0 </span><span class="cov0" title="0">{
                                for idx2 := range exFnNames </span><span class="cov0" title="0">{
                                        if fn := APP.Validator.Ins().GetExFn(exFnNames[idx2]); fn != nil </span><span class="cov0" title="0">{
                                                if err := fn(value); err != nil </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, err)
                                                }</span>
                                        }
                                }
                        }
                }
        }

        <span class="cov0" title="0">return my</span>
}
</pre>
		
		<pre class="file" id="file99" style="display: none">package validatorV3

import (
        "fmt"
        "strings"

        "github.com/spf13/cast"

        "github.com/aid297/aid/array/anyArrayV2"
)

// checkFloat32 检查小数#32位，支持：required、[float32|f32]、min&gt;、min&gt;=、max&lt;、max&lt;=、in、not-in、size:
func (my FieldInfo) checkFloat32() FieldInfo <span class="cov0" title="0">{
        var (
                rules          = anyArrayV2.NewList(my.VRuleTags)
                ruleType       = my.getRuleType(rules)
                min, max, size *float64
                include        bool
                in             []string
                notIn          []string
                value          float32
                ok             bool
        )

        if value, ok = my.Value.(float32); !ok </span><span class="cov0" title="0">{
                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：小数#32位", my.getName(), ErrInvalidType))
                return my
        }</span>

        <span class="cov0" title="0">if getRuleRequired(rules) &amp;&amp; my.IsPtr &amp;&amp; my.IsNil </span><span class="cov0" title="0">{
                my.wrongs = []error{fmt.Errorf("[%s] %w", my.getName(), ErrRequired)}
                return my
        }</span>

        <span class="cov0" title="0">for idx := range my.VRuleTags </span><span class="cov0" title="0">{
                if my.VRuleTags[idx] == "required" &amp;&amp; my.IsPtr &amp;&amp; my.IsNil </span><span class="cov0" title="0">{
                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w", my.getName(), ErrRequired))
                }</span>

                <span class="cov0" title="0">switch ruleType </span>{
                case "", "float32", "f32":<span class="cov0" title="0">
                        if strings.HasPrefix(my.VRuleTags[idx], "min") </span><span class="cov0" title="0">{
                                if min, include = getRuleFloatMin(my.VRuleTags[idx]); min != nil </span><span class="cov0" title="0">{
                                        if include </span><span class="cov0" title="0">{
                                                if !(cast.ToFloat64(value) &gt;= *min) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&gt;= %f", my.getName(), ErrInvalidLength, *min))
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                if !(cast.ToFloat64(value) &gt; *min) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&gt; %f", my.getName(), ErrInvalidLength, *min))
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "max") </span><span class="cov0" title="0">{
                                if max, include = getRuleFloatMax(my.VRuleTags[idx]); max != nil </span><span class="cov0" title="0">{
                                        if include </span><span class="cov0" title="0">{
                                                if !(cast.ToFloat64(value) &lt;= *max) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&lt;= %f", my.getName(), ErrInvalidLength, *max))
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                if !(cast.ToFloat64(value) &lt; *max) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&lt; %f", my.getName(), ErrInvalidLength, *max))
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "in") </span><span class="cov0" title="0">{
                                if in = getRuleIn(my.VRuleTags[idx]); len(in) &gt; 0 </span><span class="cov0" title="0">{
                                        anyArrayV2.NewList(in).IfNotIn(func() </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：在 %v 之中", my.getName(), ErrInvalidValue, in))
                                        }</span>, cast.ToString(value))
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "not-in") </span><span class="cov0" title="0">{
                                if notIn = getRuleNotIn(my.VRuleTags[idx]); len(notIn) &gt; 0 </span><span class="cov0" title="0">{
                                        anyArrayV2.NewList(notIn).IfIn(func() </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：在 %v 之外", my.getName(), ErrInvalidValue, notIn))
                                        }</span>, cast.ToString(value))
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "size") </span><span class="cov0" title="0">{
                                if size = getRuleFloatSize(my.VRuleTags[idx]); size != nil </span><span class="cov0" title="0">{
                                        if cast.ToFloat64(value) != *size </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：= %f", my.getName(), ErrInvalidLength, *size))
                                        }</span>
                                }
                        }
                }

                <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "ex") </span><span class="cov0" title="0">{
                        if exFnNames := getRuleExFnNames(my.VRuleTags[idx]); len(exFnNames) &gt; 0 </span><span class="cov0" title="0">{
                                for idx2 := range exFnNames </span><span class="cov0" title="0">{
                                        if fn := APP.Validator.Ins().GetExFn(exFnNames[idx2]); fn != nil </span><span class="cov0" title="0">{
                                                if err := fn(value); err != nil </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, err)
                                                }</span>
                                        }
                                }
                        }
                }
        }

        <span class="cov0" title="0">return my</span>
}

// checkFloat64 检查小数#64位，支持：required、[float|f64]、min&gt;、min&gt;=、max&lt;、max&lt;=、in、not-in、size:
func (my FieldInfo) checkFloat64() FieldInfo <span class="cov0" title="0">{
        var (
                rules          = anyArrayV2.NewList(my.VRuleTags)
                ruleType       = my.getRuleType(rules)
                min, max, size *float64
                include        bool
                in             []string
                notIn          []string
                value          float64
                ok             bool
        )

        if value, ok = my.Value.(float64); !ok </span><span class="cov0" title="0">{
                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：小数#64位", my.getName(), ErrInvalidType))
                return my
        }</span>

        <span class="cov0" title="0">if getRuleRequired(rules) &amp;&amp; my.IsPtr &amp;&amp; my.IsNil </span><span class="cov0" title="0">{
                my.wrongs = []error{fmt.Errorf("[%s] %w", my.getName(), ErrRequired)}
                return my
        }</span>

        <span class="cov0" title="0">for idx := range my.VRuleTags </span><span class="cov0" title="0">{
                switch ruleType </span>{
                case "", "float64", "f64":<span class="cov0" title="0">
                        if strings.HasPrefix(my.VRuleTags[idx], "min") </span><span class="cov0" title="0">{
                                if min, include = getRuleFloatMin(my.VRuleTags[idx]); min != nil </span><span class="cov0" title="0">{
                                        if include </span><span class="cov0" title="0">{
                                                if !(cast.ToFloat64(value) &gt;= *min) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&gt;= %f", my.getName(), ErrInvalidLength, *min))
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                if !(cast.ToFloat64(value) &gt; *min) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&gt; %f", my.getName(), ErrInvalidLength, *min))
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "max") </span><span class="cov0" title="0">{
                                if max, include = getRuleFloatMax(my.VRuleTags[idx]); max != nil </span><span class="cov0" title="0">{
                                        if include </span><span class="cov0" title="0">{
                                                if !(cast.ToFloat64(value) &lt;= *max) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&lt;= %f", my.getName(), ErrInvalidLength, *max))
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                if !(cast.ToFloat64(value) &lt; *max) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&lt; %f", my.getName(), ErrInvalidLength, *max))
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "in") </span><span class="cov0" title="0">{
                                if in = getRuleIn(my.VRuleTags[idx]); len(in) &gt; 0 </span><span class="cov0" title="0">{
                                        anyArrayV2.NewList(in).IfNotIn(func() </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：在 %v 之中", my.getName(), ErrInvalidValue, in))
                                        }</span>, cast.ToString(value))
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "not-in") </span><span class="cov0" title="0">{
                                if notIn = getRuleNotIn(my.VRuleTags[idx]); len(notIn) &gt; 0 </span><span class="cov0" title="0">{
                                        anyArrayV2.NewList(notIn).IfIn(func() </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：在 %v 之外", my.getName(), ErrInvalidValue, notIn))
                                        }</span>, cast.ToString(value))
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "size") </span><span class="cov0" title="0">{
                                if size = getRuleFloatSize(my.VRuleTags[idx]); size != nil </span><span class="cov0" title="0">{
                                        if cast.ToFloat64(value) != *size </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：= %f", my.getName(), ErrInvalidLength, *size))
                                        }</span>
                                }
                        }
                }

                <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "ex") </span><span class="cov0" title="0">{
                        if exFnNames := getRuleExFnNames(my.VRuleTags[idx]); len(exFnNames) &gt; 0 </span><span class="cov0" title="0">{
                                for idx2 := range exFnNames </span><span class="cov0" title="0">{
                                        if fn := APP.Validator.Ins().GetExFn(exFnNames[idx2]); fn != nil </span><span class="cov0" title="0">{
                                                if err := fn(value); err != nil </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, err)
                                                }</span>
                                        }
                                }
                        }
                }
        }

        <span class="cov0" title="0">return my</span>
}
</pre>
		
		<pre class="file" id="file100" style="display: none">package validatorV3

import (
        "fmt"
        "strings"

        "github.com/spf13/cast"

        "github.com/aid297/aid/array/anyArrayV2"
)

// checkInt 检查整数，支持：required、[int|i]、min&gt;、min&gt;=、max&lt;、max&lt;=、in、not-in、size:
func (my FieldInfo) checkInt() FieldInfo <span class="cov8" title="1">{
        var (
                rules          = anyArrayV2.NewList(my.VRuleTags)
                ruleType       = my.getRuleType(rules)
                min, max, size *int
                include        bool
                in             []string
                notIn          []string
                value          int
                ok             bool
        )

        if value, ok = my.Value.(int); !ok </span><span class="cov8" title="1">{
                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：整数", my.getName(), ErrInvalidType))
                return my
        }</span>

        <span class="cov8" title="1">for idx := range my.VRuleTags </span><span class="cov8" title="1">{
                if my.VRuleTags[idx] == "required" &amp;&amp; my.IsPtr &amp;&amp; my.IsNil </span><span class="cov0" title="0">{
                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w", my.getName(), ErrRequired))
                        return my
                }</span>

                <span class="cov8" title="1">switch ruleType </span>{
                case "", "int", "i":<span class="cov8" title="1">
                        if strings.HasPrefix(my.VRuleTags[idx], "min") </span><span class="cov0" title="0">{
                                if min, include = getRuleIntMin(my.VRuleTags[idx]); min != nil </span><span class="cov0" title="0">{
                                        if include </span><span class="cov0" title="0">{
                                                if !(value &gt;= *min) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&gt;= %d", my.getName(), ErrInvalidLength, *min))
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                if !(value &gt; *min) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&gt; %d", my.getName(), ErrInvalidLength, *min))
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov8" title="1">if strings.HasPrefix(my.VRuleTags[idx], "max") </span><span class="cov0" title="0">{
                                if max, include = getRuleIntMax(my.VRuleTags[idx]); max != nil </span><span class="cov0" title="0">{
                                        if include </span><span class="cov0" title="0">{
                                                if !(value &lt;= *max) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&lt;= %d", my.getName(), ErrInvalidLength, *max))
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                if !(value &lt; *max) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&lt; %d", my.getName(), ErrInvalidLength, *max))
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov8" title="1">if strings.HasPrefix(my.VRuleTags[idx], "in") </span><span class="cov0" title="0">{
                                if in = getRuleIn(my.VRuleTags[idx]); len(in) &gt; 0 </span><span class="cov0" title="0">{
                                        anyArrayV2.NewList(in).IfNotIn(func() </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：在 %v 之中", my.getName(), ErrInvalidValue, in))
                                        }</span>, cast.ToString(value))
                                }
                        }
                        <span class="cov8" title="1">if strings.HasPrefix(my.VRuleTags[idx], "not-in") </span><span class="cov0" title="0">{
                                if notIn = getRuleNotIn(my.VRuleTags[idx]); len(notIn) &gt; 0 </span><span class="cov0" title="0">{
                                        anyArrayV2.NewList(notIn).IfIn(func() </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：在 %v 之外", my.getName(), ErrInvalidValue, notIn))
                                        }</span>, cast.ToString(value))
                                }
                        }
                        <span class="cov8" title="1">if strings.HasPrefix(my.VRuleTags[idx], "size") </span><span class="cov0" title="0">{
                                if size = getRuleIntSize(my.VRuleTags[idx]); size != nil </span><span class="cov0" title="0">{
                                        if value != *size </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：= %d", my.getName(), ErrInvalidLength, *size))
                                        }</span>
                                }
                        }
                }

                <span class="cov8" title="1">if strings.HasPrefix(my.VRuleTags[idx], "ex") </span><span class="cov0" title="0">{
                        if exFnNames := getRuleExFnNames(my.VRuleTags[idx]); len(exFnNames) &gt; 0 </span><span class="cov0" title="0">{
                                for idx2 := range exFnNames </span><span class="cov0" title="0">{
                                        if fn := APP.Validator.Ins().GetExFn(exFnNames[idx2]); fn != nil </span><span class="cov0" title="0">{
                                                if err := fn(value); err != nil </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, err)
                                                }</span>
                                        }
                                }
                        }
                }
        }

        <span class="cov8" title="1">return my</span>
}

// checkInt8 检查整数#8位，支持：required、[int8|i8]、min&gt;、min&gt;=、max&lt;、max&lt;=、in、not-in、size:
func (my FieldInfo) checkInt8() FieldInfo <span class="cov8" title="1">{
        var (
                rules          = anyArrayV2.NewList(my.VRuleTags)
                ruleType       = my.getRuleType(rules)
                min, max, size *int
                include        bool
                in             []string
                notIn          []string
                value          int8
                ok             bool
        )

        if value, ok = my.Value.(int8); !ok </span><span class="cov0" title="0">{
                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：小数#32位", my.getName(), ErrInvalidType))
                return my
        }</span>

        <span class="cov8" title="1">if getRuleRequired(rules) &amp;&amp; my.IsPtr &amp;&amp; my.IsNil </span><span class="cov0" title="0">{
                my.wrongs = []error{fmt.Errorf("[%s] %w", my.getName(), ErrRequired)}
                return my
        }</span>

        <span class="cov8" title="1">for idx := range my.VRuleTags </span><span class="cov8" title="1">{
                switch ruleType </span>{
                case "", "int8", "i8":<span class="cov8" title="1">
                        if strings.HasPrefix(my.VRuleTags[idx], "min") </span><span class="cov0" title="0">{
                                if min, include = getRuleIntMin(my.VRuleTags[idx]); min != nil </span><span class="cov0" title="0">{
                                        if include </span><span class="cov0" title="0">{
                                                if !(cast.ToInt(value) &gt;= *min) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&gt;= %d", my.getName(), ErrInvalidLength, *min))
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                if !(cast.ToInt(value) &gt; *min) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&gt; %d", my.getName(), ErrInvalidLength, *min))
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov8" title="1">if strings.HasPrefix(my.VRuleTags[idx], "max") </span><span class="cov0" title="0">{
                                if max, include = getRuleIntMax(my.VRuleTags[idx]); max != nil </span><span class="cov0" title="0">{
                                        if include </span><span class="cov0" title="0">{
                                                if !(cast.ToInt(value) &lt;= *max) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&lt;= %d", my.getName(), ErrInvalidLength, *max))
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                if !(cast.ToInt(value) &lt; *max) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&lt; %d", my.getName(), ErrInvalidLength, *max))
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov8" title="1">if strings.HasPrefix(my.VRuleTags[idx], "in") </span><span class="cov0" title="0">{
                                if in = getRuleIn(my.VRuleTags[idx]); len(in) &gt; 0 </span><span class="cov0" title="0">{
                                        anyArrayV2.NewList(in).IfNotIn(func() </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：在 %v 之中", my.getName(), ErrInvalidValue, in))
                                        }</span>, cast.ToString(value))
                                }
                        }
                        <span class="cov8" title="1">if strings.HasPrefix(my.VRuleTags[idx], "not-in") </span><span class="cov0" title="0">{
                                if notIn = getRuleNotIn(my.VRuleTags[idx]); len(notIn) &gt; 0 </span><span class="cov0" title="0">{
                                        anyArrayV2.NewList(notIn).IfIn(func() </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：在 %v 之外", my.getName(), ErrInvalidValue, notIn))
                                        }</span>, cast.ToString(value))
                                }
                        }
                        <span class="cov8" title="1">if strings.HasPrefix(my.VRuleTags[idx], "size") </span><span class="cov0" title="0">{
                                if size = getRuleIntSize(my.VRuleTags[idx]); size != nil </span><span class="cov0" title="0">{
                                        if cast.ToInt(value) != *size </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：= %d", my.getName(), ErrInvalidLength, *size))
                                        }</span>
                                }
                        }
                }

                <span class="cov8" title="1">if strings.HasPrefix(my.VRuleTags[idx], "ex") </span><span class="cov0" title="0">{
                        if exFnNames := getRuleExFnNames(my.VRuleTags[idx]); len(exFnNames) &gt; 0 </span><span class="cov0" title="0">{
                                for idx2 := range exFnNames </span><span class="cov0" title="0">{
                                        if fn := APP.Validator.Ins().GetExFn(exFnNames[idx2]); fn != nil </span><span class="cov0" title="0">{
                                                if err := fn(value); err != nil </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, err)
                                                }</span>
                                        }
                                }
                        }
                }
        }

        <span class="cov8" title="1">return my</span>
}

// checkInt16 检查整数#16位，支持：required、[int16|i16]、min&gt;、min&gt;=、max&lt;、max&lt;=、in、not-in、size:
func (my FieldInfo) checkInt16() FieldInfo <span class="cov0" title="0">{
        var (
                rules          = anyArrayV2.NewList(my.VRuleTags)
                ruleType       = my.getRuleType(rules)
                min, max, size *int
                include        bool
                in             []string
                notIn          []string
                value          int16
                ok             bool
        )
        if value, ok = my.Value.(int16); !ok </span><span class="cov0" title="0">{
                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：整数#16位", my.getName(), ErrInvalidType))
                return my
        }</span>

        <span class="cov0" title="0">if getRuleRequired(rules) &amp;&amp; my.IsPtr &amp;&amp; my.IsNil </span><span class="cov0" title="0">{
                my.wrongs = []error{fmt.Errorf("[%s] %w", my.getName(), ErrRequired)}
                return my
        }</span>

        <span class="cov0" title="0">for idx := range my.VRuleTags </span><span class="cov0" title="0">{
                switch ruleType </span>{
                case "", "int16", "i16":<span class="cov0" title="0">
                        if strings.HasPrefix(my.VRuleTags[idx], "min") </span><span class="cov0" title="0">{
                                if min, include = getRuleIntMin(my.VRuleTags[idx]); min != nil </span><span class="cov0" title="0">{
                                        if include </span><span class="cov0" title="0">{
                                                if !(cast.ToInt(value) &gt;= *min) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&gt;= %d", my.getName(), ErrInvalidLength, *min))
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                if !(cast.ToInt(value) &gt; *min) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&gt; %d", my.getName(), ErrInvalidLength, *min))
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "max") </span><span class="cov0" title="0">{
                                if max, include = getRuleIntMax(my.VRuleTags[idx]); max != nil </span><span class="cov0" title="0">{
                                        if include </span><span class="cov0" title="0">{
                                                if !(cast.ToInt(value) &lt;= *max) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&lt;= %d", my.getName(), ErrInvalidLength, *max))
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                if !(cast.ToInt(value) &lt; *max) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&lt; %d", my.getName(), ErrInvalidLength, *max))
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "in") </span><span class="cov0" title="0">{
                                if in = getRuleIn(my.VRuleTags[idx]); len(in) &gt; 0 </span><span class="cov0" title="0">{
                                        anyArrayV2.NewList(in).IfNotIn(func() </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：在 %v 之中", my.getName(), ErrInvalidValue, in))
                                        }</span>, cast.ToString(value))
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "not-in") </span><span class="cov0" title="0">{
                                if notIn = getRuleNotIn(my.VRuleTags[idx]); len(notIn) &gt; 0 </span><span class="cov0" title="0">{
                                        anyArrayV2.NewList(notIn).IfIn(func() </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：在 %v 之外", my.getName(), ErrInvalidValue, notIn))
                                        }</span>, cast.ToString(value))
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "size") </span><span class="cov0" title="0">{
                                if size = getRuleIntSize(my.VRuleTags[idx]); size != nil </span><span class="cov0" title="0">{
                                        if cast.ToInt(value) != *size </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：= %d", my.getName(), ErrInvalidLength, *size))
                                        }</span>
                                }
                        }
                }

                <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "ex") </span><span class="cov0" title="0">{
                        if exFnNames := getRuleExFnNames(my.VRuleTags[idx]); len(exFnNames) &gt; 0 </span><span class="cov0" title="0">{
                                for idx2 := range exFnNames </span><span class="cov0" title="0">{
                                        if fn := APP.Validator.Ins().GetExFn(exFnNames[idx2]); fn != nil </span><span class="cov0" title="0">{
                                                if err := fn(value); err != nil </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, err)
                                                }</span>
                                        }
                                }
                        }
                }
        }

        <span class="cov0" title="0">return my</span>
}

// checkInt32 检查整数#32位，支持：required、[int32|i32]、min&gt;、min&gt;=、max&lt;、max&lt;=、in、not-in、size:
func (my FieldInfo) checkInt32() FieldInfo <span class="cov0" title="0">{
        var (
                rules          = anyArrayV2.NewList(my.VRuleTags)
                ruleType       = my.getRuleType(rules)
                min, max, size *int
                include        bool
                in             []string
                notIn          []string
                value          int32
                ok             bool
        )

        if value, ok = my.Value.(int32); !ok </span><span class="cov0" title="0">{
                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：整数#32位", my.getName(), ErrInvalidType))
                return my
        }</span>

        <span class="cov0" title="0">if getRuleRequired(rules) &amp;&amp; my.IsPtr &amp;&amp; my.IsNil </span><span class="cov0" title="0">{
                my.wrongs = []error{fmt.Errorf("[%s] %w", my.getName(), ErrRequired)}
                return my
        }</span>

        <span class="cov0" title="0">for idx := range my.VRuleTags </span><span class="cov0" title="0">{
                switch ruleType </span>{
                case "", "int32", "i32":<span class="cov0" title="0">
                        if strings.HasPrefix(my.VRuleTags[idx], "min") </span><span class="cov0" title="0">{
                                if min, include = getRuleIntMin(my.VRuleTags[idx]); min != nil </span><span class="cov0" title="0">{
                                        if include </span><span class="cov0" title="0">{
                                                if !(cast.ToInt(value) &gt;= *min) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&gt;= %d", my.getName(), ErrInvalidLength, *min))
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                if !(cast.ToInt(value) &gt; *min) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&gt; %d", my.getName(), ErrInvalidLength, *min))
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "max") </span><span class="cov0" title="0">{
                                if max, include = getRuleIntMax(my.VRuleTags[idx]); max != nil </span><span class="cov0" title="0">{
                                        if include </span><span class="cov0" title="0">{
                                                if !(cast.ToInt(value) &lt;= *max) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&lt;= %d", my.getName(), ErrInvalidLength, *max))
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                if !(cast.ToInt(value) &lt; *max) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&lt; %d", my.getName(), ErrInvalidLength, *max))
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "in") </span><span class="cov0" title="0">{
                                if in = getRuleIn(my.VRuleTags[idx]); len(in) &gt; 0 </span><span class="cov0" title="0">{
                                        anyArrayV2.NewList(in).IfNotIn(func() </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：在 %v 之中", my.getName(), ErrInvalidValue, in))
                                        }</span>, cast.ToString(value))
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "not-in") </span><span class="cov0" title="0">{
                                if notIn = getRuleNotIn(my.VRuleTags[idx]); len(notIn) &gt; 0 </span><span class="cov0" title="0">{
                                        anyArrayV2.NewList(notIn).IfIn(func() </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：在 %v 之外", my.getName(), ErrInvalidValue, notIn))
                                        }</span>, cast.ToString(value))
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "size") </span><span class="cov0" title="0">{
                                if size = getRuleIntSize(my.VRuleTags[idx]); size != nil </span><span class="cov0" title="0">{
                                        if cast.ToInt(value) != *size </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：= %d", my.getName(), ErrInvalidLength, *size))
                                        }</span>
                                }
                        }
                }

                <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "ex") </span><span class="cov0" title="0">{
                        if exFnNames := getRuleExFnNames(my.VRuleTags[idx]); len(exFnNames) &gt; 0 </span><span class="cov0" title="0">{
                                for idx2 := range exFnNames </span><span class="cov0" title="0">{
                                        if fn := APP.Validator.Ins().GetExFn(exFnNames[idx2]); fn != nil </span><span class="cov0" title="0">{
                                                if err := fn(value); err != nil </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, err)
                                                }</span>
                                        }
                                }
                        }
                }
        }

        <span class="cov0" title="0">return my</span>
}

// checkInt64 检查整数#64位，支持：required、[int64|i64]、min&gt;、min&gt;=、max&lt;、max&lt;=、in、not-in、size:
func (my FieldInfo) checkInt64() FieldInfo <span class="cov0" title="0">{
        var (
                rules          = anyArrayV2.NewList(my.VRuleTags)
                ruleType       = my.getRuleType(rules)
                min, max, size *int
                include        bool
                in             []string
                notIn          []string
                value          int64
                ok             bool
        )

        if value, ok = my.Value.(int64); !ok </span><span class="cov0" title="0">{
                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：整数#64位", my.getName(), ErrInvalidType))
                return my
        }</span>

        <span class="cov0" title="0">if getRuleRequired(rules) &amp;&amp; my.IsPtr &amp;&amp; my.IsNil </span><span class="cov0" title="0">{
                my.wrongs = []error{fmt.Errorf("[%s] %w", my.getName(), ErrRequired)}
                return my
        }</span>

        <span class="cov0" title="0">for idx := range my.VRuleTags </span><span class="cov0" title="0">{
                switch ruleType </span>{
                case "", "int64", "i64":<span class="cov0" title="0">
                        if strings.HasPrefix(my.VRuleTags[idx], "min") </span><span class="cov0" title="0">{
                                if min, include = getRuleIntMin(my.VRuleTags[idx]); min != nil </span><span class="cov0" title="0">{
                                        if include </span><span class="cov0" title="0">{
                                                if !(cast.ToInt(value) &gt;= *min) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&gt;= %d", my.getName(), ErrInvalidLength, *min))
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                if !(cast.ToInt(value) &gt; *min) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&gt; %d", my.getName(), ErrInvalidLength, *min))
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "max") </span><span class="cov0" title="0">{
                                if max, include = getRuleIntMax(my.VRuleTags[idx]); max != nil </span><span class="cov0" title="0">{
                                        if include </span><span class="cov0" title="0">{
                                                if !(cast.ToInt(value) &lt;= *max) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&lt;= %d", my.getName(), ErrInvalidLength, *max))
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                if !(cast.ToInt(value) &lt; *max) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&lt; %d", my.getName(), ErrInvalidLength, *max))
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "in") </span><span class="cov0" title="0">{
                                if in = getRuleIn(my.VRuleTags[idx]); len(in) &gt; 0 </span><span class="cov0" title="0">{
                                        anyArrayV2.NewList(in).IfNotIn(func() </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：在 %v 之中", my.getName(), ErrInvalidValue, in))
                                        }</span>, cast.ToString(value))
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "not-in") </span><span class="cov0" title="0">{
                                if notIn = getRuleNotIn(my.VRuleTags[idx]); len(notIn) &gt; 0 </span><span class="cov0" title="0">{
                                        anyArrayV2.NewList(notIn).IfIn(func() </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：在 %v 之外", my.getName(), ErrInvalidValue, notIn))
                                        }</span>, cast.ToString(value))
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "size") </span><span class="cov0" title="0">{
                                if size = getRuleIntSize(my.VRuleTags[idx]); size != nil </span><span class="cov0" title="0">{
                                        if cast.ToInt(value) != *size </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：= %d", my.getName(), ErrInvalidLength, *size))
                                        }</span>
                                }
                        }
                }

                <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "ex") </span><span class="cov0" title="0">{
                        if exFnNames := getRuleExFnNames(my.VRuleTags[idx]); len(exFnNames) &gt; 0 </span><span class="cov0" title="0">{
                                for idx2 := range exFnNames </span><span class="cov0" title="0">{
                                        if fn := APP.Validator.Ins().GetExFn(exFnNames[idx2]); fn != nil </span><span class="cov0" title="0">{
                                                if err := fn(value); err != nil </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, err)
                                                }</span>
                                        }
                                }
                        }
                }
        }

        <span class="cov0" title="0">return my</span>
}
</pre>
		
		<pre class="file" id="file101" style="display: none">package validatorV3

import (
        "fmt"
        "strings"

        "github.com/aid297/aid/array/anyArrayV2"
)

// checkSlice 检查数组、切片，支持：required、[array|slice|a|s]、min&gt;、min&gt;=、max&lt;、max&lt;=、size:
func (my FieldInfo) checkSlice() FieldInfo <span class="cov0" title="0">{
        var (
                rules          = anyArrayV2.NewList(my.VRuleTags)
                ruleType       = my.getRuleType(rules)
                min, max, size *int
                include        bool
                value          []any
                ok             bool
        )

        if value, ok = my.Value.([]any); !ok </span><span class="cov0" title="0">{
                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：数组", my.getName(), ErrInvalidType))
                return my
        }</span>

        <span class="cov0" title="0">if getRuleRequired(rules) &amp;&amp; my.IsPtr &amp;&amp; my.IsNil </span><span class="cov0" title="0">{
                my.wrongs = []error{fmt.Errorf("[%s] %w", my.getName(), ErrRequired)}
                return my
        }</span>

        <span class="cov0" title="0">for idx := range my.VRuleTags </span><span class="cov0" title="0">{
                switch ruleType </span>{
                case "", "array", "slice", "a", "s":<span class="cov0" title="0">
                        if strings.HasPrefix(my.VRuleTags[idx], "min") </span><span class="cov0" title="0">{
                                if min, include = getRuleIntMin(my.VRuleTags[idx]); min != nil </span><span class="cov0" title="0">{
                                        if include </span><span class="cov0" title="0">{
                                                if !(len(value) &gt;= *min) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&gt;= %d", my.getName(), ErrInvalidLength, *min))
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                if !(len(value) &gt; *min) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&gt; %d", my.getName(), ErrInvalidLength, *min))
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "max") </span><span class="cov0" title="0">{
                                if max, include = getRuleIntMax(my.VRuleTags[idx]); max != nil </span><span class="cov0" title="0">{
                                        if include </span><span class="cov0" title="0">{
                                                if !(len(value) &lt;= *max) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&lt;= %d", my.getName(), ErrInvalidLength, *max))
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                if !(len(value) &lt; *max) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&lt; %d", my.getName(), ErrInvalidLength, *max))
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "size") </span><span class="cov0" title="0">{
                                if size = getRuleIntSize(my.VRuleTags[idx]); size != nil </span><span class="cov0" title="0">{
                                        if len(value) != *size </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：= %d", my.getName(), ErrInvalidLength, *size))
                                        }</span>
                                }
                        }
                }

                <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "ex") </span><span class="cov0" title="0">{
                        if exFnNames := getRuleExFnNames(my.VRuleTags[idx]); len(exFnNames) &gt; 0 </span><span class="cov0" title="0">{
                                for idx2 := range exFnNames </span><span class="cov0" title="0">{
                                        if fn := APP.Validator.Ins().GetExFn(exFnNames[idx2]); fn != nil </span><span class="cov0" title="0">{
                                                if err := fn(value); err != nil </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, err)
                                                }</span>
                                        }
                                }
                        }
                }
        }

        <span class="cov0" title="0">return my</span>
}
</pre>
		
		<pre class="file" id="file102" style="display: none">package validatorV3

import (
        "fmt"
        "regexp"
        "strings"
        "unicode/utf8"

        "github.com/aid297/aid/array/anyArrayV2"
)

var (
        patternsForTimeString = map[string]string{
                "RFC3339":           `^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?(Z|[+\-]\d{2}:\d{2})$`,
                "RFC3339Nano":       `^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d+(Z|[+\-]\d{2}:\d{2})$`,
                "DateTime":          `^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$`,
                "DateOnly":          `^\d{4}-\d{2}-\d{2}$`,
                "TimeOnly":          `^\d{2}:\d{2}:\d{2}$`,
                "ReferenceLayout":   `^\d{2}/\d{2} \d{2}:\d{2}:\d{2}(AM|PM) '\d{2} [+\-]\d{4}$`,
                "ANSIC":             `^[A-Za-z]{3} [A-Za-z]{3} [ \d]\d \d{2}:\d{2}:\d{2} \d{4}$`,
                "UnixDate":          `^[A-Za-z]{3} [A-Za-z]{3} [ \d]\d \d{2}:\d{2}:\d{2} [A-Za-z]{3,4} \d{4}$`,
                "RubyDate":          `^[A-Za-z]{3} [A-Za-z]{3} \d{2} \d{2}:\d{2}:\d{2} [+\-]\d{4} \d{4}$`,
                "RFC822":            `^\d{2} [A-Za-z]{3} \d{2} \d{2}:\d{2} [A-Za-z]{3}$`,
                "RFC822Z":           `^\d{2} [A-Za-z]{3} \d{2} \d{2}:\d{2} [+\-]\d{4}$`,
                "RFC850":            `^[A-Za-z]+, \d{2}-[A-Za-z]{3}-\d{2} \d{2}:\d{2}:\d{2} [A-Za-z]{3}$`,
                "RFC1123":           `^[A-Za-z]{3}, \d{2} [A-Za-z]{3} \d{4} \d{2}:\d{2}:\d{2} [A-Za-z]{3}$`,
                "RFC1123Z":          `^[A-Za-z]{3}, \d{2} [A-Za-z]{3} \d{4} \d{2}:\d{2}:\d{2} [+\-]\d{4}$`,
                "Kitchen":           `^\d{1,2}:\d{2}(AM|PM)$`,
                "Stamp":             `^[A-Za-z]{3} [ \d]\d \d{2}:\d{2}:\d{2}$`,
                "StampMilli":        `^[A-Za-z]{3} [ \d]\d \d{2}:\d{2}:\d{2}\.\d{3}$`,
                "StampMicro":        `^[A-Za-z]{3} [ \d]\d \d{2}:\d{2}:\d{2}\.\d{6}$`,
                "StampNano":         `^[A-Za-z]{3} [ \d]\d \d{2}:\d{2}:\d{2}\.\d{9}$`,
                "SonarQubeDatetime": `^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|[+-]\d{2}:?\d{2})$`,
        }
)

// checkString 检查字符串，支持：required、[string|datetime|date|time]、min&gt;、min&gt;=、max&lt;、max&lt;=、in、not-in、size:
func (my FieldInfo) checkString() FieldInfo <span class="cov8" title="1">{
        var (
                rules          = anyArrayV2.NewList(my.VRuleTags)
                ruleType       = my.getRuleType(rules)
                min, max, size *int
                include        bool
                in             []string
                notIn          []string
                value          string
                ok             bool
        )

        if value, ok = my.Value.(string); !ok </span><span class="cov8" title="1">{
                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：字符串", my.getName(), ErrInvalidType))
                return my
        }</span>

        <span class="cov8" title="1">if getRuleRequired(rules) &amp;&amp; my.IsPtr &amp;&amp; my.IsNil </span><span class="cov0" title="0">{
                my.wrongs = []error{fmt.Errorf("[%s] %w", my.getName(), ErrRequired)}
                return my
        }</span>

        <span class="cov8" title="1">for idx := range my.VRuleTags </span><span class="cov8" title="1">{
                switch ruleType </span>{
                case "", "string":<span class="cov8" title="1">
                        if strings.HasPrefix(my.VRuleTags[idx], "min") </span><span class="cov0" title="0">{
                                if min, include = getRuleIntMin(my.VRuleTags[idx]); min != nil </span><span class="cov0" title="0">{
                                        if include </span><span class="cov0" title="0">{
                                                if !(utf8.RuneCountInString(value) &gt;= *min) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&gt;= %d", my.getName(), ErrInvalidLength, *min))
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                if !(utf8.RuneCountInString(value) &gt; *min) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&gt; %d", my.getName(), ErrInvalidLength, *min))
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov8" title="1">if strings.HasPrefix(my.VRuleTags[idx], "max") </span><span class="cov0" title="0">{
                                if max, include = getRuleIntMax(my.VRuleTags[idx]); max != nil </span><span class="cov0" title="0">{
                                        if include </span><span class="cov0" title="0">{
                                                if !(utf8.RuneCountInString(value) &lt;= *max) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&lt;= %d", my.getName(), ErrInvalidLength, *max))
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                if !(utf8.RuneCountInString(value) &lt; *max) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&lt; %d", my.getName(), ErrInvalidLength, *max))
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov8" title="1">if strings.HasPrefix(my.VRuleTags[idx], "in") </span><span class="cov0" title="0">{
                                if in = getRuleIn(my.VRuleTags[idx]); len(in) &gt; 0 </span><span class="cov0" title="0">{
                                        anyArrayV2.NewList(in).IfNotIn(func() </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：在 %v 之中", my.getName(), ErrInvalidValue, in))
                                        }</span>, value)
                                }
                        }
                        <span class="cov8" title="1">if strings.HasPrefix(my.VRuleTags[idx], "not-in") </span><span class="cov0" title="0">{
                                if notIn = getRuleNotIn(my.VRuleTags[idx]); len(notIn) &gt; 0 </span><span class="cov0" title="0">{
                                        anyArrayV2.NewList(notIn).IfIn(func() </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：在 %v 之外", my.getName(), ErrInvalidValue, notIn))
                                        }</span>, value)
                                }
                        }
                        <span class="cov8" title="1">if strings.HasPrefix(my.VRuleTags[idx], "size") </span><span class="cov0" title="0">{
                                if size = getRuleIntSize(my.VRuleTags[idx]); size != nil </span><span class="cov0" title="0">{
                                        if len(value) != *size </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：= %d", my.getName(), ErrInvalidLength, *size))
                                        }</span>
                                }
                        }
                case "bool":<span class="cov0" title="0">
                        var def = []string{"true", "True", "t", "yes", "on", "ok", "1", "false", "False", "f", "off", "no", "0"}
                        if strings.HasPrefix(my.VRuleTags[idx], "in") </span><span class="cov0" title="0">{
                                if in = getRuleIn(my.VRuleTags[idx]); len(in) &gt; 0 </span><span class="cov0" title="0">{
                                        anyArrayV2.NewList(in).IfNotIn(func() </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：在 %v 之中", my.getName(), ErrInvalidValue, in))
                                        }</span>, value)
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "not-in") </span><span class="cov0" title="0">{
                                if notIn = getRuleNotIn(my.VRuleTags[idx]); len(notIn) &gt; 0 </span><span class="cov0" title="0">{
                                        anyArrayV2.NewList(notIn).IfIn(func() </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：在 %v 之外", my.getName(), ErrInvalidValue, notIn))
                                        }</span>, value)
                                }
                        }
                        <span class="cov0" title="0">if len(in) == 0 &amp;&amp; len(notIn) == 0 </span><span class="cov0" title="0">{
                                anyArrayV2.NewList(def).IfNotIn(func() </span><span class="cov0" title="0">{
                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：在 %v 之外", my.getName(), ErrInvalidValue, def))
                                }</span>, value)
                        }
                case "datetime":<span class="cov0" title="0">
                        ok = false
                        for _, key := range []string{"RFC3339", "RFC3339Nano", "DateTime", "ReferenceLayout", "ANSIC", "UnixDate", "RubyDate", "RFC822", "RFC822Z", "RFC850", "RFC1123", "RFC1123Z", "Kitchen", "Stamp", "StampMilli", "StampMicro", "StampNano", "SonarQubeDatetime"} </span><span class="cov0" title="0">{
                                if regexp.MustCompile(patternsForTimeString[key]).MatchString(value) </span><span class="cov0" title="0">{
                                        ok = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w", my.getName(), ErrInvalidFormat))
                        }</span>
                case "date":<span class="cov0" title="0">
                        if !regexp.MustCompile(patternsForTimeString["DateOnly"]).MatchString(value) </span><span class="cov0" title="0">{
                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w", my.getName(), ErrInvalidFormat))
                        }</span>
                case "time":<span class="cov0" title="0">
                        if !regexp.MustCompile(patternsForTimeString["TimeOnly"]).MatchString(value) </span><span class="cov0" title="0">{
                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w", my.getName(), ErrInvalidFormat))
                        }</span>
                }

                <span class="cov8" title="1">if strings.HasPrefix(my.VRuleTags[idx], "ex") </span><span class="cov0" title="0">{
                        if exFnNames := getRuleExFnNames(my.VRuleTags[idx]); len(exFnNames) &gt; 0 </span><span class="cov0" title="0">{
                                for idx2 := range exFnNames </span><span class="cov0" title="0">{
                                        if fn := APP.Validator.Ins().GetExFn(exFnNames[idx2]); fn != nil </span><span class="cov0" title="0">{
                                                if err := fn(value); err != nil </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, err)
                                                }</span>
                                        }
                                }
                        }
                }
        }

        <span class="cov8" title="1">return my</span>
}
</pre>
		
		<pre class="file" id="file103" style="display: none">package validatorV3

import (
        "fmt"
        "reflect"
        "strings"
        "time"

        "github.com/aid297/aid/array/anyArrayV2"
)

// checkString 检查字符串，支持：required、[datetime]、min&gt;、min&gt;=、max&lt;、max&lt;=、in、not-in、size:
func (my FieldInfo) checkTime() FieldInfo <span class="cov0" title="0">{
        if getRuleRequired(anyArrayV2.NewList(my.VRuleTags)) &amp;&amp; my.IsPtr &amp;&amp; my.IsNil </span><span class="cov0" title="0">{
                my.wrongs = []error{fmt.Errorf("[%s] %w", my.getName(), ErrRequired)}
                return my
        }</span>

        <span class="cov0" title="0">switch my.Value.(type) </span>{
        case time.Time:<span class="cov0" title="0">
                v := reflect.ValueOf(my.Value)
                if !v.IsZero() </span><span class="cov0" title="0">{
                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：时间类型", my.getName(), ErrInvalidType))
                }</span>
        }

        <span class="cov0" title="0">for idx := range my.VRuleTags </span><span class="cov0" title="0">{
                if strings.HasPrefix(my.VRuleTags[idx], "ex") </span><span class="cov0" title="0">{
                        if exFnNames := getRuleExFnNames(my.VRuleTags[idx]); len(exFnNames) &gt; 0 </span><span class="cov0" title="0">{
                                for idx2 := range exFnNames </span><span class="cov0" title="0">{
                                        if fn := APP.Validator.Ins().GetExFn(exFnNames[idx2]); fn != nil </span><span class="cov0" title="0">{
                                                if err := fn(my.Value); err != nil </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, err)
                                                }</span>
                                        }
                                }
                        }
                }
        }

        <span class="cov0" title="0">return my</span>
}
</pre>
		
		<pre class="file" id="file104" style="display: none">package validatorV3

import (
        "fmt"
        "strings"

        "github.com/spf13/cast"

        "github.com/aid297/aid/array/anyArrayV2"
)

// checkUint 检查正整数，支持：required、[uint|u]、min&gt;、min&gt;=、max&lt;、max&lt;=、in、not-in、size:
func (my FieldInfo) checkUint() FieldInfo <span class="cov0" title="0">{
        var (
                rules          = anyArrayV2.NewList(my.VRuleTags)
                ruleType       = my.getRuleType(rules)
                min, max, size *int
                include        bool
                in             []string
                notIn          []string
                value          uint
                ok             bool
        )

        if value, ok = my.Value.(uint); !ok </span><span class="cov0" title="0">{
                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：正整数", my.getName(), ErrInvalidType))
                return my
        }</span>

        <span class="cov0" title="0">if getRuleRequired(rules) &amp;&amp; my.IsPtr &amp;&amp; my.IsNil </span><span class="cov0" title="0">{
                my.wrongs = []error{fmt.Errorf("[%s] %w", my.getName(), ErrRequired)}
                return my
        }</span>

        <span class="cov0" title="0">for idx := range my.VRuleTags </span><span class="cov0" title="0">{
                switch ruleType </span>{
                case "", "uint", "u":<span class="cov0" title="0">
                        if strings.HasPrefix(my.VRuleTags[idx], "min") </span><span class="cov0" title="0">{
                                if min, include = getRuleIntMin(my.VRuleTags[idx]); min != nil </span><span class="cov0" title="0">{
                                        if include </span><span class="cov0" title="0">{
                                                if !(cast.ToInt(value) &gt;= *min) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&gt;= %d", my.getName(), ErrInvalidLength, *min))
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                if !(cast.ToInt(value) &gt; *min) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&gt; %d", my.getName(), ErrInvalidLength, *min))
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "max") </span><span class="cov0" title="0">{
                                if max, include = getRuleIntMax(my.VRuleTags[idx]); max != nil </span><span class="cov0" title="0">{
                                        if include </span><span class="cov0" title="0">{
                                                if !(cast.ToInt(value) &lt;= *max) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&lt;= %d", my.getName(), ErrInvalidLength, *max))
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                if !(cast.ToInt(value) &lt; *max) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&lt; %d", my.getName(), ErrInvalidLength, *max))
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "in") </span><span class="cov0" title="0">{
                                if in = getRuleIn(my.VRuleTags[idx]); len(in) &gt; 0 </span><span class="cov0" title="0">{
                                        anyArrayV2.NewList(in).IfNotIn(func() </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：在 %v 之中", my.getName(), ErrInvalidValue, in))
                                        }</span>, cast.ToString(value))
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "not-in") </span><span class="cov0" title="0">{
                                if notIn = getRuleNotIn(my.VRuleTags[idx]); len(notIn) &gt; 0 </span><span class="cov0" title="0">{
                                        anyArrayV2.NewList(notIn).IfIn(func() </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：在 %v 之外", my.getName(), ErrInvalidValue, notIn))
                                        }</span>, cast.ToString(value))
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "size") </span><span class="cov0" title="0">{
                                if size = getRuleIntSize(my.VRuleTags[idx]); size != nil </span><span class="cov0" title="0">{
                                        if cast.ToInt(value) != *size </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：= %d", my.getName(), ErrInvalidLength, *size))
                                        }</span>
                                }
                        }
                }

                <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "ex") </span><span class="cov0" title="0">{
                        if exFnNames := getRuleExFnNames(my.VRuleTags[idx]); len(exFnNames) &gt; 0 </span><span class="cov0" title="0">{
                                for idx2 := range exFnNames </span><span class="cov0" title="0">{
                                        if fn := APP.Validator.Ins().GetExFn(exFnNames[idx2]); fn != nil </span><span class="cov0" title="0">{
                                                if err := fn(value); err != nil </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, err)
                                                }</span>
                                        }
                                }
                        }
                }
        }

        <span class="cov0" title="0">return my</span>
}

// checkUint8 检查正整数#8位，支持：required、[uint8|u8]、min&gt;、min&gt;=、max&lt;、max&lt;=、in、not-in、size:
func (my FieldInfo) checkUint8() FieldInfo <span class="cov0" title="0">{
        var (
                rules          = anyArrayV2.NewList(my.VRuleTags)
                ruleType       = my.getRuleType(rules)
                min, max, size *int
                include        bool
                in             []string
                notIn          []string
                value          uint8
                ok             bool
        )

        if value, ok = my.Value.(uint8); !ok </span><span class="cov0" title="0">{
                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：正整数#8位", my.getName(), ErrInvalidType))
                return my
        }</span>

        <span class="cov0" title="0">if getRuleRequired(rules) &amp;&amp; my.IsPtr &amp;&amp; my.IsNil </span><span class="cov0" title="0">{
                my.wrongs = []error{fmt.Errorf("[%s] %w", my.getName(), ErrRequired)}
                return my
        }</span>

        <span class="cov0" title="0">for idx := range my.VRuleTags </span><span class="cov0" title="0">{
                switch ruleType </span>{
                case "", "uint8", "u8":<span class="cov0" title="0">
                        if strings.HasPrefix(my.VRuleTags[idx], "min") </span><span class="cov0" title="0">{
                                if min, include = getRuleIntMin(my.VRuleTags[idx]); min != nil </span><span class="cov0" title="0">{
                                        if include </span><span class="cov0" title="0">{
                                                if !(cast.ToInt(value) &gt;= *min) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&gt;= %d", my.getName(), ErrInvalidLength, *min))
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                if !(cast.ToInt(value) &gt; *min) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&gt; %d", my.getName(), ErrInvalidLength, *min))
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "max") </span><span class="cov0" title="0">{
                                if max, include = getRuleIntMax(my.VRuleTags[idx]); max != nil </span><span class="cov0" title="0">{
                                        if include </span><span class="cov0" title="0">{
                                                if !(cast.ToInt(value) &lt;= *max) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&lt;= %d", my.getName(), ErrInvalidLength, *max))
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                if !(cast.ToInt(value) &lt; *max) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&lt; %d", my.getName(), ErrInvalidLength, *max))
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "in") </span><span class="cov0" title="0">{
                                if in = getRuleIn(my.VRuleTags[idx]); len(in) &gt; 0 </span><span class="cov0" title="0">{
                                        anyArrayV2.NewList(in).IfNotIn(func() </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：在 %v 之中", my.getName(), ErrInvalidValue, in))
                                        }</span>, cast.ToString(value))
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "not-in") </span><span class="cov0" title="0">{
                                if notIn = getRuleNotIn(my.VRuleTags[idx]); len(notIn) &gt; 0 </span><span class="cov0" title="0">{
                                        anyArrayV2.NewList(notIn).IfIn(func() </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：在 %v 之外", my.getName(), ErrInvalidValue, notIn))
                                        }</span>, cast.ToString(value))
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "size") </span><span class="cov0" title="0">{
                                if size = getRuleIntSize(my.VRuleTags[idx]); size != nil </span><span class="cov0" title="0">{
                                        if cast.ToInt(value) != *size </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：= %d", my.getName(), ErrInvalidLength, *size))
                                        }</span>
                                }
                        }
                }

                <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "ex") </span><span class="cov0" title="0">{
                        if exFnNames := getRuleExFnNames(my.VRuleTags[idx]); len(exFnNames) &gt; 0 </span><span class="cov0" title="0">{
                                for idx2 := range exFnNames </span><span class="cov0" title="0">{
                                        if fn := APP.Validator.Ins().GetExFn(exFnNames[idx2]); fn != nil </span><span class="cov0" title="0">{
                                                if err := fn(value); err != nil </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, err)
                                                }</span>
                                        }
                                }
                        }
                }
        }

        <span class="cov0" title="0">return my</span>
}

// checkUint16 检查正整数#16位，支持：required、[uint16|u16]、min&gt;、min&gt;=、max&lt;、max&lt;=、in、not-in、size:
func (my FieldInfo) checkUint16() FieldInfo <span class="cov0" title="0">{
        var (
                rules          = anyArrayV2.NewList(my.VRuleTags)
                ruleType       = my.getRuleType(rules)
                min, max, size *int
                include        bool
                in             []string
                notIn          []string
                value          uint16
                ok             bool
        )

        if value, ok = my.Value.(uint16); !ok </span><span class="cov0" title="0">{
                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：正整数#16位", my.getName(), ErrInvalidType))
                return my
        }</span>

        <span class="cov0" title="0">if getRuleRequired(rules) &amp;&amp; my.IsPtr &amp;&amp; my.IsNil </span><span class="cov0" title="0">{
                my.wrongs = []error{fmt.Errorf("[%s] %w", my.getName(), ErrRequired)}
                return my
        }</span>

        <span class="cov0" title="0">for idx := range my.VRuleTags </span><span class="cov0" title="0">{
                switch ruleType </span>{
                case "", "uint16", "u16":<span class="cov0" title="0">
                        if strings.HasPrefix(my.VRuleTags[idx], "min") </span><span class="cov0" title="0">{
                                if min, include = getRuleIntMin(my.VRuleTags[idx]); min != nil </span><span class="cov0" title="0">{
                                        if include </span><span class="cov0" title="0">{
                                                if !(cast.ToInt(value) &gt;= *min) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&gt;= %d", my.getName(), ErrInvalidLength, *min))
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                if !(cast.ToInt(value) &gt; *min) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&gt; %d", my.getName(), ErrInvalidLength, *min))
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "max") </span><span class="cov0" title="0">{
                                if max, include = getRuleIntMax(my.VRuleTags[idx]); max != nil </span><span class="cov0" title="0">{
                                        if include </span><span class="cov0" title="0">{
                                                if !(cast.ToInt(value) &lt;= *max) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&lt;= %d", my.getName(), ErrInvalidLength, *max))
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                if !(cast.ToInt(value) &lt; *max) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&lt; %d", my.getName(), ErrInvalidLength, *max))
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "in") </span><span class="cov0" title="0">{
                                if in = getRuleIn(my.VRuleTags[idx]); len(in) &gt; 0 </span><span class="cov0" title="0">{
                                        anyArrayV2.NewList(in).IfNotIn(func() </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：在 %v 之中", my.getName(), ErrInvalidValue, in))
                                        }</span>, cast.ToString(value))
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "not-in") </span><span class="cov0" title="0">{
                                if notIn = getRuleNotIn(my.VRuleTags[idx]); len(notIn) &gt; 0 </span><span class="cov0" title="0">{
                                        anyArrayV2.NewList(notIn).IfIn(func() </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：在 %v 之外", my.getName(), ErrInvalidValue, notIn))
                                        }</span>, cast.ToString(value))
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "size") </span><span class="cov0" title="0">{
                                if size = getRuleIntSize(my.VRuleTags[idx]); size != nil </span><span class="cov0" title="0">{
                                        if cast.ToInt(value) != *size </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：= %d", my.getName(), ErrInvalidLength, *size))
                                        }</span>
                                }
                        }
                }

                <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "ex") </span><span class="cov0" title="0">{
                        if exFnNames := getRuleExFnNames(my.VRuleTags[idx]); len(exFnNames) &gt; 0 </span><span class="cov0" title="0">{
                                for idx2 := range exFnNames </span><span class="cov0" title="0">{
                                        if fn := APP.Validator.Ins().GetExFn(exFnNames[idx2]); fn != nil </span><span class="cov0" title="0">{
                                                if err := fn(value); err != nil </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, err)
                                                }</span>
                                        }
                                }
                        }
                }
        }

        <span class="cov0" title="0">return my</span>
}

// checkUint32 检查正整数#32位，支持：required、[uint32|u32]、min&gt;、min&gt;=、max&lt;、max&lt;=、in、not-in、size:
func (my FieldInfo) checkUint32() FieldInfo <span class="cov0" title="0">{
        var (
                rules          = anyArrayV2.NewList(my.VRuleTags)
                ruleType       = my.getRuleType(rules)
                min, max, size *int
                include        bool
                in             []string
                notIn          []string
                value          uint32
                ok             bool
        )

        if value, ok = my.Value.(uint32); !ok </span><span class="cov0" title="0">{
                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：正整数#32位", my.getName(), ErrInvalidType))
                return my
        }</span>

        <span class="cov0" title="0">if getRuleRequired(rules) &amp;&amp; my.IsPtr &amp;&amp; my.IsNil </span><span class="cov0" title="0">{
                my.wrongs = []error{fmt.Errorf("[%s] %w", my.getName(), ErrRequired)}
                return my
        }</span>

        <span class="cov0" title="0">for idx := range my.VRuleTags </span><span class="cov0" title="0">{
                switch ruleType </span>{
                case "", "uint32", "u32":<span class="cov0" title="0">
                        if strings.HasPrefix(my.VRuleTags[idx], "min") </span><span class="cov0" title="0">{
                                if min, include = getRuleIntMin(my.VRuleTags[idx]); min != nil </span><span class="cov0" title="0">{
                                        if include </span><span class="cov0" title="0">{
                                                if !(cast.ToInt(value) &gt;= *min) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&gt;= %d", my.getName(), ErrInvalidLength, *min))
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                if !(cast.ToInt(value) &gt; *min) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&gt; %d", my.getName(), ErrInvalidLength, *min))
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "max") </span><span class="cov0" title="0">{
                                if max, include = getRuleIntMax(my.VRuleTags[idx]); max != nil </span><span class="cov0" title="0">{
                                        if include </span><span class="cov0" title="0">{
                                                if !(cast.ToInt(value) &lt;= *max) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&lt;= %d", my.getName(), ErrInvalidLength, *max))
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                if !(cast.ToInt(value) &lt; *max) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&lt; %d", my.getName(), ErrInvalidLength, *max))
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "in") </span><span class="cov0" title="0">{
                                if in = getRuleIn(my.VRuleTags[idx]); len(in) &gt; 0 </span><span class="cov0" title="0">{
                                        anyArrayV2.NewList(in).IfNotIn(func() </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：在 %v 之中", my.getName(), ErrInvalidValue, in))
                                        }</span>, cast.ToString(value))
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "not-in") </span><span class="cov0" title="0">{
                                if notIn = getRuleNotIn(my.VRuleTags[idx]); len(notIn) &gt; 0 </span><span class="cov0" title="0">{
                                        anyArrayV2.NewList(notIn).IfIn(func() </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：在 %v 之外", my.getName(), ErrInvalidValue, notIn))
                                        }</span>, cast.ToString(value))
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "size") </span><span class="cov0" title="0">{
                                if size = getRuleIntSize(my.VRuleTags[idx]); size != nil </span><span class="cov0" title="0">{
                                        if cast.ToInt(value) != *size </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：= %d", my.getName(), ErrInvalidLength, *size))
                                        }</span>
                                }
                        }
                }

                <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "ex") </span><span class="cov0" title="0">{
                        if exFnNames := getRuleExFnNames(my.VRuleTags[idx]); len(exFnNames) &gt; 0 </span><span class="cov0" title="0">{
                                for idx2 := range exFnNames </span><span class="cov0" title="0">{
                                        if fn := APP.Validator.Ins().GetExFn(exFnNames[idx2]); fn != nil </span><span class="cov0" title="0">{
                                                if err := fn(value); err != nil </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, err)
                                                }</span>
                                        }
                                }
                        }
                }
        }

        <span class="cov0" title="0">return my</span>
}

// checkUint64 检查正整数#64位，支持：required、[uint64|u64]、min&gt;、min&gt;=、max&lt;、max&lt;=、in、not-in、size:
func (my FieldInfo) checkUint64() FieldInfo <span class="cov0" title="0">{
        var (
                rules          = anyArrayV2.NewList(my.VRuleTags)
                ruleType       = my.getRuleType(rules)
                min, max, size *int
                include        bool
                in             []string
                notIn          []string
                value          uint64
                ok             bool
        )

        if value, ok = my.Value.(uint64); !ok </span><span class="cov0" title="0">{
                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：正整数#64位", my.getName(), ErrInvalidType))
                return my
        }</span>

        <span class="cov0" title="0">if getRuleRequired(rules) &amp;&amp; my.IsPtr &amp;&amp; my.IsNil </span><span class="cov0" title="0">{
                my.wrongs = []error{fmt.Errorf("[%s] %w", my.getName(), ErrRequired)}
                return my
        }</span>

        <span class="cov0" title="0">for idx := range my.VRuleTags </span><span class="cov0" title="0">{
                switch ruleType </span>{
                case "", "unt64", "u64":<span class="cov0" title="0">
                        if strings.HasPrefix(my.VRuleTags[idx], "min") </span><span class="cov0" title="0">{
                                if min, include = getRuleIntMin(my.VRuleTags[idx]); min != nil </span><span class="cov0" title="0">{
                                        if include </span><span class="cov0" title="0">{
                                                if !(cast.ToInt(value) &gt;= *min) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&gt;= %d", my.getName(), ErrInvalidLength, *min))
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                if !(cast.ToInt(value) &gt; *min) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&gt; %d", my.getName(), ErrInvalidLength, *min))
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "max") </span><span class="cov0" title="0">{
                                if max, include = getRuleIntMax(my.VRuleTags[idx]); max != nil </span><span class="cov0" title="0">{
                                        if include </span><span class="cov0" title="0">{
                                                if !(cast.ToInt(value) &lt;= *max) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&lt;= %d", my.getName(), ErrInvalidLength, *max))
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                if !(cast.ToInt(value) &lt; *max) </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：&lt; %d", my.getName(), ErrInvalidLength, *max))
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "in") </span><span class="cov0" title="0">{
                                if in = getRuleIn(my.VRuleTags[idx]); len(in) &gt; 0 </span><span class="cov0" title="0">{
                                        anyArrayV2.NewList(in).IfNotIn(func() </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：在 %v 之中", my.getName(), ErrInvalidValue, in))
                                        }</span>, cast.ToString(value))
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "not-in") </span><span class="cov0" title="0">{
                                if notIn = getRuleNotIn(my.VRuleTags[idx]); len(notIn) &gt; 0 </span><span class="cov0" title="0">{
                                        anyArrayV2.NewList(notIn).IfIn(func() </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：在 %v 之外", my.getName(), ErrInvalidValue, notIn))
                                        }</span>, cast.ToString(value))
                                }
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "size") </span><span class="cov0" title="0">{
                                if size = getRuleIntSize(my.VRuleTags[idx]); size != nil </span><span class="cov0" title="0">{
                                        if cast.ToInt(value) != *size </span><span class="cov0" title="0">{
                                                my.wrongs = append(my.wrongs, fmt.Errorf("[%s] %w 期望：= %d", my.getName(), ErrInvalidLength, *size))
                                        }</span>
                                }
                        }
                }

                <span class="cov0" title="0">if strings.HasPrefix(my.VRuleTags[idx], "ex") </span><span class="cov0" title="0">{
                        if exFnNames := getRuleExFnNames(my.VRuleTags[idx]); len(exFnNames) &gt; 0 </span><span class="cov0" title="0">{
                                for idx2 := range exFnNames </span><span class="cov0" title="0">{
                                        if fn := APP.Validator.Ins().GetExFn(exFnNames[idx2]); fn != nil </span><span class="cov0" title="0">{
                                                if err := fn(value); err != nil </span><span class="cov0" title="0">{
                                                        my.wrongs = append(my.wrongs, err)
                                                }</span>
                                        }
                                }
                        }
                }
        }

        <span class="cov0" title="0">return my</span>
}
</pre>
		
		<pre class="file" id="file105" style="display: none">package validatorV3

import (
        "errors"
        "fmt"
        "reflect"
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/gofiber/fiber/v2"

        "github.com/aid297/aid/array/anyArrayV2"
        "github.com/aid297/aid/operation/operationV2"
        "github.com/aid297/aid/str"
)

// Checker 验证器
type Checker struct {
        data   any
        wrongs []error
}

func (Checker) New(data any) Checker <span class="cov8" title="1">{ return Checker{data: data} }</span>

func (my Checker) Wrongs() []error <span class="cov8" title="1">{ return my.wrongs }</span>

func (my Checker) Wrong() error <span class="cov0" title="0">{
        return operationV2.NewTernary(operationV2.TrueFn(func() error </span><span class="cov0" title="0">{ return errors.New(my.WrongToString()) }</span>)).GetByValue(len(my.wrongs) &gt; 0)
}

func (my Checker) WrongToString() string <span class="cov0" title="0">{
        var errs = make([]string, 0, len(my.wrongs))

        for idx := range my.wrongs </span><span class="cov0" title="0">{
                errs = append(errs, my.wrongs[idx].Error())
        }</span>

        <span class="cov0" title="0">return str.APP.Buffer.JoinStringLimit("；", errs...)</span>
}

func (my Checker) Validate(exCheckFns ...any) Checker <span class="cov8" title="1">{
        fieldInfos := getStructFieldInfos(my.data, "")
        for idx := range fieldInfos </span><span class="cov8" title="1">{
                if wrongs := fieldInfos[idx].Check().Wrongs(); len(wrongs) &gt; 0 </span><span class="cov8" title="1">{
                        my.wrongs = append(my.wrongs, wrongs...)
                }</span>
        }

        <span class="cov8" title="1">if len(my.wrongs) == 0 </span><span class="cov8" title="1">{
                for idx := range exCheckFns </span><span class="cov8" title="1">{
                        if err := callExCheckFn(exCheckFns[idx], my.data); err != nil </span><span class="cov0" title="0">{
                                my.wrongs = append(my.wrongs, err)
                        }</span>
                }
        }

        <span class="cov8" title="1">return my</span>
}

func WithGin[T any](c *gin.Context, exCheckFns ...any) (T, Checker) <span class="cov0" title="0">{
        var (
                zero T
                form = new(T)
        )

        if err := c.ShouldBind(&amp;form); err != nil </span><span class="cov0" title="0">{
                return zero, Checker{wrongs: []error{err}}
        }</span>

        <span class="cov0" title="0">return *form, Checker{}.New(form).Validate(exCheckFns...)</span>
}

func WithFiber[T any](c *fiber.Ctx, exCheckFns ...any) (T, Checker) <span class="cov0" title="0">{
        var (
                zero T
                form = new(T)
        )

        if err := c.BodyParser(&amp;form); err != nil </span><span class="cov0" title="0">{
                return zero, Checker{wrongs: []error{err}}
        }</span>

        <span class="cov0" title="0">return *form, Checker{}.New(form).Validate(exCheckFns)</span>
}

func callExCheckFn(fn any, data any) error <span class="cov8" title="1">{
        if fn == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("callback is nil")
        }</span>
        <span class="cov8" title="1">fv := reflect.ValueOf(fn)
        if fv.Kind() != reflect.Func </span><span class="cov0" title="0">{
                return fmt.Errorf("callback is not a function: %T", fn)
        }</span>
        <span class="cov8" title="1">ft := fv.Type()
        if ft.NumIn() != 1 || ft.NumOut() &lt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("callback must have signature func(T) error (or similar), got %s", ft.String())
        }</span>

        <span class="cov8" title="1">argType := ft.In(0)
        var dv reflect.Value
        if data == nil </span><span class="cov0" title="0">{
                dv = reflect.Zero(argType)
        }</span> else<span class="cov8" title="1"> {
                dv = reflect.ValueOf(data)
                // If direct assignable, OK. Otherwise try to adapt:
                if !dv.Type().AssignableTo(argType) </span><span class="cov0" title="0">{
                        // If function expects a pointer and we have a non-pointer of compatible element, take address.
                        if argType.Kind() == reflect.Ptr &amp;&amp; dv.Type().AssignableTo(argType.Elem()) </span><span class="cov0" title="0">{
                                addr := reflect.New(dv.Type())
                                addr.Elem().Set(dv)
                                dv = addr
                        }</span> else<span class="cov0" title="0"> if dv.Kind() == reflect.Ptr &amp;&amp; dv.Type().Elem().AssignableTo(argType) </span><span class="cov0" title="0">{
                                // If we have a pointer but function expects a value, dereference
                                dv = dv.Elem()
                        }</span> else<span class="cov0" title="0"> if dv.CanAddr() &amp;&amp; dv.Addr().Type().AssignableTo(argType) </span><span class="cov0" title="0">{
                                // If we have an addressable value and function expects that pointer type
                                dv = dv.Addr()
                        }</span> else<span class="cov0" title="0"> {
                                // last resort: try zero value of argType
                                dv = reflect.Zero(argType)
                        }</span>
                }
        }

        <span class="cov8" title="1">outs := fv.Call([]reflect.Value{dv})
        if len(outs) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">first := outs[0]
        if first.IsNil() </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov0" title="0">errIface := reflect.TypeOf((*error)(nil)).Elem()
        if !first.Type().Implements(errIface) </span><span class="cov0" title="0">{
                return fmt.Errorf("callback first return does not implement error: %s", first.Type().String())
        }</span>
        <span class="cov0" title="0">return first.Interface().(error)</span>
}

func getStructFieldInfos(s any, parentName string) []FieldInfo <span class="cov8" title="1">{
        v := reflect.ValueOf(s)
        t := v.Type()

        var infos []FieldInfo

        if t.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                v = v.Elem()
                t = v.Type()
        }</span>

        <span class="cov8" title="1">if t.Kind() == reflect.Struct </span><span class="cov8" title="1">{
                for i := 0; i &lt; t.NumField(); i++ </span><span class="cov8" title="1">{
                        field := t.Field(i)
                        fieldValue := v.Field(i)

                        // 获取 tags
                        vRuleTag := field.Tag.Get("v-rule")
                        vNameTag := field.Tag.Get("v-name")

                        if vNameTag == "" </span><span class="cov8" title="1">{
                                vNameTag = field.Name
                        }</span>

                        <span class="cov8" title="1">if vRuleTag == "" || vRuleTag == "-" </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">isPtr := fieldValue.Kind() == reflect.Ptr
                        isNil := isPtr &amp;&amp; fieldValue.IsNil()

                        // determine the element/type kind safely before dereferencing
                        var elemType reflect.Type
                        var elemKind reflect.Kind
                        if isPtr </span><span class="cov8" title="1">{
                                elemType = fieldValue.Type().Elem()
                                elemKind = elemType.Kind()
                        }</span> else<span class="cov8" title="1"> {
                                elemType = fieldValue.Type()
                                elemKind = elemType.Kind()
                        }</span>

                        <span class="cov8" title="1">var value any = nil
                        // only dereference if pointer and not nil, otherwise keep value as nil or the concrete value
                        if isPtr &amp;&amp; !isNil </span><span class="cov8" title="1">{
                                fieldValue = fieldValue.Elem()
                                value = fieldValue.Interface()
                        }</span> else<span class="cov8" title="1"> if !isPtr </span><span class="cov8" title="1">{
                                value = fieldValue.Interface()
                        }</span>

                        // If the declared/element kind is struct, recurse.
                        // For a nil pointer-to-struct, pass a zero value of the element type so reflection works.
                        <span class="cov8" title="1">if elemKind == reflect.Struct </span><span class="cov0" title="0">{
                                var recurseArg any
                                if isPtr &amp;&amp; isNil </span><span class="cov0" title="0">{
                                        recurseArg = reflect.Zero(elemType).Interface()
                                }</span> else<span class="cov0" title="0"> {
                                        recurseArg = value
                                }</span>
                                <span class="cov0" title="0">infos = append(infos, getStructFieldInfos(recurseArg, vNameTag)...)
                                continue</span>
                        }

                        <span class="cov8" title="1">vRuleTag = strings.TrimLeft(vRuleTag, "(")
                        vRuleTag = strings.TrimRight(vRuleTag, ")")

                        infos = append(infos, FieldInfo{
                                Name:      field.Name,
                                Value:     value,
                                Kind:      elemKind,
                                Type:      elemType,
                                IsPtr:     isPtr,
                                IsNil:     isNil,
                                VRuleTags: strings.Split(vRuleTag, ")("),
                                VNameTags: anyArrayV2.NewItems(parentName, vNameTag).RemoveEmpty().ToSlice(),
                        })</span>
                }
        }

        <span class="cov8" title="1">return infos</span>
}
</pre>
		
		<pre class="file" id="file106" style="display: none">package validatorV3

import (
        "reflect"
        "strings"
        "time"

        "github.com/spf13/cast"

        "github.com/aid297/aid/array/anyArrayV2"
        "github.com/aid297/aid/ptr"
)

type (
        // FieldInfo 保存了字段的相关信息。
        FieldInfo struct {
                Name      string // 字段名
                Value     any    // 实际值
                Kind      reflect.Kind
                Type      reflect.Type
                IsPtr     bool     // 是否是指针
                IsNil     bool     // 是否为空指针
                Required  bool     // 是否必填
                VRuleTags []string // v-rule tag 的值
                VNameTags []string // v-name tag 的值
                wrongs    []error
        }

        FieldRuleBase struct{ Required string }
        FieldRule     struct{ FieldRuleBase }
)

func (my FieldInfo) Wrongs() []error <span class="cov8" title="1">{ return my.wrongs }</span>

func (my FieldInfo) getName() string <span class="cov8" title="1">{ return strings.Join(my.VNameTags, ".") }</span>

func (my FieldInfo) getRuleType(rules anyArrayV2.AnyArray[string]) (targetType string) <span class="cov8" title="1">{
        // 获取目标类型
        rules.IfIn(func() </span><span class="cov0" title="0">{ targetType = "string" }</span>, "string")
        <span class="cov8" title="1">rules.IfIn(func() </span><span class="cov0" title="0">{ targetType = "datetime" }</span>, "datetime")
        <span class="cov8" title="1">rules.IfIn(func() </span><span class="cov0" title="0">{ targetType = "date" }</span>, "date")
        <span class="cov8" title="1">rules.IfIn(func() </span><span class="cov0" title="0">{ targetType = "time" }</span>, "time")
        <span class="cov8" title="1">rules.IfIn(func() </span><span class="cov0" title="0">{ targetType = "int" }</span>, "int")
        <span class="cov8" title="1">rules.IfIn(func() </span><span class="cov0" title="0">{ targetType = "int8" }</span>, "int8")
        <span class="cov8" title="1">rules.IfIn(func() </span><span class="cov0" title="0">{ targetType = "int16" }</span>, "int16")
        <span class="cov8" title="1">rules.IfIn(func() </span><span class="cov0" title="0">{ targetType = "int32" }</span>, "int32")
        <span class="cov8" title="1">rules.IfIn(func() </span><span class="cov0" title="0">{ targetType = "int64" }</span>, "int64")
        <span class="cov8" title="1">rules.IfIn(func() </span><span class="cov0" title="0">{ targetType = "uint" }</span>, "uint")
        <span class="cov8" title="1">rules.IfIn(func() </span><span class="cov0" title="0">{ targetType = "uint8" }</span>, "uint8")
        <span class="cov8" title="1">rules.IfIn(func() </span><span class="cov0" title="0">{ targetType = "uint16" }</span>, "uint16")
        <span class="cov8" title="1">rules.IfIn(func() </span><span class="cov0" title="0">{ targetType = "uint32" }</span>, "uint32")
        <span class="cov8" title="1">rules.IfIn(func() </span><span class="cov0" title="0">{ targetType = "uint64" }</span>, "uint64")
        <span class="cov8" title="1">rules.IfIn(func() </span><span class="cov0" title="0">{ targetType = "bool" }</span>, "bool")
        <span class="cov8" title="1">rules.IfIn(func() </span><span class="cov0" title="0">{ targetType = "float32" }</span>, "float32")
        <span class="cov8" title="1">rules.IfIn(func() </span><span class="cov0" title="0">{ targetType = "float64" }</span>, "float64")
        <span class="cov8" title="1">rules.IfIn(func() </span><span class="cov0" title="0">{ targetType = "slice" }</span>, "array", "slice")
        <span class="cov8" title="1">rules.IfIn(func() </span><span class="cov0" title="0">{ targetType = "struct" }</span>, "struct")

        <span class="cov8" title="1">return</span>
}

func getRuleRequired(rules anyArrayV2.AnyArray[string]) bool <span class="cov8" title="1">{ return rules.In("required") }</span>

func getRuleExFnNames(rule string) []string <span class="cov0" title="0">{
        var (
                value string
                ok    bool
        )

        if value, ok = strings.CutPrefix(rule, "size"); ok </span><span class="cov0" title="0">{
                return strings.Split(value, ",")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func getRuleIntSize(rule string) (size *int) <span class="cov0" title="0">{
        var (
                value string
                ok    bool
        )

        if value, ok = strings.CutPrefix(rule, "size"); ok </span><span class="cov0" title="0">{
                size = ptr.New(cast.ToInt(value))
                return
        }</span>

        <span class="cov0" title="0">return</span>
}

func getRuleFloatSize(rule string) (size *float64) <span class="cov0" title="0">{
        var (
                value string
                ok    bool
        )

        if value, ok = strings.CutPrefix(rule, "size"); ok </span><span class="cov0" title="0">{
                size = ptr.New(cast.ToFloat64(value))
                return
        }</span>

        <span class="cov0" title="0">return</span>
}

func getRuleIntMin(rule string) (size *int, include bool) <span class="cov0" title="0">{
        var (
                value string
                ok    bool
        )

        if value, ok = strings.CutPrefix(rule, "min&gt;="); ok </span><span class="cov0" title="0">{
                size = ptr.New(cast.ToInt(value))
                include = true
                return
        }</span>
        <span class="cov0" title="0">if value, ok = strings.CutPrefix(rule, "min&gt;"); ok </span><span class="cov0" title="0">{
                size = ptr.New(cast.ToInt(value))
                return
        }</span>

        <span class="cov0" title="0">return</span>
}

func getRuleIntMax(rule string) (size *int, include bool) <span class="cov0" title="0">{
        var (
                value string
                ok    bool
        )

        if value, ok = strings.CutPrefix(rule, "max&lt;="); ok </span><span class="cov0" title="0">{
                size = ptr.New(cast.ToInt(value))
                include = true
                return
        }</span>
        <span class="cov0" title="0">if value, ok = strings.CutPrefix(rule, "max&lt;"); ok </span><span class="cov0" title="0">{
                size = ptr.New(cast.ToInt(value))
                return
        }</span>

        <span class="cov0" title="0">return nil, false</span>
}

func getRuleFloatMin(rule string) (size *float64, include bool) <span class="cov0" title="0">{
        var (
                value string
                ok    bool
        )

        if value, ok = strings.CutPrefix(rule, "min&gt;="); ok </span><span class="cov0" title="0">{
                size = ptr.New(cast.ToFloat64(value))
                include = true
                return
        }</span>
        <span class="cov0" title="0">if value, ok = strings.CutPrefix(rule, "min&gt;"); ok </span><span class="cov0" title="0">{
                size = ptr.New(cast.ToFloat64(value))
                return
        }</span>

        <span class="cov0" title="0">return</span>
}

func getRuleFloatMax(rule string) (size *float64, include bool) <span class="cov0" title="0">{
        var (
                value string
                ok    bool
        )

        if value, ok = strings.CutPrefix(rule, "max&lt;="); ok </span><span class="cov0" title="0">{
                size = ptr.New(cast.ToFloat64(value))
                include = true
                return
        }</span>
        <span class="cov0" title="0">if value, ok = strings.CutPrefix(rule, "max&lt;"); ok </span><span class="cov0" title="0">{
                size = ptr.New(cast.ToFloat64(value))
                return
        }</span>

        <span class="cov0" title="0">return nil, false</span>
}

func getRuleIn(rule string) (in []string) <span class="cov0" title="0">{
        var (
                value string
                ok    bool
        )
        if value, ok = strings.CutPrefix(rule, "in:"); ok </span><span class="cov0" title="0">{
                in = strings.Split(value, ",")
                return
        }</span>

        <span class="cov0" title="0">return in</span>
}

func getRuleNotIn(rule string) (notIn []string) <span class="cov0" title="0">{
        var (
                value string
                ok    bool
        )
        if value, ok = strings.CutPrefix(rule, "not-in:"); ok </span><span class="cov0" title="0">{
                notIn = strings.Split(value, ",")
                return
        }</span>

        <span class="cov0" title="0">return notIn</span>
}

func (my FieldInfo) Check() FieldInfo <span class="cov8" title="1">{
        switch my.Kind </span>{
        case reflect.String:<span class="cov8" title="1">
                return my.checkString()</span>
        case reflect.Int:<span class="cov8" title="1">
                return my.checkInt()</span>
        case reflect.Int8:<span class="cov8" title="1">
                return my.checkInt8()</span>
        case reflect.Int16:<span class="cov0" title="0">
                return my.checkInt16()</span>
        case reflect.Int32:<span class="cov0" title="0">
                return my.checkInt32()</span>
        case reflect.Int64:<span class="cov0" title="0">
                return my.checkInt64()</span>
        case reflect.Uint:<span class="cov0" title="0">
                return my.checkUint()</span>
        case reflect.Uint8:<span class="cov0" title="0">
                return my.checkUint8()</span>
        case reflect.Uint16:<span class="cov0" title="0">
                return my.checkUint16()</span>
        case reflect.Uint32:<span class="cov0" title="0">
                return my.checkUint32()</span>
        case reflect.Uint64:<span class="cov0" title="0">
                return my.checkUint64()</span>
        case reflect.Float32:<span class="cov0" title="0">
                return my.checkFloat32()</span>
        case reflect.Float64:<span class="cov0" title="0">
                return my.checkFloat64()</span>
        case reflect.Bool:<span class="cov0" title="0">
                return my.checkBool()</span>
        case reflect.Array, reflect.Slice:<span class="cov0" title="0">
                return my.checkSlice()</span>
        case reflect.Struct:<span class="cov0" title="0">
                if my.Type == reflect.TypeOf(time.Time{}) </span><span class="cov0" title="0">{
                        return my.checkTime()
                }</span>
                <span class="cov0" title="0">return my</span>
        default:<span class="cov0" title="0">
                return my</span>
        }
}
</pre>
		
		<pre class="file" id="file107" style="display: none">package validatorV3

import (
        "sync"
)

type Validator struct{ data map[string]func(any) error }

var (
        validatorExOnce sync.Once
        validatorExIns  *Validator
)

func (*Validator) Ins() *Validator <span class="cov8" title="1">{
        validatorExOnce.Do(func() </span><span class="cov8" title="1">{ validatorExIns = &amp;Validator{data: make(map[string]func(any) (err error))} }</span>)
        <span class="cov8" title="1">return validatorExIns</span>
}

func (*Validator) RegisterExFn(key string, fn func(any) (err error)) *Validator <span class="cov0" title="0">{
        validatorExIns.data[key] = fn
        return validatorExIns
}</span>

func (*Validator) GetExFn(key string) func(any) (err error) <span class="cov0" title="0">{ return validatorExIns.data[key] }</span>

func (*Validator) Checker(data any) Checker <span class="cov8" title="1">{ return Checker{}.New(data) }</span>
</pre>
		
		<pre class="file" id="file108" style="display: none">package validator

import (
        "reflect"
        "strings"

        "github.com/spf13/cast"

        "github.com/aid297/aid/array"
        "github.com/aid297/aid/operation"

        "github.com/aid297/aid/common"
)

// checkFloat32 验证：float32 -&gt; 支持的规则 required、size&lt;、size&lt;=、size&gt;、size&gt;=、range=
func (my *ValidatorApp[T]) checkFloat32(rule, fieldName string, value any) error <span class="cov0" title="0">{
        if reflect.TypeOf(value).Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                if reflect.ValueOf(value).IsNil() </span><span class="cov0" title="0">{
                        return operation.Ternary(rule == "required", RequiredErr.New(fieldName), nil)
                }</span>
                <span class="cov0" title="0">value = reflect.ValueOf(value).Elem().Interface()</span>
        }

        <span class="cov0" title="0">switch </span>{
        case strings.HasPrefix(rule, "size&lt;="):<span class="cov0" title="0">
                small := strings.TrimPrefix(rule, "size&lt;=")
                if value.(float32) &lt;= common.ToFloat32(small) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能小于等于[%f]", fieldName, common.ToFloat32(small))
                }</span>
        case strings.HasPrefix(rule, "size&lt;"):<span class="cov0" title="0">
                small := strings.TrimPrefix(rule, "size&lt;")
                if value.(float32) &lt; common.ToFloat32(small) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能小于[%f]", fieldName, common.ToFloat32(small))
                }</span>
        case strings.HasPrefix(rule, "size&gt;="):<span class="cov0" title="0">
                large := strings.TrimPrefix(rule, "size&gt;=")
                if value.(float32) &gt;= common.ToFloat32(large) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能大于等于[%f]", fieldName, common.ToFloat32(large))
                }</span>
        case strings.HasPrefix(rule, "size&gt;"):<span class="cov0" title="0">
                large := strings.TrimPrefix(rule, "size&gt;")
                if value.(float32) &gt; common.ToFloat32(large) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能大于[%f]", fieldName, common.ToFloat32(large))
                }</span>
        case strings.HasPrefix(rule, "size="):<span class="cov0" title="0">
                size := strings.TrimPrefix(rule, "size=")
                if value.(float32) != common.ToFloat32(size) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须等于[%f]", fieldName, common.ToFloat32(size))
                }</span>
        case strings.HasPrefix(rule, "size!="):<span class="cov0" title="0">
                size := strings.TrimPrefix(rule, "size!=")
                if value.(float32) == common.ToFloat32(size) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须不等于[%f]", fieldName, common.ToFloat32(size))
                }</span>
        case strings.HasPrefix(rule, "range="):<span class="cov0" title="0">
                between := strings.TrimPrefix(rule, "range=")
                betweenRange := strings.Split(between, ",")
                if len(betweenRange) != 2 </span><span class="cov0" title="0">{
                        return RuleErr.NewFormat("[%s]规则定义错误#1，规则格式：f,f", fieldName)
                }</span>
                <span class="cov0" title="0">small := common.ToFloat32(betweenRange[0])
                large := common.ToFloat32(betweenRange[1])
                if value.(float32) &lt; small || value.(float32) &gt; large </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须在：%f~%f之间", fieldName, small, large)
                }</span>
        case strings.HasPrefix(rule, "in="):<span class="cov0" title="0">
                inValuesStr := strings.TrimPrefix(rule, "in=")
                inValuesArr := array.Cast(array.New(strings.Split(inValuesStr, ",")), func(value string) float32 </span><span class="cov0" title="0">{ return cast.ToFloat32(value) }</span>)
                <span class="cov0" title="0">if !inValuesArr.In(value.(float32)) </span><span class="cov0" title="0">{
                        return ValidateErr.NewFormat("[%s]值必须在[%s]中", fieldName, inValuesStr)
                }</span>
        case strings.HasPrefix(rule, "not-in="):<span class="cov0" title="0">
                inValuesStr := strings.TrimPrefix(rule, "not-in=")
                inValuesArr := array.Cast(array.New(strings.Split(inValuesStr, ",")), func(value string) float32 </span><span class="cov0" title="0">{ return cast.ToFloat32(value) }</span>)
                <span class="cov0" title="0">if inValuesArr.In(value.(float32)) </span><span class="cov0" title="0">{
                        return ValidateErr.NewFormat("[%s]值不可为以下内容：[%s]", fieldName, inValuesStr)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// checkFloat64 验证：float64 -&gt; 支持的规则 required、size&lt;、size&lt;=、size&gt;、size&gt;=、range=
func (my *ValidatorApp[T]) checkFloat64(rule, fieldName string, value any) error <span class="cov0" title="0">{
        if reflect.TypeOf(value).Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                if reflect.ValueOf(value).IsNil() </span><span class="cov0" title="0">{
                        return operation.Ternary(rule == "required", RequiredErr.New(fieldName), nil)
                }</span>
                <span class="cov0" title="0">value = reflect.ValueOf(value).Elem().Interface()</span>
        }

        <span class="cov0" title="0">switch </span>{
        case strings.HasPrefix(rule, "size&lt;="):<span class="cov0" title="0">
                small := strings.TrimPrefix(rule, "size&lt;=")
                if !(value.(float64) &lt;= common.ToFloat64(small)) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能小于等于[%f]", fieldName, common.ToFloat64(small))
                }</span>
        case strings.HasPrefix(rule, "size&lt;"):<span class="cov0" title="0">
                small := strings.TrimPrefix(rule, "size&lt;")
                if !(value.(float64) &lt; common.ToFloat64(small)) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能小于[%f]", fieldName, common.ToFloat64(small))
                }</span>
        case strings.HasPrefix(rule, "size&gt;="):<span class="cov0" title="0">
                large := strings.TrimPrefix(rule, "size&gt;=")
                if !(value.(float64) &gt;= common.ToFloat64(large)) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能大于等于[%f]", fieldName, common.ToFloat64(large))
                }</span>
        case strings.HasPrefix(rule, "size&gt;"):<span class="cov0" title="0">
                large := strings.TrimPrefix(rule, "size&gt;")
                if !(value.(float64) &gt; common.ToFloat64(large)) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能大于[%f]", fieldName, common.ToFloat64(large))
                }</span>
        case strings.HasPrefix(rule, "size="):<span class="cov0" title="0">
                size := strings.TrimPrefix(rule, "size=")
                if value.(float64) != common.ToFloat64(size) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须等于[%f]", fieldName, common.ToFloat64(size))
                }</span>
        case strings.HasPrefix(rule, "size!="):<span class="cov0" title="0">
                size := strings.TrimPrefix(rule, "size!=")
                if value.(float64) == common.ToFloat64(size) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须不等于[%f]", fieldName, common.ToFloat64(size))
                }</span>
        case strings.HasPrefix(rule, "range="):<span class="cov0" title="0">
                between := strings.TrimPrefix(rule, "range=")
                betweenRange := strings.Split(between, ",")
                if len(betweenRange) != 2 </span><span class="cov0" title="0">{
                        return RuleErr.NewFormat("[%s]规则定义错误#1，规则格式：f,f", fieldName)
                }</span>
                <span class="cov0" title="0">small := common.ToFloat64(betweenRange[0])
                large := common.ToFloat64(betweenRange[1])
                if value.(float64) &lt; small || value.(float64) &gt; large </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须在：%f~%f之间", fieldName, small, large)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file109" style="display: none">package validator

import (
        "reflect"
        "strings"

        "github.com/spf13/cast"

        "github.com/aid297/aid/array"
        "github.com/aid297/aid/operation"

        "github.com/aid297/aid/common"
)

// checkInt 验证：int -&gt; 支持的规则 required、size&lt;、size&lt;=、size&gt;、size&gt;=、range=
func (my *ValidatorApp[T]) checkInt(rule, fieldName string, value any) error <span class="cov0" title="0">{
        if reflect.TypeOf(value).Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                if reflect.ValueOf(value).IsNil() </span><span class="cov0" title="0">{
                        return operation.Ternary(rule == "required", RequiredErr.New(fieldName), nil)
                }</span>
                <span class="cov0" title="0">value = reflect.ValueOf(value).Elem().Interface()</span>
        }

        <span class="cov0" title="0">switch </span>{
        case strings.HasPrefix(rule, "size&lt;="):<span class="cov0" title="0">
                small := strings.TrimPrefix(rule, "size&lt;=")
                if value.(int) &lt;= common.ToInt(small) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能小于等于：[%d]", fieldName, common.ToInt(small))
                }</span>
        case strings.HasPrefix(rule, "size&lt;"):<span class="cov0" title="0">
                small := strings.TrimPrefix(rule, "size&lt;")
                if value.(int) &lt; common.ToInt(small) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能小于：[%d]", fieldName, common.ToInt(small))
                }</span>
        case strings.HasPrefix(rule, "size&gt;="):<span class="cov0" title="0">
                large := strings.TrimPrefix(rule, "size&gt;=")
                if value.(int) &gt;= common.ToInt(large) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能大于等于：[%d]", fieldName, common.ToInt(large))
                }</span>
        case strings.HasPrefix(rule, "size&gt;"):<span class="cov0" title="0">
                large := strings.TrimPrefix(rule, "size&gt;")
                if value.(int) &gt; common.ToInt(large) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能大于：[%d]", fieldName, common.ToInt(large))
                }</span>
        case strings.HasPrefix(rule, "size="):<span class="cov0" title="0">
                size := strings.TrimPrefix(rule, "size=")
                if value.(int) != common.ToInt(size) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须等于：[%d]", fieldName, common.ToInt(size))
                }</span>
        case strings.HasPrefix(rule, "size!="):<span class="cov0" title="0">
                size := strings.TrimPrefix(rule, "size!=")
                if value.(int) == common.ToInt(size) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须不等于：[%d]", fieldName, common.ToInt(size))
                }</span>
        case strings.HasPrefix(rule, "range="):<span class="cov0" title="0">
                between := strings.TrimPrefix(rule, "range=")
                betweenRange := strings.Split(between, ",")
                if len(betweenRange) != 2 </span><span class="cov0" title="0">{
                        return RuleErr.NewFormat("[%s]规则定义错误#2，规则格式[d,d]", fieldName)
                }</span>
                <span class="cov0" title="0">small := common.ToInt(betweenRange[0])
                large := common.ToInt(betweenRange[1])
                if value.(int) &lt; small || value.(int) &gt; large </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须在[%d~%d]之间", fieldName, small, large)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// checkInt8 验证：int8 -&gt; 支持的规则 required、size&lt;、size&lt;=、size&gt;、size&gt;=、range=
func (my *ValidatorApp[T]) checkInt8(rule, fieldName string, value any) error <span class="cov0" title="0">{
        if reflect.TypeOf(value).Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                if reflect.ValueOf(value).IsNil() </span><span class="cov0" title="0">{
                        return operation.Ternary(rule == "required", RequiredErr.New(fieldName), nil)
                }</span>
                <span class="cov0" title="0">value = reflect.ValueOf(value).Elem().Interface()</span>
        }

        <span class="cov0" title="0">switch </span>{
        case strings.HasPrefix(rule, "size&lt;="):<span class="cov0" title="0">
                small := strings.TrimPrefix(rule, "size&lt;=")
                if value.(int8) &lt;= common.ToInt8(small) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能小于等于：[%d]", fieldName, common.ToInt(small))
                }</span>
        case strings.HasPrefix(rule, "size&lt;"):<span class="cov0" title="0">
                small := strings.TrimPrefix(rule, "size&lt;")
                if value.(int8) &lt; common.ToInt8(small) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能小于：[%d]", fieldName, common.ToInt(small))
                }</span>
        case strings.HasPrefix(rule, "size&gt;="):<span class="cov0" title="0">
                large := strings.TrimPrefix(rule, "size&gt;=")
                if value.(int8) &gt;= common.ToInt8(large) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能大于等于：[%d]", fieldName, common.ToInt(large))
                }</span>
        case strings.HasPrefix(rule, "size&gt;"):<span class="cov0" title="0">
                large := strings.TrimPrefix(rule, "size&gt;")
                if value.(int8) &gt; common.ToInt8(large) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能大于：[%d]", fieldName, common.ToInt(large))
                }</span>
        case strings.HasPrefix(rule, "size="):<span class="cov0" title="0">
                size := strings.TrimPrefix(rule, "size=")
                if value.(int8) != common.ToInt8(size) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须等于：[%d]", fieldName, common.ToInt(size))
                }</span>
        case strings.HasPrefix(rule, "size!="):<span class="cov0" title="0">
                size := strings.TrimPrefix(rule, "size!=")
                if value.(int8) == common.ToInt8(size) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须不等于：[%d]", fieldName, common.ToInt(size))
                }</span>
        case strings.HasPrefix(rule, "range="):<span class="cov0" title="0">
                between := strings.TrimPrefix(rule, "range=")
                betweenRange := strings.Split(between, ",")
                if len(betweenRange) != 2 </span><span class="cov0" title="0">{
                        return RuleErr.NewFormat("[%s]规则定义错误#2，规则格式[d,d]", fieldName)
                }</span>
                <span class="cov0" title="0">small := common.ToInt8(betweenRange[0])
                large := common.ToInt8(betweenRange[1])
                if value.(int8) &lt; small || value.(int8) &gt; large </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须在[%d~%d]之间", fieldName, small, large)
                }</span>
        case strings.HasPrefix(rule, "in="):<span class="cov0" title="0">
                inValuesStr := strings.TrimPrefix(rule, "in=")
                inValuesArr := array.Cast(array.New(strings.Split(inValuesStr, ",")), func(value string) int </span><span class="cov0" title="0">{ return cast.ToInt(value) }</span>)
                <span class="cov0" title="0">if !inValuesArr.In(value.(int)) </span><span class="cov0" title="0">{
                        return ValidateErr.NewFormat("[%s]值必须在[%s]中", fieldName, inValuesStr)
                }</span>
        case strings.HasPrefix(rule, "not-in="):<span class="cov0" title="0">
                inValuesStr := strings.TrimPrefix(rule, "not-in=")
                inValuesArr := array.Cast(array.New(strings.Split(inValuesStr, ",")), func(value string) int </span><span class="cov0" title="0">{ return cast.ToInt(value) }</span>)
                <span class="cov0" title="0">if inValuesArr.In(value.(int)) </span><span class="cov0" title="0">{
                        return ValidateErr.NewFormat("[%s]值不可为以下内容：[%s]", fieldName, inValuesStr)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// checkInt16 验证：int16 -&gt; 支持的规则 required、size&lt;、size&lt;=、size&gt;、size&gt;=、range=
func (my *ValidatorApp[T]) checkInt16(rule, fieldName string, value any) error <span class="cov0" title="0">{
        if reflect.TypeOf(value).Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                if reflect.ValueOf(value).IsNil() </span><span class="cov0" title="0">{
                        return operation.Ternary(rule == "required", RequiredErr.New(fieldName), nil)
                }</span>
                <span class="cov0" title="0">value = reflect.ValueOf(value).Elem().Interface()</span>
        }

        <span class="cov0" title="0">switch </span>{
        case strings.HasPrefix(rule, "size&lt;="):<span class="cov0" title="0">
                small := strings.TrimPrefix(rule, "size&lt;=")
                if value.(int16) &lt;= common.ToInt16(small) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须小于等于：[%d]", fieldName, common.ToInt(small))
                }</span>
        case strings.HasPrefix(rule, "size&lt;"):<span class="cov0" title="0">
                small := strings.TrimPrefix(rule, "size&lt;")
                if value.(int16) &lt; common.ToInt16(small) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须小于：[%d]", fieldName, common.ToInt(small))
                }</span>
        case strings.HasPrefix(rule, "size&gt;="):<span class="cov0" title="0">
                large := strings.TrimPrefix(rule, "size&gt;=")
                if value.(int16) &gt;= common.ToInt16(large) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须大于等于：[%d]", fieldName, common.ToInt(large))
                }</span>
        case strings.HasPrefix(rule, "size&gt;"):<span class="cov0" title="0">
                large := strings.TrimPrefix(rule, "size&gt;")
                if !(value.(int16) &gt; common.ToInt16(large)) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须大于：[%d]", fieldName, common.ToInt(large))
                }</span>
        case strings.HasPrefix(rule, "size="):<span class="cov0" title="0">
                size := strings.TrimPrefix(rule, "size=")
                if !(value.(int16) != common.ToInt16(size)) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须等于：[%d]", fieldName, common.ToInt(size))
                }</span>
        case strings.HasPrefix(rule, "size!="):<span class="cov0" title="0">
                size := strings.TrimPrefix(rule, "size!=")
                if !(value.(int16) == common.ToInt16(size)) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须不等于：[%d]", fieldName, common.ToInt(size))
                }</span>
        case strings.HasPrefix(rule, "range="):<span class="cov0" title="0">
                between := strings.TrimPrefix(rule, "range=")
                betweenRange := strings.Split(between, ",")
                if len(betweenRange) != 2 </span><span class="cov0" title="0">{
                        return RuleErr.NewFormat("[%s]规则定义错误#2，规则格式[d,d]", fieldName)
                }</span>
                <span class="cov0" title="0">small := common.ToInt16(betweenRange[0])
                large := common.ToInt16(betweenRange[1])
                if value.(int16) &lt; small || value.(int16) &gt; large </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须在[%d~%d]之间", fieldName, small, large)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// checkInt32 验证：int32 -&gt; 支持的规则 required、size&lt;、size&lt;=、size&gt;、size&gt;=、range=
func (my *ValidatorApp[T]) checkInt32(rule, fieldName string, value any) error <span class="cov0" title="0">{
        if reflect.TypeOf(value).Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                if reflect.ValueOf(value).IsNil() </span><span class="cov0" title="0">{
                        return operation.Ternary(rule == "required", RequiredErr.New(fieldName), nil)
                }</span>
                <span class="cov0" title="0">value = reflect.ValueOf(value).Elem().Interface()</span>
        }

        <span class="cov0" title="0">switch </span>{
        case strings.HasPrefix(rule, "size&lt;="):<span class="cov0" title="0">
                small := strings.TrimPrefix(rule, "size&lt;=")
                if value.(int32) &lt;= common.ToInt32(small) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能小于等于：[%d]", fieldName, common.ToInt(small))
                }</span>
        case strings.HasPrefix(rule, "size&lt;"):<span class="cov0" title="0">
                small := strings.TrimPrefix(rule, "size&lt;")
                if value.(int32) &lt; common.ToInt32(small) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能小于：[%d]", fieldName, common.ToInt(small))
                }</span>
        case strings.HasPrefix(rule, "size&gt;="):<span class="cov0" title="0">
                large := strings.TrimPrefix(rule, "size&gt;=")
                if value.(int32) &gt;= common.ToInt32(large) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能大于等于：[%d]", fieldName, common.ToInt(large))
                }</span>
        case strings.HasPrefix(rule, "size&gt;"):<span class="cov0" title="0">
                large := strings.TrimPrefix(rule, "size&gt;")
                if value.(int32) &gt; common.ToInt32(large) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能大于：[%d]", fieldName, common.ToInt(large))
                }</span>
        case strings.HasPrefix(rule, "size="):<span class="cov0" title="0">
                size := strings.TrimPrefix(rule, "size=")
                if value.(int32) != common.ToInt32(size) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须等于：[%d]", fieldName, common.ToInt(size))
                }</span>
        case strings.HasPrefix(rule, "size!="):<span class="cov0" title="0">
                size := strings.TrimPrefix(rule, "size!=")
                if value.(int32) == common.ToInt32(size) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须不等于#2：[%d]", fieldName, common.ToInt(size))
                }</span>
        case strings.HasPrefix(rule, "range="):<span class="cov0" title="0">
                between := strings.TrimPrefix(rule, "range=")
                betweenRange := strings.Split(between, ",")
                if len(betweenRange) != 2 </span><span class="cov0" title="0">{
                        return RuleErr.NewFormat("[%s]规则定义错误，规则格式[d,d]", fieldName)
                }</span>
                <span class="cov0" title="0">small := common.ToInt32(betweenRange[0])
                large := common.ToInt32(betweenRange[1])
                if value.(int32) &lt; small || value.(int32) &gt; large </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须在[%d~%d]之间", fieldName, small, large)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// checkInt64 验证：int64 -&gt; 支持的规则 required、size&lt;、size&lt;=、size&gt;、size&gt;=、range=
func (my *ValidatorApp[T]) checkInt64(rule, fieldName string, value any) error <span class="cov0" title="0">{
        if reflect.TypeOf(value).Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                if reflect.ValueOf(value).IsNil() </span><span class="cov0" title="0">{
                        return operation.Ternary(rule == "required", RequiredErr.New(fieldName), nil)
                }</span>
                <span class="cov0" title="0">value = reflect.ValueOf(value).Elem().Interface()</span>
        }

        <span class="cov0" title="0">switch </span>{
        case strings.HasPrefix(rule, "size&lt;="):<span class="cov0" title="0">
                small := strings.TrimPrefix(rule, "size&lt;=")
                if value.(int64) &lt;= common.ToInt64(small) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能小于等于[%d]", fieldName, common.ToInt(small))
                }</span>
        case strings.HasPrefix(rule, "size&lt;"):<span class="cov0" title="0">
                small := strings.TrimPrefix(rule, "size&lt;")
                if value.(int64) &lt; common.ToInt64(small) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能小于[%d]", fieldName, common.ToInt(small))
                }</span>
        case strings.HasPrefix(rule, "size&gt;="):<span class="cov0" title="0">
                large := strings.TrimPrefix(rule, "size&gt;=")
                if value.(int64) &gt;= common.ToInt64(large) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能大于等于[%d]", fieldName, common.ToInt(large))
                }</span>
        case strings.HasPrefix(rule, "size&gt;"):<span class="cov0" title="0">
                large := strings.TrimPrefix(rule, "size&gt;")
                if value.(int64) &gt; common.ToInt64(large) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能大于[%d]", fieldName, common.ToInt(large))
                }</span>
        case strings.HasPrefix(rule, "size="):<span class="cov0" title="0">
                size := strings.TrimPrefix(rule, "size=")
                if value.(int64) != common.ToInt64(size) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须等于[%d]", fieldName, common.ToInt(size))
                }</span>
        case strings.HasPrefix(rule, "size!="):<span class="cov0" title="0">
                size := strings.TrimPrefix(rule, "size!=")
                if value.(int64) == common.ToInt64(size) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须不等于[%d]", fieldName, common.ToInt(size))
                }</span>
        case strings.HasPrefix(rule, "range="):<span class="cov0" title="0">
                between := strings.TrimPrefix(rule, "range=")
                betweenRange := strings.Split(between, ",")
                if len(betweenRange) != 2 </span><span class="cov0" title="0">{
                        return RuleErr.NewFormat("[%s]规则定义错误#2，规则格式[d,d]", fieldName)
                }</span>
                <span class="cov0" title="0">small := common.ToInt64(betweenRange[0])
                large := common.ToInt64(betweenRange[1])
                if value.(int64) &lt; small || value.(int64) &gt; large </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须在[%d~%d]之间", fieldName, small, large)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file110" style="display: none">package validator

import (
        "reflect"
        "regexp"
        "strings"
        "unicode/utf8"

        "github.com/aid297/aid/array"
        "github.com/aid297/aid/operation"

        "github.com/aid297/aid/common"
)

// checkString 验证：string -&gt; 支持的规则 required、email、email=、date、date=、time、time=、datetime、datetime=、size&lt;、size&lt;=、size&gt;、size&gt;=、size=、range=、in=、not-in=、not-empty
func (my *ValidatorApp[T]) checkString(rule, fieldName string, value any) error <span class="cov8" title="1">{
        if reflect.TypeOf(value).Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                if reflect.ValueOf(value).IsNil() </span><span class="cov0" title="0">{
                        return operation.Ternary(rule == "required", RequiredErr.New(fieldName), nil)
                }</span>
                <span class="cov0" title="0">value = reflect.ValueOf(value).Elem().Interface()</span>
        }

        <span class="cov8" title="1">switch </span>{
        case rule == "empty-email":<span class="cov0" title="0">
                if value.(string) == "" </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">if matched, _ := regexp.MatchString(my.emailFormat, value.(string)); !matched </span><span class="cov0" title="0">{
                        return EmailErr.New(fieldName)
                }</span>
        case rule == "email":<span class="cov0" title="0">
                if matched, _ := regexp.MatchString(my.emailFormat, value.(string)); !matched </span><span class="cov0" title="0">{
                        return EmailErr.New(fieldName)
                }</span>
        case strings.HasPrefix(rule, "empty-email="):<span class="cov0" title="0">
                if value.(string) == "" </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">emailFormat := strings.TrimPrefix(rule, "empty-email=")
                if matched, _ := regexp.MatchString(emailFormat, value.(string)); !matched </span><span class="cov0" title="0">{
                        return EmailErr.New(fieldName)
                }</span>
        case strings.HasPrefix(rule, "email="):<span class="cov0" title="0">
                emailFormat := strings.TrimPrefix(rule, "email=")
                if matched, _ := regexp.MatchString(emailFormat, value.(string)); !matched </span><span class="cov0" title="0">{
                        return EmailErr.New(fieldName)
                }</span>
        case rule == "empty-time":<span class="cov0" title="0">
                if value.(string) == "" </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">if matched, _ := regexp.MatchString(my.timeFormat, value.(string)); !matched </span><span class="cov0" title="0">{
                        return TimeErr.NewFormat("[%s]时间格式错误，正确格式[%s]", fieldName, my.timeFormat)
                }</span>
        case rule == "time":<span class="cov0" title="0">
                if matched, _ := regexp.MatchString(my.timeFormat, value.(string)); !matched </span><span class="cov0" title="0">{
                        return TimeErr.NewFormat("[%s]时间格式错误，正确格式[%s]", fieldName, my.timeFormat)
                }</span>
        case strings.HasPrefix(rule, "time="):<span class="cov0" title="0">
                timeFormat := strings.TrimPrefix(rule, "time=")
                if matched, _ := regexp.MatchString(timeFormat, value.(string)); !matched </span><span class="cov0" title="0">{
                        return TimeErr.NewFormat("[%s]时间格式错误，正确格式[%s]", fieldName, timeFormat)
                }</span>
        case rule == "empty-datetime":<span class="cov0" title="0">
                if value.(string) == "" </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">if matched, _ := regexp.MatchString(my.datetimeFormat, value.(string)); !matched </span><span class="cov0" title="0">{
                        return TimeErr.NewFormat("[%s]时间格式错误，正确格式[%s]", fieldName, my.datetimeFormat)
                }</span>
        case rule == "datetime":<span class="cov0" title="0">
                if matched, _ := regexp.MatchString(my.datetimeFormat, value.(string)); !matched </span><span class="cov0" title="0">{
                        return TimeErr.NewFormat("[%s]时间格式错误，正确格式[%s]", fieldName, my.datetimeFormat)
                }</span>
        case strings.HasPrefix(rule, "empty-datetime="):<span class="cov0" title="0">
                if value.(string) == "" </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">datetimeFormat := strings.TrimPrefix(rule, "empty-datetime=")
                if matched, _ := regexp.MatchString(datetimeFormat, value.(string)); !matched </span><span class="cov0" title="0">{
                        return TimeErr.NewFormat("[%s]时间格式错误，正确格式[%s]", fieldName, datetimeFormat)
                }</span>
        case strings.HasPrefix(rule, "datetime="):<span class="cov0" title="0">
                datetimeFormat := strings.TrimPrefix(rule, "datetime=")
                if matched, _ := regexp.MatchString(datetimeFormat, value.(string)); !matched </span><span class="cov0" title="0">{
                        return TimeErr.NewFormat("[%s]时间格式错误，正确格式[%s]", fieldName, datetimeFormat)
                }</span>
        case rule == "empty-date":<span class="cov0" title="0">
                if value.(string) == "" </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">if matched, _ := regexp.MatchString(my.dateFormat, value.(string)); !matched </span><span class="cov0" title="0">{
                        return TimeErr.NewFormat("[%s]日期格式错误，正确格式[%s]", fieldName, my.dateFormat)
                }</span>
        case rule == "date":<span class="cov0" title="0">
                if matched, _ := regexp.MatchString(my.dateFormat, value.(string)); !matched </span><span class="cov0" title="0">{
                        return TimeErr.NewFormat("[%s]日期格式错误，正确格式[%s]", fieldName, my.dateFormat)
                }</span>
        case strings.HasPrefix(rule, "date="):<span class="cov0" title="0">
                dateFormat := strings.TrimPrefix(rule, "date=")
                if matched, _ := regexp.MatchString(dateFormat, value.(string)); !matched </span><span class="cov0" title="0">{
                        return TimeErr.NewFormat("[%s]日期格式错误，正确格式[%s]", fieldName, dateFormat)
                }</span>
        case rule == "not-empty":<span class="cov0" title="0">
                if utf8.RuneCountInString(value.(string)) == 0 </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]不能为空", fieldName)
                }</span>
        case strings.HasPrefix(rule, "empty-size&lt;="):<span class="cov0" title="0">
                if value.(string) == "" </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">small := strings.TrimPrefix(rule, "empty-size&lt;=")
                if !(utf8.RuneCountInString(value.(string)) &lt;= common.ToInt(small)) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须小于等于[%d]", fieldName, common.ToInt(small))
                }</span>
        case strings.HasPrefix(rule, "size&lt;="):<span class="cov0" title="0">
                small := strings.TrimPrefix(rule, "size&lt;=")
                if !(utf8.RuneCountInString(value.(string)) &lt;= common.ToInt(small)) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须小于等于[%d]", fieldName, common.ToInt(small))
                }</span>
        case strings.HasPrefix(rule, "empty-size&lt;"):<span class="cov0" title="0">
                if value.(string) == "" </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">large := strings.TrimPrefix(rule, "empty-size&lt;")
                if !(utf8.RuneCountInString(value.(string)) &lt; common.ToInt(large)) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须小于[%d]", fieldName, common.ToInt(large))
                }</span>
        case strings.HasPrefix(rule, "size&lt;"):<span class="cov0" title="0">
                large := strings.TrimPrefix(rule, "size&lt;")
                if !(utf8.RuneCountInString(value.(string)) &lt; common.ToInt(large)) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须小于[%d]", fieldName, common.ToInt(large))
                }</span>
        case strings.HasPrefix(rule, "empty-size&gt;="):<span class="cov0" title="0">
                if value.(string) == "" </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">large := strings.TrimPrefix(rule, "empty-size&gt;=")
                if !(utf8.RuneCountInString(value.(string)) &gt;= common.ToInt(large)) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须大于等于[%d]", fieldName, common.ToInt(large))
                }</span>
        case strings.HasPrefix(rule, "size&gt;="):<span class="cov0" title="0">
                large := strings.TrimPrefix(rule, "size&gt;=")
                if !(utf8.RuneCountInString(value.(string)) &gt;= common.ToInt(large)) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须大于等于[%d]", fieldName, common.ToInt(large))
                }</span>
        case strings.HasPrefix(rule, "empty-size&gt;"):<span class="cov0" title="0">
                if value.(string) == "" </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">large := strings.TrimPrefix(rule, "empty-size&gt;")
                if !(utf8.RuneCountInString(value.(string)) &gt; common.ToInt(large)) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须大于[%d]", fieldName, common.ToInt(large))
                }</span>
        case strings.HasPrefix(rule, "size&gt;"):<span class="cov0" title="0">
                large := strings.TrimPrefix(rule, "size&gt;")
                if !(utf8.RuneCountInString(value.(string)) &gt; common.ToInt(large)) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须大于[%d]", fieldName, common.ToInt(large))
                }</span>
        case strings.HasPrefix(rule, "empty-size="):<span class="cov0" title="0">
                if value.(string) == "" </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">size := strings.TrimPrefix(rule, "empty-size=")
                if utf8.RuneCountInString(value.(string)) != common.ToInt(size) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须等于[%d]", fieldName, common.ToInt(size))
                }</span>
        case strings.HasPrefix(rule, "size="):<span class="cov0" title="0">
                size := strings.TrimPrefix(rule, "size=")
                if utf8.RuneCountInString(value.(string)) != common.ToInt(size) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须等于[%d]", fieldName, common.ToInt(size))
                }</span>
        case strings.HasPrefix(rule, "empty-size!="):<span class="cov0" title="0">
                if value.(string) == "" </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">size := strings.TrimPrefix(rule, "empty-size!=")
                if utf8.RuneCountInString(value.(string)) == common.ToInt(size) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须不等于[%d]", fieldName, common.ToInt(size))
                }</span>
        case strings.HasPrefix(rule, "size!="):<span class="cov0" title="0">
                size := strings.TrimPrefix(rule, "size!=")
                if utf8.RuneCountInString(value.(string)) == common.ToInt(size) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须不等于[%d]", fieldName, common.ToInt(size))
                }</span>
        case strings.HasPrefix(rule, "empty-range="):<span class="cov0" title="0">
                if value.(string) == "" </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">between := strings.TrimPrefix(rule, "empty-range=")
                betweenRange := strings.Split(between, ",")
                if len(betweenRange) != 2 </span><span class="cov0" title="0">{
                        return RuleErr.NewFormat("[%s]规则定义错误#3，规则格式[d,d]", fieldName)
                }</span>
                <span class="cov0" title="0">small := common.ToInt(betweenRange[0])
                large := common.ToInt(betweenRange[1])
                if utf8.RuneCountInString(value.(string)) &lt; small || utf8.RuneCountInString(value.(string)) &gt; large </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须在[%d~%d]之间", fieldName, small, large)
                }</span>
        case strings.HasPrefix(rule, "range="):<span class="cov0" title="0">
                between := strings.TrimPrefix(rule, "range=")
                betweenRange := strings.Split(between, ",")
                if len(betweenRange) != 2 </span><span class="cov0" title="0">{
                        return RuleErr.NewFormat("[%s]规则定义错误#3，规则格式[d,d]", fieldName)
                }</span>
                <span class="cov0" title="0">small := common.ToInt(betweenRange[0])
                large := common.ToInt(betweenRange[1])
                if utf8.RuneCountInString(value.(string)) &lt; small || utf8.RuneCountInString(value.(string)) &gt; large </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须在[%d~%d]之间", fieldName, small, large)
                }</span>
        case strings.HasPrefix(rule, "empty-range!="):<span class="cov0" title="0">
                if value.(string) == "" </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">between := strings.TrimPrefix(rule, "range!=")
                betweenRange := strings.Split(between, ",")
                if len(betweenRange) != 2 </span><span class="cov0" title="0">{
                        return RuleErr.NewFormat("[%s]规则定义错误#3，规则格式[d,d]", fieldName)
                }</span>
                <span class="cov0" title="0">small := common.ToInt(betweenRange[0])
                large := common.ToInt(betweenRange[1])
                if !(utf8.RuneCountInString(value.(string)) &lt; small || utf8.RuneCountInString(value.(string)) &gt; large) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能在[%d~%d]之间", fieldName, small, large)
                }</span>
        case strings.HasPrefix(rule, "range!="):<span class="cov0" title="0">
                between := strings.TrimPrefix(rule, "range!=")
                betweenRange := strings.Split(between, ",")
                if len(betweenRange) != 2 </span><span class="cov0" title="0">{
                        return RuleErr.NewFormat("[%s]规则定义错误#3，规则格式[d,d]", fieldName)
                }</span>
                <span class="cov0" title="0">small := common.ToInt(betweenRange[0])
                large := common.ToInt(betweenRange[1])
                if !(utf8.RuneCountInString(value.(string)) &lt; small || utf8.RuneCountInString(value.(string)) &gt; large) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能在[%d~%d]之间", fieldName, small, large)
                }</span>
        case strings.HasPrefix(rule, "empty-in="):<span class="cov0" title="0">
                if value.(string) == "" </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">inValuesStr := strings.TrimPrefix(rule, "empty-in=")
                inValuesArr := array.New(strings.Split(inValuesStr, ","))
                if !inValuesArr.In(value.(string)) </span><span class="cov0" title="0">{
                        return ValidateErr.NewFormat("[%s]值必须在[%s]中", fieldName, inValuesStr)
                }</span>
        case strings.HasPrefix(rule, "in="):<span class="cov0" title="0">
                inValuesStr := strings.TrimPrefix(rule, "in=")
                inValuesArr := array.New(strings.Split(inValuesStr, ","))
                if !inValuesArr.In(value.(string)) </span><span class="cov0" title="0">{
                        return ValidateErr.NewFormat("[%s]值必须在[%s]中", fieldName, inValuesStr)
                }</span>
        case strings.HasPrefix(rule, "empty-not-in="):<span class="cov0" title="0">
                if value.(string) == "" </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">inValuesStr := strings.TrimPrefix(rule, "empty-not-in=")
                inValuesArr := array.New(strings.Split(inValuesStr, ","))
                if inValuesArr.In(value.(string)) </span><span class="cov0" title="0">{
                        return ValidateErr.NewFormat("[%s]值不可为以下内容：[%s]", fieldName, inValuesStr)
                }</span>
        case strings.HasPrefix(rule, "not-in="):<span class="cov0" title="0">
                inValuesStr := strings.TrimPrefix(rule, "not-in=")
                inValuesArr := array.New(strings.Split(inValuesStr, ","))
                if inValuesArr.In(value.(string)) </span><span class="cov0" title="0">{
                        return ValidateErr.NewFormat("[%s]值不可为以下内容：[%s]", fieldName, inValuesStr)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file111" style="display: none">package validator

import (
        "reflect"
        "time"

        "github.com/aid297/aid/operation"
)

func (my *ValidatorApp[T]) checkTime(rule, fieldName string, value any) error <span class="cov0" title="0">{
        if reflect.TypeOf(value).Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                if reflect.ValueOf(value).IsNil() </span><span class="cov0" title="0">{
                        return operation.Ternary(rule == "required", RequiredErr.New(fieldName), nil)
                }</span>
                <span class="cov0" title="0">value = reflect.ValueOf(value).Elem().Interface()</span>
        }

        <span class="cov0" title="0">if !reflect.DeepEqual(value, time.Time{}) </span><span class="cov0" title="0">{
                return TimeErr.NewFormat("[%s]必须是时间类型", fieldName)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file112" style="display: none">package validator

import (
        "reflect"
        "strings"

        "github.com/spf13/cast"

        "github.com/aid297/aid/array"
        "github.com/aid297/aid/operation"

        "github.com/aid297/aid/common"
)

// checkUint 验证：uint -&gt; 支持的规则 required、size&lt;、size&lt;=、size&gt;、size&gt;=、range=
func (my *ValidatorApp[T]) checkUint(rule, fieldName string, value any) error <span class="cov0" title="0">{
        if reflect.TypeOf(value).Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                if reflect.ValueOf(value).IsNil() </span><span class="cov0" title="0">{
                        return operation.Ternary(rule == "required", RequiredErr.New(fieldName), nil)
                }</span>
                <span class="cov0" title="0">value = reflect.ValueOf(value).Elem().Interface()</span>
        }

        <span class="cov0" title="0">switch </span>{
        case strings.HasPrefix(rule, "size&lt;="):<span class="cov0" title="0">
                small := strings.TrimPrefix(rule, "size&lt;=")
                if value.(uint) &lt;= common.ToUint(small) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能小于等于[%d]", fieldName, common.ToInt(small))
                }</span>
        case strings.HasPrefix(rule, "size&lt;"):<span class="cov0" title="0">
                small := strings.TrimPrefix(rule, "size&lt;")
                if value.(uint) &lt; common.ToUint(small) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能小于[%d]", fieldName, common.ToInt(small))
                }</span>
        case strings.HasPrefix(rule, "size&gt;="):<span class="cov0" title="0">
                large := strings.TrimPrefix(rule, "size&gt;=")
                if value.(uint) &gt;= common.ToUint(large) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能大于等于[%d]", fieldName, common.ToInt(large))
                }</span>
        case strings.HasPrefix(rule, "size&gt;"):<span class="cov0" title="0">
                large := strings.TrimPrefix(rule, "size&gt;")
                if value.(uint) &gt; common.ToUint(large) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能大于[%d]", fieldName, common.ToInt(large))
                }</span>
        case strings.HasPrefix(rule, "size="):<span class="cov0" title="0">
                size := strings.TrimPrefix(rule, "size=")
                if value.(uint) != common.ToUint(size) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须等于[%d]", fieldName, common.ToInt(size))
                }</span>
        case strings.HasPrefix(rule, "size!="):<span class="cov0" title="0">
                size := strings.TrimPrefix(rule, "size!=")
                if value.(uint) == common.ToUint(size) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须不等于[%d]", fieldName, common.ToInt(size))
                }</span>
        case strings.HasPrefix(rule, "range="):<span class="cov0" title="0">
                between := strings.TrimPrefix(rule, "range=")
                betweenRange := strings.Split(between, ",")
                if len(betweenRange) != 2 </span><span class="cov0" title="0">{
                        return RuleErr.NewFormat("[%s]规则定义错误#4，规则格式[d,d]", fieldName)
                }</span>
                <span class="cov0" title="0">small := common.ToUint(betweenRange[0])
                large := common.ToUint(betweenRange[1])
                if value.(uint) &lt; small || value.(uint) &gt; large </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须在[%d~%d]之间", fieldName, small, large)
                }</span>
        case strings.HasPrefix(rule, "in="):<span class="cov0" title="0">
                inValuesStr := strings.TrimPrefix(rule, "in=")
                inValuesArr := array.Cast(array.New(strings.Split(inValuesStr, ",")), func(value string) uint </span><span class="cov0" title="0">{ return cast.ToUint(value) }</span>)
                <span class="cov0" title="0">if !inValuesArr.In(value.(uint)) </span><span class="cov0" title="0">{
                        return ValidateErr.NewFormat("[%s]值必须在[%s]中", fieldName, inValuesStr)
                }</span>
        case strings.HasPrefix(rule, "not-in="):<span class="cov0" title="0">
                inValuesStr := strings.TrimPrefix(rule, "not-in=")
                inValuesArr := array.Cast(array.New(strings.Split(inValuesStr, ",")), func(value string) uint </span><span class="cov0" title="0">{ return cast.ToUint(value) }</span>)
                <span class="cov0" title="0">if inValuesArr.In(value.(uint)) </span><span class="cov0" title="0">{
                        return ValidateErr.NewFormat("[%s]值不可为以下内容：[%s]", fieldName, inValuesStr)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// checkUint8 验证：uint8 -&gt; 支持的规则 required、size&lt;、size&lt;=、size&gt;、size&gt;=、range=
func (my *ValidatorApp[T]) checkUint8(rule, fieldName string, value any) error <span class="cov0" title="0">{
        if reflect.TypeOf(value).Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                if reflect.ValueOf(value).IsNil() </span><span class="cov0" title="0">{
                        return operation.Ternary(rule == "required", RequiredErr.New(fieldName), nil)
                }</span>
                <span class="cov0" title="0">value = reflect.ValueOf(value).Elem().Interface()</span>
        }

        <span class="cov0" title="0">switch </span>{
        case strings.HasPrefix(rule, "size&lt;="):<span class="cov0" title="0">
                small := strings.TrimPrefix(rule, "size&lt;=")
                if value.(uint8) &lt;= common.ToUint8(small) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能小于等于[%d]", fieldName, common.ToInt(small))
                }</span>
        case strings.HasPrefix(rule, "size&lt;"):<span class="cov0" title="0">
                small := strings.TrimPrefix(rule, "size&lt;")
                if value.(uint8) &lt; common.ToUint8(small) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能小于[%d]", fieldName, common.ToInt(small))
                }</span>
        case strings.HasPrefix(rule, "size&gt;="):<span class="cov0" title="0">
                large := strings.TrimPrefix(rule, "size&gt;=")
                if value.(uint8) &gt;= common.ToUint8(large) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能大于等于[%d]", fieldName, common.ToInt(large))
                }</span>
        case strings.HasPrefix(rule, "size&gt;"):<span class="cov0" title="0">
                large := strings.TrimPrefix(rule, "size&gt;")
                if value.(uint8) &gt; common.ToUint8(large) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能大于[%d]", fieldName, common.ToInt(large))
                }</span>
        case strings.HasPrefix(rule, "size="):<span class="cov0" title="0">
                size := strings.TrimPrefix(rule, "size=")
                if value.(uint8) != common.ToUint8(size) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须等于[%d]", fieldName, common.ToInt(size))
                }</span>
        case strings.HasPrefix(rule, "size!="):<span class="cov0" title="0">
                size := strings.TrimPrefix(rule, "size!=")
                if value.(uint8) == common.ToUint8(size) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须不等于[%d]", fieldName, common.ToInt(size))
                }</span>
        case strings.HasPrefix(rule, "range="):<span class="cov0" title="0">
                between := strings.TrimPrefix(rule, "range=")
                betweenRange := strings.Split(between, ",")
                if len(betweenRange) != 2 </span><span class="cov0" title="0">{
                        return RuleErr.NewFormat("[%s]规则定义错误#4，规则格式[d,d]", fieldName)
                }</span>
                <span class="cov0" title="0">small := common.ToUint8(betweenRange[0])
                large := common.ToUint8(betweenRange[1])
                if value.(uint8) &lt; small || value.(uint8) &gt; large </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须在[%d~%d]之间", fieldName, small, large)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// checkUint16 验证：uint16 -&gt; 支持的规则 required、size&lt;、size&lt;=、size&gt;、size&gt;=、range=
func (my *ValidatorApp[T]) checkUint16(rule, fieldName string, value any) error <span class="cov0" title="0">{
        if reflect.TypeOf(value).Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                if reflect.ValueOf(value).IsNil() </span><span class="cov0" title="0">{
                        return operation.Ternary(rule == "required", RequiredErr.New(fieldName), nil)
                }</span>
                <span class="cov0" title="0">value = reflect.ValueOf(value).Elem().Interface()</span>
        }

        <span class="cov0" title="0">switch </span>{
        case strings.HasPrefix(rule, "size&lt;="):<span class="cov0" title="0">
                small := strings.TrimPrefix(rule, "size&lt;=")
                if value.(uint16) &lt;= common.ToUint16(small) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能小于等于[%d]", fieldName, common.ToInt(small))
                }</span>
        case strings.HasPrefix(rule, "size&lt;"):<span class="cov0" title="0">
                small := strings.TrimPrefix(rule, "size&lt;")
                if value.(uint16) &lt; common.ToUint16(small) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能小于[%d]", fieldName, common.ToInt(small))
                }</span>
        case strings.HasPrefix(rule, "size&gt;="):<span class="cov0" title="0">
                large := strings.TrimPrefix(rule, "size&gt;=")
                if value.(uint16) &gt;= common.ToUint16(large) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能大于等于[%d]", fieldName, common.ToInt(large))
                }</span>
        case strings.HasPrefix(rule, "size&gt;"):<span class="cov0" title="0">
                large := strings.TrimPrefix(rule, "size&gt;")
                if value.(uint16) &gt; common.ToUint16(large) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能大于[%d]", fieldName, common.ToInt(large))
                }</span>
        case strings.HasPrefix(rule, "size="):<span class="cov0" title="0">
                size := strings.TrimPrefix(rule, "size=")
                if value.(uint16) != common.ToUint16(size) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须等于[%d]", fieldName, common.ToInt(size))
                }</span>
        case strings.HasPrefix(rule, "size!="):<span class="cov0" title="0">
                size := strings.TrimPrefix(rule, "size!=")
                if value.(uint16) == common.ToUint16(size) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须不等于[%d]", fieldName, common.ToInt(size))
                }</span>
        case strings.HasPrefix(rule, "range="):<span class="cov0" title="0">
                between := strings.TrimPrefix(rule, "range=")
                betweenRange := strings.Split(between, ",")
                if len(betweenRange) != 2 </span><span class="cov0" title="0">{
                        return RuleErr.NewFormat("[%s]规则定义错误#4，规则格式[d,d]", fieldName)
                }</span>
                <span class="cov0" title="0">small := common.ToUint16(betweenRange[0])
                large := common.ToUint16(betweenRange[1])
                if value.(uint16) &lt; small || value.(uint16) &gt; large </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须在[%d~%d]之间", fieldName, small, large)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// checkUint32 验证：uint32 -&gt; 支持的规则 required、size&lt;、size&lt;=、size&gt;、size&gt;=、range=
func (my *ValidatorApp[T]) checkUint32(rule, fieldName string, value any) error <span class="cov0" title="0">{
        if reflect.TypeOf(value).Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                if reflect.ValueOf(value).IsNil() </span><span class="cov0" title="0">{
                        return operation.Ternary(rule == "required", RequiredErr.New(fieldName), nil)
                }</span>
                <span class="cov0" title="0">value = reflect.ValueOf(value).Elem().Interface()</span>
        }

        <span class="cov0" title="0">switch </span>{
        case strings.HasPrefix(rule, "size&lt;="):<span class="cov0" title="0">
                small := strings.TrimPrefix(rule, "size&lt;=")
                if value.(uint32) &lt;= common.ToUint32(small) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能小于等于[%d]", fieldName, common.ToInt(small))
                }</span>
        case strings.HasPrefix(rule, "size&lt;"):<span class="cov0" title="0">
                small := strings.TrimPrefix(rule, "size&lt;")
                if value.(uint32) &lt; common.ToUint32(small) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能小于[%d]", fieldName, common.ToInt(small))
                }</span>
        case strings.HasPrefix(rule, "size&gt;="):<span class="cov0" title="0">
                large := strings.TrimPrefix(rule, "size&gt;=")
                if value.(uint32) &gt;= common.ToUint32(large) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能大于等于[%d]", fieldName, common.ToInt(large))
                }</span>
        case strings.HasPrefix(rule, "size&gt;"):<span class="cov0" title="0">
                large := strings.TrimPrefix(rule, "size&gt;")
                if value.(uint32) &gt; common.ToUint32(large) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能大于[%d]", fieldName, common.ToInt(large))
                }</span>
        case strings.HasPrefix(rule, "size="):<span class="cov0" title="0">
                size := strings.TrimPrefix(rule, "size=")
                if value.(uint32) != common.ToUint32(size) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须等于[%d]", fieldName, common.ToInt(size))
                }</span>
        case strings.HasPrefix(rule, "size!="):<span class="cov0" title="0">
                size := strings.TrimPrefix(rule, "size!=")
                if value.(uint32) == common.ToUint32(size) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须不等于[%d]", fieldName, common.ToInt(size))
                }</span>
        case strings.HasPrefix(rule, "range="):<span class="cov0" title="0">
                between := strings.TrimPrefix(rule, "range=")
                betweenRange := strings.Split(between, ",")
                if len(betweenRange) != 2 </span><span class="cov0" title="0">{
                        return RuleErr.NewFormat("[%s]规则定义错误#4，规则格式[d,d]", fieldName)
                }</span>
                <span class="cov0" title="0">small := common.ToUint32(betweenRange[0])
                large := common.ToUint32(betweenRange[1])
                if value.(uint32) &lt; small || value.(uint32) &gt; large </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须在[%d~%d]之间", fieldName, small, large)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// checkUint64 验证：uint64 -&gt; 支持的规则 required、size&lt;、size&lt;=、size&gt;、size&gt;=、range=
func (my *ValidatorApp[T]) checkUint64(rule, fieldName string, value any) error <span class="cov0" title="0">{
        if reflect.TypeOf(value).Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                if reflect.ValueOf(value).IsNil() </span><span class="cov0" title="0">{
                        return operation.Ternary(rule == "required", RequiredErr.New(fieldName), nil)
                }</span>
                <span class="cov0" title="0">value = reflect.ValueOf(value).Elem().Interface()</span>
        }

        <span class="cov0" title="0">switch </span>{
        case strings.HasPrefix(rule, "size&lt;="):<span class="cov0" title="0">
                small := strings.TrimPrefix(rule, "size&lt;=")
                if value.(uint64) &lt;= common.ToUint64(small) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能小于等于[%d]", fieldName, common.ToInt(small))
                }</span>
        case strings.HasPrefix(rule, "size&lt;"):<span class="cov0" title="0">
                small := strings.TrimPrefix(rule, "size&lt;")
                if value.(uint64) &lt; common.ToUint64(small) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能小于[%d]", fieldName, common.ToInt(small))
                }</span>
        case strings.HasPrefix(rule, "size&gt;="):<span class="cov0" title="0">
                large := strings.TrimPrefix(rule, "size&gt;=")
                if value.(uint64) &gt;= common.ToUint64(large) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能大于等于[%d]", fieldName, common.ToInt(large))
                }</span>
        case strings.HasPrefix(rule, "size&gt;"):<span class="cov0" title="0">
                large := strings.TrimPrefix(rule, "size&gt;")
                if value.(uint64) &gt; common.ToUint64(large) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度不能大于[%d]", fieldName, common.ToInt(large))
                }</span>
        case strings.HasPrefix(rule, "size="):<span class="cov0" title="0">
                size := strings.TrimPrefix(rule, "size=")
                if value.(uint64) != common.ToUint64(size) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须等于[%d]", fieldName, common.ToInt(size))
                }</span>
        case strings.HasPrefix(rule, "size!="):<span class="cov0" title="0">
                size := strings.TrimPrefix(rule, "size!=")
                if value.(uint64) == common.ToUint64(size) </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须不等于[%d]", fieldName, common.ToInt(size))
                }</span>
        case strings.HasPrefix(rule, "range="):<span class="cov0" title="0">
                between := strings.TrimPrefix(rule, "range=")
                betweenRange := strings.Split(between, ",")
                if len(betweenRange) != 2 </span><span class="cov0" title="0">{
                        return RuleErr.NewFormat("[%s]规则定义错误#4，规则格式[d,d]", fieldName)
                }</span>
                <span class="cov0" title="0">small := common.ToUint64(betweenRange[0])
                large := common.ToUint64(betweenRange[1])
                if value.(uint64) &lt; small || value.(uint64) &gt; large </span><span class="cov0" title="0">{
                        return LengthErr.NewFormat("[%s]长度必须在[%d~%d]之间", fieldName, small, large)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file113" style="display: none">package httpAPI

import (
        "net/http"
        "time"

        "github.com/aid297/aid/web/backend/aid-web-backend-gin/global"
        "github.com/aid297/aid/web/backend/aid-web-backend-gin/module/httpModule"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

type HealthAPI struct{}

var healthRes = httpModule.HealthResponse{
        Time: httpModule.HealthTime{
                Now:    time.Now(),
                String: time.Now().Format(time.DateTime),
        },
        System: httpModule.HealthSystem{
                Debug:    global.CONFIG.System.Debug,
                Version:  global.CONFIG.System.Version,
                Daemon:   global.CONFIG.System.Daemon,
                Timezone: global.CONFIG.System.Timezone,
        },
        WebService: httpModule.HealthWebService{
                Cors: global.CONFIG.WebService.Cors,
        },
        VSCodeLaunch: httpModule.HealthVSCode{
                Version: "0.2.0",
                Configurations: []httpModule.HealthVSCodeConfiguration{
                        {
                                Name:    "Launch HA-BACKEND",
                                Type:    "go",
                                Request: "launch",
                                Mode:    "auto",
                                Program: "main.go",
                                Env:     map[string]string{"HR_BACKEND_CONFIG": "config.json"},
                                Args: []string{
                                        "-C=config.json",
                                        "-M=web-service",
                                        "-D=false",
                                },
                                BuildFlags: []string{"-tags=jsoniter"},
                        },
                },
        },
}

// JSON 健康检查 JSON 格式
// * URL ANY /health/json
func (HealthAPI) JSON(c *gin.Context) <span class="cov0" title="0">{
        global.LOG.Info("获取支持的UUID版本", zap.Any("ANY /health/json", "生成UUID成功"))
        c.JSON(http.StatusOK, healthRes)
}</span>

// JSON 健康检查 JSON 格式
// * URL ANY /health/yaml
func (HealthAPI) YAML(c *gin.Context) <span class="cov0" title="0">{
        global.LOG.Info("获取支持的UUID版本", zap.Any("ANY /health/yaml", "生成UUID成功"))
        c.YAML(http.StatusOK, healthRes)
}</span>

// JSON 健康检查 JSON 格式
// * URL ANY /health/toml
func (HealthAPI) TOML(c *gin.Context) <span class="cov0" title="0">{
        global.LOG.Info("获取支持的UUID版本", zap.Any("ANY /health/toml", "生成UUID成功"))
        c.TOML(http.StatusOK, healthRes)
}</span>
</pre>
		
		<pre class="file" id="file114" style="display: none">package v1HTTPAPI

import (
        "archive/zip"
        "bytes"
        "fmt"
        "io"
        "mime/multipart"
        "os"

        "github.com/aid297/aid/web/backend/aid-web-backend-gin/module/httpModule"

        "github.com/aid297/aid/web/backend/aid-web-backend-gin/global"

        "github.com/aid297/aid/filesystem/filesystemV2"
        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

type RezipAPI struct{}

func (RezipAPI) Upload(c *gin.Context) <span class="cov0" title="0">{
        var (
                title     = "重新压缩"
                file      *multipart.FileHeader
                err       error
                srcFile   multipart.File
                buf       []byte
                zipReader *zip.Reader
                rc        io.ReadCloser
        )

        if file, err = c.FormFile("f"); err != nil </span><span class="cov0" title="0">{
                global.LOG.Error(title, zap.Errors("上传文件", []error{err}))
                httpModule.NewForbidden().SetMsg("上传文件失败").WithAccept(c)
                return
        }</span>

        // 打开上传文件
        <span class="cov0" title="0">srcFile, err = file.Open()
        if err != nil </span><span class="cov0" title="0">{
                global.LOG.Error(title, zap.Errors("打开文件", []error{err}))
                httpModule.NewForbidden().SetErrorf("打开文件失败：%w", err).WithAccept(c)
                return
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = srcFile.Close() }</span>()

        // 读到内存
        <span class="cov0" title="0">buf = make([]byte, file.Size)
        if _, err = io.ReadFull(srcFile, buf); err != nil </span><span class="cov0" title="0">{
                global.LOG.Error(title, zap.Errors("读取文件", []error{err}))
                httpModule.NewForbidden().SetErrorf("读取文件失败：%w", err).WithAccept(c)
                return
        }</span>

        // 创建 zip reader
        <span class="cov0" title="0">zipReader, err = zip.NewReader(bytes.NewReader(buf), file.Size)
        if err != nil </span><span class="cov0" title="0">{
                global.LOG.Error(title, zap.Errors("创建zip reader", []error{err}))
                httpModule.NewForbidden().SetErrorf("创建zip容器失败：%w", err).WithAccept(c)
                return
        }</span>

        // 准备写入新 zip 到内存
        <span class="cov0" title="0">var outBuf bytes.Buffer
        zipWriter := zip.NewWriter(&amp;outBuf)

        for _, f := range zipReader.File </span><span class="cov0" title="0">{
                if f.FileInfo().IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }

                // 打开原文件
                <span class="cov0" title="0">rc, err = f.Open()
                if err != nil </span><span class="cov0" title="0">{
                        global.LOG.Error(title, zap.Errors("读取压缩包文件", []error{err}))
                        httpModule.NewForbidden().SetErrorf("读取压缩包文件失败：%w", err).WithAccept(c)
                        return
                }</span>

                // 创建新 zip 内的文件条目
                <span class="cov0" title="0">header := &amp;zip.FileHeader{Name: f.Name, Method: zip.Deflate}
                header.SetModTime(f.ModTime())
                header.SetMode(f.Mode())
                w, err := zipWriter.CreateHeader(header)
                if err != nil </span><span class="cov0" title="0">{
                        _ = rc.Close()
                        global.LOG.Error(title, zap.Errors("重建压缩文件", []error{err}))
                        httpModule.NewForbidden(httpModule.Errorf("重建压缩文件失败：%w", err)).WithAccept(c)
                        return
                }</span>

                // 拷贝内容
                <span class="cov0" title="0">if _, err := io.Copy(w, rc); err != nil </span><span class="cov0" title="0">{
                        _ = rc.Close()
                        global.LOG.Error(title, zap.Errors("拷贝压缩文件内容", []error{err}))
                        httpModule.NewForbidden().SetErrorf("拷贝压缩文件内容失败：%w", err).WithAccept(c)
                        return
                }</span>
                <span class="cov0" title="0">_ = rc.Close()</span>
        }

        // 关闭 zip writer
        <span class="cov0" title="0">if err = zipWriter.Close(); err != nil </span><span class="cov0" title="0">{
                global.LOG.Error(title, zap.Errors("保存新压缩文件", []error{err}))
                httpModule.NewForbidden().SetErrorf("保存新压缩文件失败：%w", err).WithAccept(c)
                return
        }</span>

        <span class="cov0" title="0">fs := filesystemV2.FileApp.NewByRel(fmt.Sprintf("%s/repacked.zip", global.CONFIG.Rezip.OutDir))
        global.LOG.Info(title, zap.String("保存路径", fs.GetFullPath()))
        if err = os.MkdirAll(fs.GetBasePath(), os.ModePerm); err != nil </span><span class="cov0" title="0">{
                global.LOG.Error(title, zap.Errors("创建目录", []error{err}))
                httpModule.NewForbidden().SetErrorf("创建目录失败：%w", err).WithAccept(c)
                return
        }</span>

        // 保存到本地文件
        <span class="cov0" title="0">if err = os.WriteFile(fs.GetFullPath(), outBuf.Bytes(), 0644); err != nil </span><span class="cov0" title="0">{
                global.LOG.Error(title, zap.Errors("保存压缩文件", []error{err}))
                httpModule.NewForbidden().SetErrorf("保存压缩文件失败：%w", err).WithAccept(c)
                return
        }</span>

        <span class="cov0" title="0">httpModule.NewOK().SetMsg("上传成功").SetData(gin.H{"to": c.Request.Host + "/upload/rezip/repacked.zip"}).WithAccept(c)</span>
}
</pre>
		
		<pre class="file" id="file115" style="display: none">package v1HTTPAPI

import (
        "github.com/aid297/aid/web/backend/aid-web-backend-gin/module/httpModule"
        "github.com/aid297/aid/web/backend/aid-web-backend-gin/service/httpService/v1HTTPService"

        "github.com/aid297/aid/web/backend/aid-web-backend-gin/global"
        "github.com/aid297/aid/web/backend/aid-web-backend-gin/module/httpModule/v1HTTPModule/request"
        "github.com/aid297/aid/web/backend/aid-web-backend-gin/module/httpModule/v1HTTPModule/response"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

type UUIDAPI struct{}

// Generate 批量生成uuid
// * URL POST /api/v1/uuid/generate
func (UUIDAPI) Generate(c *gin.Context) <span class="cov0" title="0">{
        var (
                title = "批量生成uuid"
                err   error
                form  request.UUIDGenerateRequest
                uuids []response.UUIDResponse
        )

        if form, err = request.UUIDGenerate.Bind(c); err != nil </span><span class="cov0" title="0">{
                global.LOG.Error(title, zap.Any("表单验证", err))
                httpModule.NewForbidden().SetErrorf("表单验证失败：%w", err).WithAccept(c)
                return
        }</span>

        <span class="cov0" title="0">uuids = make([]response.UUIDResponse, form.Number)

        for idx := range form.Number </span><span class="cov0" title="0">{
                if uuids[idx], err = v1HTTPService.UUID.GenerateOne(&amp;form); err != nil </span><span class="cov0" title="0">{
                        global.LOG.Error(title, zap.Any("生成UUID失败", err.Error()))
                        httpModule.NewForbidden(httpModule.Errorf("生成UUID失败：%w", err)).WithAccept(c)
                        return
                }</span>
        }

        <span class="cov0" title="0">global.LOG.Info(title, zap.Any("POST /api/v1/uuid/generate", "生成UUID成功"))
        httpModule.NewOK().SetData(response.UUIDGenerateResponse{UUIDs: uuids}).WithAccept(c)</span>
}

// Versions 获取支持的UUID版本
// * URL POST /api/v1/uuid/versions
func (UUIDAPI) Versions(c *gin.Context) <span class="cov0" title="0">{
        global.LOG.Info("获取支持的UUID版本", zap.Any("POST /api/v1/uuid/versions", "生成UUID成功"))
        httpModule.NewOK().SetData(response.UUIDVersionsResponse{
                Versions: map[string]string{
                        string(request.UUIDVersionV1): string(request.UUIDVersionV1),
                        string(request.UUIDVersionV4): string(request.UUIDVersionV4),
                        string(request.UUIDVersionV6): string(request.UUIDVersionV6),
                        string(request.UUIDVersionV7): string(request.UUIDVersionV7),
                },
        }).WithAccept(c)
}</span>
</pre>
		
		<pre class="file" id="file116" style="display: none">package command

import "fmt"

type HelpCommand struct{}

var (
        Help      HelpCommand
        helpTexts = []string{
                `1. 启动参数说明：`,
                `    1.1. -C`,
                `        是否必填：可选`,
                `        含义：配置文件所在路径`,
                `        配置方法：1、设置环境变量："HR_BACKEND_CONFIG" 。2、配置命令行参数：-C xxx.[json|yaml|toml]。3、默认值：config.yaml`,
                `        优先级：命令行参数 &gt; 环境变量 &gt; 默认值(config.yaml)`,
                `    1.2. -M`,
                `        是否必填：可选`,
                `        含义：启动服务模块。 web-service=开启web服务。默认开启 web-service 服务`,
                `    1.3. -D`,
                `        是否必填：可选`,
                `        含义：是否以守护进程方式启动程序`,
                `        配置方法：1、命令行参数：-D=true|false。2、配置文件 system.daemon 字段指定 true|false。3、默认值：false`,
                `        优先级：命令行参数 &gt; 配置文件 &gt; 默认值(false)`,
                `2. 配置参数说明：`,
                `    2.1. system.debug`,
                `        含义：是否开启 Debug 模式。true=开启 Debug 模式，false=开启 Release 模式。Release 模式下绑定路由不会输出到控制台`,
                `    2.2. log.zap.in-console`,
                `        含义：zap 日志是否输出到控制台。true=输出到控制台，false=不输出到控制台`,
                `        备注：system.debug || log.zap.in-console 为 true 时，日志会输出到控制台。也就是说：如果是 Debug 模式，日志一定会输出到控制台。如果是 Release 模式，则根据 log.zap.in-console 配置决定是否输出到控制台`,
        }
)

func (HelpCommand) Launch() <span class="cov0" title="0">{
        for idx := range helpTexts </span><span class="cov0" title="0">{
                fmt.Println(helpTexts[idx])
        }</span>
}
</pre>
		
		<pre class="file" id="file117" style="display: none">package command

import (
        "log"

        "github.com/aid297/aid/web/backend/aid-web-backend-gin/global"
        "github.com/aid297/aid/web/backend/aid-web-backend-gin/route"

        "github.com/aid297/aid/str"
        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

type WebServiceCommand struct{}

var WebService WebServiceCommand

func (WebServiceCommand) Launch() <span class="cov0" title="0">{
        if global.CONFIG.System.Debug </span><span class="cov0" title="0">{
                gin.SetMode(gin.DebugMode)
                global.LOG.Warn("当前运行在 Debug 模式，Gin 使用 Debug 模式")
        }</span> else<span class="cov0" title="0"> {
                gin.SetMode(gin.ReleaseMode)
                global.LOG.Warn("当前运行在 非 Debug 模式，Gin 使用 Release 模式")
        }</span>

        <span class="cov0" title="0">app := gin.Default()
        route.Index.Register(app)

        // 启动web-service服务
        if err := app.Run(str.APP.Buffer.JoinString(":", global.CONFIG.WebService.Port)); err != nil </span><span class="cov0" title="0">{
                global.LOG.Error("启动web服务", zap.Error(err))
                log.Fatalf("【启动web服务错误】%s", err.Error())
        }</span>
}
</pre>
		
		<pre class="file" id="file118" style="display: none">package initialize

import (
        "github.com/aid297/aid/web/backend/aid-web-backend-gin/global"

        "github.com/aid297/aid/setting"
        "github.com/aid297/aid/str"
        "github.com/fsnotify/fsnotify"
        "github.com/spf13/viper"
)

type ConfigInit struct{}

var Config ConfigInit

func (ConfigInit) Launch(consolePath string) <span class="cov0" title="0">{
        setting.APP.Setting.New(
                setting.ConfigFilename(consolePath),
                setting.EnvName(global.ENV_CONFIG),
                setting.Content(&amp;global.CONFIG),
                setting.OnChange(func(v *viper.Viper, e fsnotify.Event) </span><span class="cov0" title="0">{
                        var err error
                        global.LOG.Info(str.APP.Buffer.JoinString("配置文件改变：", e.Name))
                        if err = v.Unmarshal(&amp;global.CONFIG); err != nil </span><span class="cov0" title="0">{
                                global.LOG.Error(str.APP.Buffer.JoinString("更新配置文件失败：", err.Error()))
                        }</span>
                }),
        )
}
</pre>
		
		<pre class="file" id="file119" style="display: none">package initialize

import (
        "log"
        "time"

        "github.com/aid297/aid/web/backend/aid-web-backend-gin/global"

        "go.uber.org/zap"
)

type TimezoneInit struct{}

var Timezone TimezoneInit

func (TimezoneInit) Launch() <span class="cov0" title="0">{
        if global.CONFIG.System.Timezone != "" </span><span class="cov0" title="0">{
                if timezoneL, err := time.LoadLocation(global.CONFIG.System.Timezone); err != nil </span><span class="cov0" title="0">{
                        global.LOG.Error("加载时区失败", zap.String("timezone", global.CONFIG.System.Timezone), zap.Error(err))
                        log.Fatalf("设置时区失败：%s", err)
                }</span> else<span class="cov0" title="0"> {
                        time.Local = timezoneL
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file120" style="display: none">package initialize

import (
        "log"
        "strings"

        "github.com/aid297/aid/logger"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"

        "github.com/aid297/aid/web/backend/aid-web-backend-gin/global"
)

type ZapInit struct{}

var Zap ZapInit

func (ZapInit) Launch() <span class="cov0" title="0">{
        var (
                err       error
                zapLevels = map[string]zapcore.Level{
                        "debug": zap.DebugLevel,
                        "info":  zap.InfoLevel,
                        "warn":  zap.WarnLevel,
                        "error": zap.ErrorLevel,
                        "panic": zap.PanicLevel,
                        "fatal": zap.FatalLevel,
                }
        )

        if global.LOG, err = logger.APP.Zap.New(
                logger.APP.ZapConfig.New(zapLevels[global.CONFIG.Log.Zap.Level]).
                        SetEncoderType(logger.EncoderType(strings.ToUpper(global.CONFIG.Log.Zap.EncoderType))).
                        SetExtension(global.CONFIG.Log.Zap.Extension).
                        SetInConsole(global.CONFIG.System.Debug || global.CONFIG.Log.Zap.InConsole).
                        SetMaxSize(global.CONFIG.Log.Zap.MaxSize).
                        SetMaxDay(global.CONFIG.Log.Zap.MaxDay).
                        SetPathAbs(global.CONFIG.Log.Zap.DirAbs).
                        SetPath(global.CONFIG.Log.Zap.Dir),
        ); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("【启动日志失败】 %s", err.Error())
        }</span>
}
</pre>
		
		<pre class="file" id="file121" style="display: none">package main

import (
        "flag"
        "strings"

        "github.com/aid297/aid/web/backend/aid-web-backend-gin/command"
        "github.com/aid297/aid/web/backend/aid-web-backend-gin/global"
        "github.com/aid297/aid/web/backend/aid-web-backend-gin/initialize"

        "github.com/aid297/aid/daemon"
        "github.com/spf13/cast"
)

type consoleArgs struct {
        commandName   string
        configPath    string
        daemonStr     string
        commandParams []string
}

func parseArgs() consoleArgs <span class="cov0" title="0">{
        var (
                originalCommand, commandName, configPath string
                commandParams, originalCommands          []string
                daemonStr                                string
        )
        flag.StringVar(&amp;configPath, "C", "config.yaml", "配置文件路径")
        flag.StringVar(&amp;originalCommand, "M", "", "命令终端参数")
        flag.StringVar(&amp;daemonStr, "D", "false", "是否开启守护进程")
        flag.Parse()

        commandName = ""
        commandParams = make([]string, 0)

        if originalCommand != "" </span><span class="cov0" title="0">{
                originalCommands = strings.Split(originalCommand, " ")
                commandName = originalCommands[0]
                commandParams = originalCommands[1:]
        }</span>

        <span class="cov0" title="0">return consoleArgs{
                commandName:   commandName,
                configPath:    configPath,
                daemonStr:     daemonStr,
                commandParams: commandParams,
        }</span>
}

func main() <span class="cov0" title="0">{
        var consoleArgs = parseArgs()

        initialize.Config.Launch(consoleArgs.configPath)
        initialize.Zap.Launch()
        initialize.Timezone.Launch()

        launch(consoleArgs)
}</span>

// launch 启动程序
func launch(consoleArgs consoleArgs) <span class="cov0" title="0">{
        if cast.ToBool(consoleArgs.daemonStr) || global.CONFIG.System.Daemon </span><span class="cov0" title="0">{
                daemon.APP.Daemon.Launch("启动程序", global.CONFIG.Log.Daemon.Dir, global.CONFIG.Log.Daemon.Filename) // 通过守护进程启动
        }</span>

        <span class="cov0" title="0">switch consoleArgs.commandName </span>{
        case "help":<span class="cov0" title="0">
                command.Help.Launch()</span>
        case "web-service":<span class="cov0" title="0">
                command.WebService.Launch()</span>
        default:<span class="cov0" title="0">
                command.WebService.Launch()</span>
        }
}
</pre>
		
		<pre class="file" id="file122" style="display: none">package httpMiddleware

import (
        "runtime/debug"

        "github.com/aid297/aid/web/backend/aid-web-backend-gin/module/httpModule"

        "github.com/gin-gonic/gin"
)

func RecoverHandler(c *gin.Context) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        switch err := r.(type) </span>{
                        case error:<span class="cov0" title="0">
                                httpModule.NewInternalServerError().SetErrorf("意外错误：%w", err).WithAccept(c)</span>
                        }
                        <span class="cov0" title="0">debug.PrintStack()

                        c.Abort()</span>
                }
        }()

        <span class="cov0" title="0">c.Next()</span>
}
</pre>
		
		<pre class="file" id="file123" style="display: none">package v1HTTPMiddleware

import (
        "time"

        "github.com/gin-contrib/cors"
        "github.com/gin-gonic/gin"
)

// Cors 返回一个配置好的跨域中间件
func Cors() gin.HandlerFunc <span class="cov0" title="0">{
        return cors.New(cors.Config{
                AllowAllOrigins:  true,
                AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS", "HEAD"},
                AllowHeaders:     []string{"Origin", "Content-Type", "Authorization", "AccessToken", "X-CSRF-Token", "Token", "X-Token", "X-User-Id", "Accept", "X-Requested-With"},
                ExposeHeaders:    []string{"Content-Length", "Access-Control-Allow-Origin", "Access-Control-Allow-Headers", "Content-Type", "Set-Token", "Set-Expires-At"},
                AllowCredentials: true,
                MaxAge:           12 * time.Hour,
        })
}</span>
</pre>
		
		<pre class="file" id="file124" style="display: none">package v1HTTPMiddleware

import (
        "net/http"
        "time"

        "github.com/aid297/aid/operation/operationV2"
        "github.com/gin-contrib/timeout"
        "github.com/gin-gonic/gin"
        "github.com/spf13/cast"
)

func Timeout(second time.Duration) gin.HandlerFunc <span class="cov0" title="0">{
        return func(ctx *gin.Context) </span><span class="cov0" title="0">{
                keepalive := cast.ToDuration(ctx.GetHeader("keep-alive"))
                timeout.New(
                        timeout.WithTimeout(operationV2.NewTernary(operationV2.TrueValue(keepalive), operationV2.FalseValue(second)).GetByValue(keepalive &gt; 0)*time.Second),
                        timeout.WithResponse(func(c *gin.Context) </span><span class="cov0" title="0">{
                                c.JSON(http.StatusRequestTimeout, gin.H{"code": 0, "status": http.StatusRequestTimeout, "data": nil, "msg": "请求超时"})
                        }</span>),
                )
        }
}
</pre>
		
		<pre class="file" id="file125" style="display: none">package httpModule

import (
        "fmt"
        "net/http"

        "github.com/gin-gonic/gin"
)

// ******************** HTTPResponse 定义 ******************** //
type HTTPResponse struct {
        Code int    `json:"code"`
        Msg  string `json:"msg"`
        Data any    `json:"data"`
}

func New(attrs ...HTTPResponseAttributer) HTTPResponse <span class="cov0" title="0">{
        ins := HTTPResponse{}
        for idx := range attrs </span><span class="cov0" title="0">{
                attrs[idx].Register(&amp;ins)
        }</span>
        <span class="cov0" title="0">return ins</span>
}

func (my HTTPResponse) SetAttrs(attrs ...HTTPResponseAttributer) HTTPResponse <span class="cov0" title="0">{
        for idx := range attrs </span><span class="cov0" title="0">{
                attrs[idx].Register(&amp;my)
        }</span>
        <span class="cov0" title="0">return my</span>
}

func NewOK(attrs ...HTTPResponseAttributer) HTTPResponse <span class="cov0" title="0">{ return New(OK()).SetAttrs(attrs...) }</span>
func NewCreated(attrs ...HTTPResponseAttributer) HTTPResponse <span class="cov0" title="0">{
        return New(Created()).SetAttrs(attrs...)
}</span>
func NewUpdated(attrs ...HTTPResponseAttributer) HTTPResponse <span class="cov0" title="0">{
        return New(Updated()).SetAttrs(attrs...)
}</span>
func NewDeleted(attrs ...HTTPResponseAttributer) HTTPResponse <span class="cov0" title="0">{
        return New(Deleted()).SetAttrs(attrs...)
}</span>
func NewUnauthorized(attrs ...HTTPResponseAttributer) HTTPResponse <span class="cov0" title="0">{
        return New(Unauthorized()).SetAttrs(attrs...)
}</span>
func NewUnPermission(attrs ...HTTPResponseAttributer) HTTPResponse <span class="cov0" title="0">{
        return New(UnPermission()).SetAttrs(attrs...)
}</span>
func NewForbidden(attrs ...HTTPResponseAttributer) HTTPResponse <span class="cov0" title="0">{
        return New(Forbidden()).SetAttrs(attrs...)
}</span>
func NewNotFound(attrs ...HTTPResponseAttributer) HTTPResponse <span class="cov0" title="0">{
        return New(NotFound()).SetAttrs(attrs...)
}</span>
func NewInternalServerError(attrs ...HTTPResponseAttributer) HTTPResponse <span class="cov0" title="0">{
        return New(InternalServerError()).SetAttrs(attrs...)
}</span>

func (my HTTPResponse) SetMsg(msg string) HTTPResponse <span class="cov0" title="0">{ return my.SetAttrs(Msg(msg)) }</span>

func (my HTTPResponse) SetError(err error) HTTPResponse <span class="cov0" title="0">{ return my.SetAttrs(Error(err)) }</span>

func (my HTTPResponse) SetErrorf(format string, a ...any) HTTPResponse <span class="cov0" title="0">{
        return my.SetAttrs(Errorf(format, a...))
}</span>

func (my HTTPResponse) SetData(data any) HTTPResponse <span class="cov0" title="0">{ return my.SetAttrs(Data(data)) }</span>

func (my HTTPResponse) Raw() (int, any) <span class="cov0" title="0">{ return my.Code, my }</span>

func (my HTTPResponse) WithAccept(c *gin.Context) <span class="cov0" title="0">{
        switch c.GetHeader("accept") </span>{
        case "application/json":<span class="cov0" title="0">
                my.JSON(c)</span>
        case "application/xml":<span class="cov0" title="0">
                my.XML(c)</span>
        case "application/yaml":<span class="cov0" title="0">
                my.YAML(c)</span>
        case "application/toml":<span class="cov0" title="0">
                my.TOML(c)</span>
        default:<span class="cov0" title="0">
                my.JSON(c)</span>
        }
}

func (my HTTPResponse) JSON(c *gin.Context) <span class="cov0" title="0">{ c.JSON(my.Code, my) }</span>
func (my HTTPResponse) YAML(c *gin.Context) <span class="cov0" title="0">{ c.YAML(my.Code, my) }</span>
func (my HTTPResponse) TOML(c *gin.Context) <span class="cov0" title="0">{ c.TOML(my.Code, my) }</span>
func (my HTTPResponse) XML(c *gin.Context)  <span class="cov0" title="0">{ c.XML(my.Code, my) }</span>

func (my HTTPResponse) WithoutCodeJSON(c *gin.Context) <span class="cov0" title="0">{ c.JSON(http.StatusOK, my) }</span>
func (my HTTPResponse) WithoutCodeYAML(c *gin.Context) <span class="cov0" title="0">{ c.YAML(http.StatusOK, my) }</span>
func (my HTTPResponse) WithoutCodeTOML(c *gin.Context) <span class="cov0" title="0">{ c.TOML(http.StatusOK, my) }</span>
func (my HTTPResponse) WithoutCodeXML(c *gin.Context)  <span class="cov0" title="0">{ c.XML(http.StatusOK, my) }</span>

// ******************** HTTPResponseAttributer 实现 ******************** //
type (
        HTTPResponseAttributer interface{ Register(res *HTTPResponse) }

        AttrCode struct {
                code int
                msg  string
        }
        AttrMsg  struct{ msg string }
        AttrData struct{ data any }
)

func OK() HTTPResponseAttributer      <span class="cov0" title="0">{ return AttrCode{code: http.StatusOK, msg: "操作成功"} }</span>
func Created() HTTPResponseAttributer <span class="cov0" title="0">{ return AttrCode{code: http.StatusCreated, msg: "新建成功"} }</span>
func Updated() HTTPResponseAttributer <span class="cov0" title="0">{
        return AttrCode{code: http.StatusAccepted, msg: "更新成功"}
}</span>
func Deleted() HTTPResponseAttributer <span class="cov0" title="0">{
        return AttrCode{code: http.StatusNoContent, msg: "删除成功"}
}</span>
func Unauthorized() HTTPResponseAttributer <span class="cov0" title="0">{
        return AttrCode{code: http.StatusUnauthorized, msg: "未登录"}
}</span>
func UnPermission() HTTPResponseAttributer <span class="cov0" title="0">{
        return AttrCode{code: http.StatusNotAcceptable, msg: "无权操作"}
}</span>
func Forbidden() HTTPResponseAttributer <span class="cov0" title="0">{
        return AttrCode{code: http.StatusForbidden, msg: "操作失败"}
}</span>
func NotFound() HTTPResponseAttributer <span class="cov0" title="0">{
        return AttrCode{code: http.StatusNotFound, msg: "资源不存在"}
}</span>
func InternalServerError() HTTPResponseAttributer <span class="cov0" title="0">{
        return AttrCode{code: http.StatusInternalServerError, msg: "服务器内部错误"}
}</span>
func (my AttrCode) Register(res *HTTPResponse) <span class="cov0" title="0">{ res.Code = my.code; res.Msg = my.msg }</span>

func Msg(msg string) HTTPResponseAttributer                 <span class="cov0" title="0">{ return AttrMsg{msg: msg} }</span>
func Error(err error) HTTPResponseAttributer                <span class="cov0" title="0">{ return AttrMsg{msg: err.Error()} }</span>
func Errorf(format string, a ...any) HTTPResponseAttributer <span class="cov0" title="0">{ return Error(fmt.Errorf(format, a...)) }</span>
func (my AttrMsg) Register(res *HTTPResponse)               <span class="cov0" title="0">{ res.Msg = my.msg }</span>

func Data(data any) HTTPResponseAttributer     <span class="cov0" title="0">{ return AttrData{data: data} }</span>
func (my AttrData) Register(res *HTTPResponse) <span class="cov0" title="0">{ res.Data = my.data }</span>
</pre>
		
		<pre class="file" id="file126" style="display: none">package request

import (
        "github.com/aid297/aid/validator"
        "github.com/gin-gonic/gin"
)

type (
        UUIDGenerateRequest struct {
                Number         uint8       `json:"number" yaml:"number" toml:"number" v-rule:"required;uint8;range=1,255" v-name:"生成数量"`
                NoSubsTractKey bool        `json:"noSubsTractKey" yaml:"noSubsTractKey" toml:"noSubsTractKey" v-rule:"bool" v-name:"不减去key"`
                IsUpper        bool        `json:"isUpper" yaml:"isUpper" toml:"isUpper" v-rule:"bool" v-name:"是否大写"`
                Version        UUIDVersion `json:"version" yaml:"version" toml:"version" v-rule:"string;in=v1,v4,v6,v7" v-name:"uuid版本"`
        }

        UUIDVersion string
)

const (
        UUIDVersionV1 UUIDVersion = "v1"
        UUIDVersionV4 UUIDVersion = "v4"
        UUIDVersionV6 UUIDVersion = "v6"
        UUIDVersionV7 UUIDVersion = "v7"
)

var UUIDGenerate UUIDGenerateRequest

func (UUIDGenerateRequest) Bind(c *gin.Context) (UUIDGenerateRequest, error) <span class="cov0" title="0">{
        return validator.WithGin[UUIDGenerateRequest](c)
}</span>
</pre>
		
		<pre class="file" id="file127" style="display: none">package response

type UUIDResponse struct {
        UUID string `json:"uuid" yaml:"uuid" toml:"uuid"`
}

var UUID UUIDResponse

func (UUIDResponse) New(uuid string) UUIDResponse <span class="cov0" title="0">{ return UUIDResponse{UUID: uuid} }</span>

type UUIDGenerateResponse struct {
        UUIDs []UUIDResponse `json:"uuids" yaml:"uuids" toml:"uuids"`
}
</pre>
		
		<pre class="file" id="file128" style="display: none">package v1HTTPRoute

import (
        "github.com/gin-gonic/gin"

        "github.com/aid297/aid/web/backend/aid-web-backend-gin/api/httpAPI/v1HTTPAPI"
)

type RezipRoute struct{}

var Rezip RezipRoute

func (*RezipRoute) Register(app *gin.RouterGroup) <span class="cov0" title="0">{
        r := app.Group("rezip")
        </span><span class="cov0" title="0">{
                r.POST("/upload", v1HTTPAPI.APP.Rezip.Upload)
        }</span>
}
</pre>
		
		<pre class="file" id="file129" style="display: none">package v1HTTPRoute

import (
        "github.com/gin-gonic/gin"

        "github.com/aid297/aid/web/backend/aid-web-backend-gin/api/httpAPI/v1HTTPAPI"
)

type (
        UuidRoute struct{}
)

var (
        Uuid UuidRoute
)

func (*UuidRoute) Register(app *gin.RouterGroup) <span class="cov0" title="0">{
        r := app.Group("uuid")
        </span><span class="cov0" title="0">{
                r.POST("/generate", v1HTTPAPI.APP.UUID.Generate)
                r.POST("/versions", v1HTTPAPI.APP.UUID.Versions)
        }</span>
}
</pre>
		
		<pre class="file" id="file130" style="display: none">package route

import (
        "net/http"

        "github.com/aid297/aid/web/backend/aid-web-backend-gin/api/httpAPI"
        "github.com/aid297/aid/web/backend/aid-web-backend-gin/global"
        "github.com/aid297/aid/web/backend/aid-web-backend-gin/middleware/httpMiddleware"
        "github.com/aid297/aid/web/backend/aid-web-backend-gin/middleware/httpMiddleware/v1HTTPMiddleware"
        "github.com/aid297/aid/web/backend/aid-web-backend-gin/route/httpRoute/v1HTTPRoute"

        "github.com/gin-gonic/gin"
)

type IndexRoute struct{}

var Index IndexRoute

func (*IndexRoute) Register(app *gin.Engine) <span class="cov0" title="0">{
        if global.CONFIG.WebService.Cors </span><span class="cov0" title="0">{
                app.Use(v1HTTPMiddleware.Cors())
        }</span>
        <span class="cov0" title="0">app.Use(httpMiddleware.RecoverHandler)

        apiRout := app.Group("api")
        v1Rout := apiRout.Group("v1")
        v1Rout.Use(httpMiddleware.RecoverHandler, v1HTTPMiddleware.Timeout(120))

        </span><span class="cov0" title="0">{
                app.Any("/health/json", httpAPI.APP.Health.JSON)
                app.Any("/health/yaml", httpAPI.APP.Health.YAML)
                app.Any("/health/toml", httpAPI.APP.Health.TOML)
                app.Any("/health", httpAPI.APP.Health.TOML)
                app.StaticFS("/upload/rezip", http.Dir(global.CONFIG.Rezip.OutDir)) // 静态资源 (压缩包)

                v1HTTPRoute.Rezip.Register(v1Rout)
                v1HTTPRoute.Uuid.Register(v1Rout)

                for idx := range global.CONFIG.WebService.StaticDirs </span><span class="cov0" title="0">{
                        app.Static(global.CONFIG.WebService.StaticDirs[idx].URL, global.CONFIG.WebService.StaticDirs[idx].Dir) // 静态资源路由
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file131" style="display: none">package v1HTTPService

import (
        "strings"

        "github.com/aid297/aid/web/backend/aid-web-backend-gin/module/httpModule/v1HTTPModule/request"
        "github.com/aid297/aid/web/backend/aid-web-backend-gin/module/httpModule/v1HTTPModule/response"

        "github.com/gofrs/uuid/v5"
)

type UUIDService struct{}

var UUID UUIDService

// GenerateOne 生成单个UUID
func (UUIDService) GenerateOne(form *request.UUIDGenerateRequest) (response.UUIDResponse, error) <span class="cov0" title="0">{
        var (
                err     error
                u       uuid.UUID
                uuidStr string
        )
        switch form.Version </span>{
        case request.UUIDVersionV1:<span class="cov0" title="0">
                u, err = uuid.NewV1()</span>
        case request.UUIDVersionV4:<span class="cov0" title="0">
                u, err = uuid.NewV4()</span>
        case request.UUIDVersionV6:<span class="cov0" title="0">
                u, err = uuid.NewV6()</span>
        case request.UUIDVersionV7:<span class="cov0" title="0">
                u, err = uuid.NewV7()</span>
        default:<span class="cov0" title="0">
                u, err = uuid.NewV6()</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return response.UUIDResponse{}, err
        }</span>

        <span class="cov0" title="0">uuidStr = u.String()

        if form.IsUpper </span><span class="cov0" title="0">{
                uuidStr = strings.ToUpper(uuidStr)
        }</span>

        <span class="cov0" title="0">if form.NoSubsTractKey </span><span class="cov0" title="0">{
                uuidStr = strings.ReplaceAll(uuidStr, "-", "")
        }</span>

        <span class="cov0" title="0">return response.UUID.New(uuidStr), nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
